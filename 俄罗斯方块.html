<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>ä¿„ç½—æ–¯æ–¹å—</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <!-- éŸ³é¢‘åº“ Howler.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
  <style>
    :root{
  --bg:#0e1322;
  --panel:#151a2e;
  --accent:#4f8cff;
  --text:#e7ebf3;
  --muted:#94a3b8;
  --grid:#1d2544;
  --ghost:#7aa2ff55;
  --cell-gap:1;
  --side-ctrl-w: 100px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,"Segoe UI",Roboto,Helvetica,Arial}
a{color:var(--accent);text-decoration:none}
.app{
  display:grid; gap:12px; padding:12px; height:100%;
  grid-template-rows:auto 1fr auto;
}
header, footer{
  display:flex; align-items:center; justify-content:space-between;
  background:var(--panel); border-radius:10px; padding:8px 12px;
  border:1px solid #263057;
}
header .title{font-weight:700; letter-spacing:.3px;}
header .controls{display:flex; gap:8px; flex-wrap:wrap}
button,select,input{
  background:#1b2140; color:var(--text); border:1px solid #2b345d; border-radius:8px;
  padding:8px 10px; font-size:14px; cursor:pointer;
  transition:transform .08s ease, background .15s ease, box-shadow .15s ease;
}
button:hover{background:#232b50}
button:active{transform:translateY(1px)}
button.primary{background:#3563e9; border-color:#3563e9}
button.primary:hover{background:#2f55c8}
button.danger{background:#dc2626; border-color:#dc2626}
button.danger:hover{background:#b91c1c}
.layout{
  display:grid; gap:12px;
  grid-template-columns: 180px 1fr 180px;
  grid-auto-rows: minmax(0,1fr);
  overflow:hidden;
}
.panel{
  background:var(--panel); border-radius:10px; padding:10px; overflow:auto;
  border:1px solid #263057;
}
.stats{display:grid; gap:6px; font-size:14px}
.stat-line{display:flex; justify-content:space-between; color:var(--muted)}
.stat-value{color:var(--text); font-weight:600}
.right .previews{display:flex; flex-direction:column; gap:8px}
.preview-item, .hold-box{
  background:#10142a; border:1px solid #2b3156; border-radius:8px; padding:8px;
  display:flex; justify-content:center; align-items:center;
}
.preview-title{font-size:12px; color:var(--muted); margin-bottom:6px}
.playfield-wrap{
  position:relative; display:flex; justify-content:center; align-items:center; height:100%;
}
canvas.playfield{background:#0b0f23; border:1px solid #2b3156; border-radius:10px; touch-action:none;}
.overlay{
  position:absolute; inset:0; display:none; align-items:center; justify-content:center;
  background:rgba(10,12,24,.65); backdrop-filter: blur(4px);
  z-index:1000;
}
.overlay.visible{display:flex}
.modal{
  width:min(92vw, 820px); max-height:85vh; overflow:auto;
  background:var(--panel); border:1px solid #2b3156; border-radius:12px; padding:16px;
  box-shadow:0 20px 50px rgba(0,0,0,.35);
}
.modal h3{margin:0 0 8px 0}
.grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}
.row{display:flex; gap:10px; align-items:center; margin:6px 0}
.row label{flex:1; color:var(--muted); font-size:14px}
.row input[type="number"], .row select{width:140px}
.modal .actions{display:flex; justify-content:flex-end; gap:8px; margin-top:12px}
.legend{font-size:12px; color:var(--muted); line-height:1.5}
.badges{display:flex; gap:6px; flex-wrap:wrap; font-size:11px; margin-top:6px}
.badge{background:#1a1f3d; border:1px solid #2b3156; color:var(--muted); padding:2px 6px; border-radius:999px}

/* ========== ç§»åŠ¨ç«¯æ§åˆ¶ ========== */
.mobile-controls{
  display:none; gap:10px; flex-wrap:wrap; justify-content:center; padding:12px;
}
.mobile-controls .btn{
  min-width:70px; padding:14px 16px; border-radius:12px; 
  background:#1b2140; border:2px solid #2b345d;
  user-select:none; touch-action:manipulation; color:var(--text);
  box-shadow:0 3px 0 rgba(0,0,0,.4);
  transition:transform .06s ease, background .12s ease, box-shadow .12s ease;
  font-size:15px; font-weight:500;
}

.mobile-controls .btn[data-act="rotateLeft"],
.mobile-controls .btn[data-act="rotateRight"] {
  background: linear-gradient(135deg, #2d3a6e, #1f2847);
  border-color: #4f8cff;
  color: #4f8cff;
  font-weight: bold;
  box-shadow:0 3px 0 rgba(79,140,255,.3);
}

.mobile-controls .btn:active,
.mobile-controls .btn.pressed{
  transform:translateY(2px);
  box-shadow:0 1px 0 rgba(0,0,0,.5);
}

/* ä¾§è¾¹æ§åˆ¶ */
.mobile-side{ 
  position:absolute; 
  display:none;
  z-index:10;
}

.mobile-left{
  left: 0;
  top: 50%;
  transform: translateY(-50%);
}

.mobile-right{
  right: 0;
  top: 50%;
  transform: translateY(-50%);
}

.mobile-side .btn{
  display:block;
  width:calc(var(--side-ctrl-w) - 16px);
  padding:12px 8px; 
  margin:8px 8px;
  text-align:center;
  border-radius:10px; 
  background:#1b2140; 
  border:2px solid #2b345d; 
  color:var(--text);
  box-shadow:0 3px 0 rgba(0,0,0,.4);
  user-select:none; 
  touch-action:manipulation;
  transition:transform .06s ease, background .12s ease, box-shadow .12s ease;
  font-size:13px;
  font-weight:500;
}

.mobile-side .btn[data-act="rotateLeft"],
.mobile-side .btn[data-act="rotateRight"] {
  background: linear-gradient(135deg, #2d3a6e, #1f2847);
  border-color: #4f8cff;
  color: #4f8cff;
  font-weight: bold;
  box-shadow:0 3px 0 rgba(79,140,255,.3);
}

.mobile-side .btn:active, 
.mobile-side .btn.pressed{
  transform:translateY(2px);
  box-shadow:0 1px 0 rgba(0,0,0,.5);
}

.header-toggle{
  position:fixed; 
  top:10px; 
  left:50%;
  transform:translateX(-50%);
  z-index:100;
  display:none;
  background:#1b2140; 
  color:var(--text); 
  border:2px solid #2b345d; 
  border-radius:999px;
  padding:10px 16px; 
  font-size:13px; 
  box-shadow:0 4px 12px rgba(0,0,0,.4);
}
.header-toggle:active{ transform:translateX(-50%) translateY(1px); }

.combo-notification {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
  z-index: 1000;
  opacity: 0;
  font-size: 48px;
  font-weight: bold;
  text-shadow: 0 0 10px rgba(0,0,0,0.8), 0 0 20px currentColor;
  white-space: nowrap;
}

.combo-notification.show {
  animation: comboAnim 1.2s ease-out forwards;
}

@keyframes comboAnim {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.5);
  }
  20% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.3);
  }
  40% {
    transform: translate(-50%, -50%) scale(1.1);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -70%) scale(0.9);
  }
}

.combo-1 { color: #4f8cff; }
.combo-2 { color: #10b981; }
.combo-3 { color: #f59e0b; }
.combo-4 {
  color: #ef4444;
  font-size: 64px;
  text-shadow: 0 0 20px rgba(239,68,68,0.8), 0 0 40px rgba(239,68,68,0.6);
}
.combo-tspin {
  color: #a855f7;
  font-size: 56px;
  text-shadow: 0 0 20px rgba(168,85,247,0.8), 0 0 40px rgba(168,85,247,0.6);
}
.combo-b2b {
  color: #f97316;
  font-size: 52px;
  text-shadow: 0 0 20px rgba(249,115,22,0.8), 0 0 40px rgba(249,115,22,0.6);
}

.status-indicators {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 8px;
}
.indicator {
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.5px;
  opacity: 0.4;
  transition: opacity 0.3s ease;
}
.indicator.active {
  opacity: 1;
  animation: pulse 1s ease-in-out infinite;
}
.indicator.combo-ind {
  background: linear-gradient(135deg, #4f8cff, #3563e9);
}
.indicator.b2b-ind {
  background: linear-gradient(135deg, #f97316, #ea580c);
}
@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

/* æ¸¸æˆæ¨¡å¼é€‰æ‹© */
.mode-selector {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 12px;
  margin: 16px 0;
}
.mode-card {
  background: #1a1f3d;
  border: 2px solid #2b3156;
  border-radius: 10px;
  padding: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}
.mode-card:hover {
  border-color: #4f8cff;
  transform: translateY(-2px);
}
.mode-card.selected {
  border-color: #4f8cff;
  background: #1f2847;
  box-shadow: 0 0 20px rgba(79, 140, 255, 0.3);
}
.mode-card h4 {
  margin: 0 0 6px 0;
  color: var(--accent);
  font-size: 15px;
}
.mode-card p {
  margin: 0;
  font-size: 12px;
  color: var(--muted);
  line-height: 1.4;
}

/* è®¡æ—¶å™¨æ˜¾ç¤º */
.timer-display {
  font-size: 32px;
  font-weight: bold;
  text-align: center;
  color: var(--accent);
  padding: 12px;
  background: #1a1f3d;
  border-radius: 8px;
  margin: 8px 0;
  font-variant-numeric: tabular-nums;
}
.timer-display.warning {
  color: #f59e0b;
  animation: pulse 1s ease-in-out infinite;
}
.timer-display.danger {
  color: #ef4444;
}

/* é”®ä½è‡ªå®šä¹‰ç•Œé¢ */
.keybind-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin: 12px 0;
}
.keybind-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: #1a1f3d;
  border-radius: 8px;
  border: 1px solid #2b3156;
}
.keybind-label {
  color: var(--muted);
  font-size: 13px;
}
.keybind-button {
  background: #2b345d;
  color: var(--text);
  border: 1px solid #3d4873;
  border-radius: 6px;
  padding: 6px 12px;
  font-size: 12px;
  min-width: 80px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s ease;
}
.keybind-button:hover {
  background: #364070;
}
.keybind-button.listening {
  background: #3563e9;
  border-color: #4f8cff;
  animation: pulse 0.8s ease-in-out infinite;
}

/* æ‰‹æŸ„æŒ‡ç¤ºå™¨ */
.gamepad-indicator {
  display: none;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: #1a1f3d;
  border: 1px solid #2b3156;
  border-radius: 8px;
  font-size: 12px;
  margin: 8px 0;
}
.gamepad-indicator.connected {
  display: flex;
  border-color: #10b981;
}
.gamepad-icon {
  width: 16px;
  height: 16px;
  background: #10b981;
  border-radius: 50%;
  animation: pulse 2s ease-in-out infinite;
}

/* æ’¤é”€/é‡åšæŒ‰é’® */
.undo-controls {
  display: none;
  gap: 6px;
  margin-top: 8px;
}
.undo-controls.visible {
  display: flex;
}
.undo-controls button {
  flex: 1;
  padding: 6px;
  font-size: 12px;
}

/* æŒ–æ˜æ¨¡å¼åƒåœ¾è¡Œé¢„è§ˆ */
.cheese-preview {
  margin-top: 10px;
  padding: 8px;
  background: #1a1f3d;
  border-radius: 8px;
  border: 1px solid #2b3156;
}
.cheese-preview-title {
  font-size: 11px;
  color: var(--muted);
  margin-bottom: 4px;
}
.cheese-bar {
  height: 6px;
  background: #2b345d;
  border-radius: 3px;
  overflow: hidden;
}
.cheese-progress {
  height: 100%;
  background: linear-gradient(90deg, #10b981, #34d399);
  transition: width 0.3s ease;
}

/* ========== å“åº”å¼å¸ƒå±€ ========== */

/* ç«–å±æ¨¡å¼ */
@media (max-width: 980px) and (orientation: portrait){
  .layout{
    grid-template-columns: 1fr; 
    grid-template-rows: auto auto auto; 
    overflow:auto;
  }
  .right, .left{order:2}
  .center{order:1; min-height:55vh}
  
  .mobile-controls{
    display:flex;
    padding:16px 12px;
  }
  .mobile-controls .btn{
    flex:1 1 calc(25% - 8px);
    min-width:70px;
    max-width:120px;
    padding:16px 12px;
    font-size:14px;
  }
  .mobile-side{display:none}
  
  header, footer{
    position:sticky; 
    top:0; 
    z-index:50;
  }
  
  .combo-notification { 
    font-size: 32px; 
  }
  .combo-4 { font-size: 42px; }
  .combo-tspin { font-size: 38px; }
  .combo-b2b { font-size: 36px; }
  
  .header-toggle{ display:none; }
}

/* æ¨ªå±æ¨¡å¼ */
@media (max-width: 980px) and (orientation: landscape){
  .layout{
    grid-template-columns: 120px 1fr 120px;
    grid-template-rows: 1fr;
    overflow:hidden;
  }
  .left, .right{
    order:initial;
    font-size:12px;
  }
  .center{
    min-height:100%;
  }
  
  header{
    display:none;
  }
  header.header-visible{
    display:flex;
    position:fixed;
    left:10px; 
    right:10px; 
    top:50px;
    z-index:100;
    box-shadow:0 8px 20px rgba(0,0,0,.5);
  }
  footer{display:none}

  .mobile-controls{display:none}
  
  .playfield-wrap{
    padding-left: var(--side-ctrl-w);
    padding-right: var(--side-ctrl-w);
  }
  
  .mobile-side{
    display:block;
  }
  
  .header-toggle{ 
    display:inline-flex; 
    align-items:center; 
    gap:6px; 
  }
  
  /* æ¨ªå±æ—¶å³ä¾§é¢æ¿ç‰¹æ®Šå¸ƒå±€ */
  .right {
    display: flex;
    flex-direction: column;
    gap:8px;
    padding:8px;
  }
  
  .right .preview-title {
    order: 1;
    margin-bottom: 4px;
    font-size:11px;
  }
  
  .right .previews {
    order: 2;
    flex:1;
    overflow-y:auto;
  }
  
  .right .previews .preview-item{
    padding:4px;
  }
  
  .right .previews canvas{
    width:100%;
    height:auto;
    max-height:70px;
  }
  
  /* å·¦ä¾§é¢æ¿ä¼˜åŒ– */
  .left{
    padding:8px;
  }
  .left .hold-box{
    margin-bottom:8px;
    padding:6px;
  }
  .left .preview-title{
    font-size:11px;
  }
  .left .stats{
    font-size:12px;
    gap:4px;
  }
  .left .badges{
    display:none;
  }
  
  .combo-notification { 
    font-size: 28px; 
  }
  .combo-4 { font-size: 36px; }
  .combo-tspin { font-size: 32px; }
  .combo-b2b { font-size: 30px; }
}

/* è¶…å°å±å¹•ä¼˜åŒ– */
@media (max-width: 640px) and (orientation: landscape){
  .layout{
    grid-template-columns: 100px 1fr 100px;
  }
  
  :root{
    --side-ctrl-w: 85px;
  }
  
  .mobile-side .btn{
    padding:10px 6px;
    font-size:12px;
    margin:6px 6px;
  }
  
  .left, .right{
    font-size:11px;
  }
  
  .stat-line{
    font-size:11px;
  }
}

/* Tab å¯¼èˆª */
.tab-nav {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
  border-bottom: 2px solid #2b3156;
}
.tab-btn {
  background: transparent;
  border: none;
  border-bottom: 2px solid transparent;
  padding: 8px 16px;
  margin-bottom: -2px;
  cursor: pointer;
  color: var(--muted);
  transition: all 0.2s ease;
}
.tab-btn:hover {
  color: var(--text);
  background: transparent;
}
.tab-btn.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
}
.tab-content {
  display: none;
}
.tab-content.active {
  display: block;
}

/* å±å¹•éœ‡åŠ¨åŠ¨ç”» */
@keyframes screen-shake {
  0%, 100% { transform: translate(0, 0) rotate(0deg); }
  10% { transform: translate(-2px, 1px) rotate(-0.5deg); }
  20% { transform: translate(2px, -1px) rotate(0.5deg); }
  30% { transform: translate(-1px, 2px) rotate(-0.3deg); }
  40% { transform: translate(1px, -2px) rotate(0.3deg); }
  50% { transform: translate(-2px, -1px) rotate(-0.4deg); }
  60% { transform: translate(2px, 1px) rotate(0.4deg); }
  70% { transform: translate(-1px, -2px) rotate(-0.2deg); }
  80% { transform: translate(1px, 2px) rotate(0.2deg); }
  90% { transform: translate(-2px, -1px) rotate(-0.1deg); }
}

.playfield-wrap.shake {
  animation: screen-shake 0.5s ease-in-out;
}

.playfield-wrap.all-clear {
  animation: allClearFlash 0.8s ease-in-out 3;
}

/* Hold åŠ¨ç”» */
@keyframes hold-fly-in {
  0% {
    opacity: 0;
    transform: translateX(-100px) scale(0.5) rotate(-180deg);
  }
  60% {
    transform: translateX(10px) scale(1.1) rotate(10deg);
  }
  100% {
    opacity: 1;
    transform: translateX(0) scale(1) rotate(0deg);
  }
}

@keyframes hold-fly-out {
  0% {
    opacity: 1;
    transform: translateX(0) scale(1) rotate(0deg);
  }
  100% {
    opacity: 0;
    transform: translateX(-100px) scale(0.5) rotate(-180deg);
  }
}

.hold-box.animate-in canvas {
  animation: hold-fly-in 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

.hold-box.animate-out canvas {
  animation: hold-fly-out 0.4s cubic-bezier(0.6, -0.28, 0.735, 0.045);
}

/* åŠ¨æ€èƒŒæ™¯ç²’å­ */
.background-particles {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
  overflow: hidden;
}

.bg-particle {
  position: absolute;
  background: radial-gradient(circle, rgba(79, 140, 255, 0.3), transparent);
  border-radius: 50%;
  animation: float-particle linear infinite;
}

@keyframes float-particle {
  0% {
    transform: translateY(0) translateX(0) scale(1);
    opacity: 0;
  }
  10% {
    opacity: 0.6;
  }
  90% {
    opacity: 0.3;
  }
  100% {
    transform: translateY(-100vh) translateX(50px) scale(0.5);
    opacity: 0;
  }
}

/* æ–¹å—çº¹ç†å…‰æ³½æ•ˆæœ */
.playfield.glossy {
  filter: brightness(1.1) contrast(1.05);
}

/* Level å˜åŒ–é—ªå…‰ */
@keyframes level-flash {
  0%, 100% { 
    box-shadow: 0 0 0 rgba(79, 140, 255, 0);
  }
  50% { 
    box-shadow: 0 0 30px rgba(79, 140, 255, 0.8), 
                inset 0 0 20px rgba(79, 140, 255, 0.3);
  }
}

.playfield.level-up {
  animation: level-flash 0.6s ease-out;
}

/* éŸ³é‡æ§åˆ¶æŒ‰é’® */
.audio-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.audio-toggle {
  background: #1b2140;
  border: 1px solid #2b345d;
  border-radius: 8px;
  padding: 8px 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 16px;
}

.audio-toggle:hover {
  background: #232b50;
  transform: scale(1.05);
}

.audio-toggle.muted {
  opacity: 0.5;
  background: #3d1f1f;
}

@keyframes allClearFlash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.8) contrast(1.2); }
}

/* ========== ç«–å±æç¤º ========== */
.portrait-warning {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, var(--bg) 0%, #1a1f3d 100%);
  z-index: 10000;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

.portrait-warning.show {
  display: flex;
}

.portrait-content {
  text-align: center;
  padding: 40px 20px;
  max-width: 400px;
}

.portrait-icon {
  font-size: 100px;
  margin-bottom: 30px;
  animation: rotate-hint 2s ease-in-out infinite;
  filter: drop-shadow(0 0 20px rgba(79, 140, 255, 0.5));
}

@keyframes rotate-hint {
  0%, 100% { 
    transform: rotate(0deg) scale(1); 
  }
  25% { 
    transform: rotate(-15deg) scale(1.1); 
  }
  50% { 
    transform: rotate(0deg) scale(1); 
  }
  75% { 
    transform: rotate(15deg) scale(1.1); 
  }
}

.portrait-content h2 {
  font-size: 28px;
  margin: 20px 0;
  color: var(--accent);
  font-weight: 700;
  text-shadow: 0 2px 10px rgba(79, 140, 255, 0.3);
}

.portrait-content p {
  font-size: 16px;
  color: var(--muted);
  line-height: 1.8;
  margin-top: 16px;
}

/* åªåœ¨ç§»åŠ¨ç«¯ç«–å±æ—¶å¼ºåˆ¶æ˜¾ç¤º */
@media (max-width: 980px) and (orientation: portrait) {
  .portrait-warning.active {
    display: flex !important;
  }
  
  /* éšè—ä¸»ç•Œé¢ï¼Œé˜²æ­¢ç©¿é€ */
  .portrait-warning.active ~ .app {
    display: none;
  }
}

/* æ¨ªå±æ—¶ç¡®ä¿éšè— */
@media (orientation: landscape) {
  .portrait-warning {
    display: none !important;
  }
}

  </style>
</head>
<body>
<div class="app">
<!-- ç«–å±æç¤ºé®ç½© -->
<div id="portraitWarning" class="portrait-warning">
  <div class="portrait-content">
    <div class="portrait-icon">ğŸ“±</div>
    <h2>è¯·æ—‹è½¬æ‚¨çš„è®¾å¤‡</h2>
    <p>ä¸ºäº†è·å¾—æœ€ä½³æ¸¸æˆä½“éªŒ<br>è¯·å°†è®¾å¤‡æ¨ªå‘æ”¾ç½®</p>
  </div>
</div>
  <header id="topHeader">
    <div class="title">ä¿„ç½—æ–¯æ–¹å—</div>
    <div class="controls">
      <button id="btnStart" class="primary">å¼€å§‹/ç»§ç»­</button>
      <button id="btnPause">æš‚åœ</button>
      <button id="btnRestart">é‡æ–°å¼€å§‹</button>
      <button id="btnSettings">è®¾ç½®</button>
    </div>
  </header>

  <button class="header-toggle" id="btnHeaderToggle">â˜° èœå•</button>

  <div class="layout">
    <div class="panel left">
      <div class="preview-title">æš‚å­˜ (C/Shift)</div>
      <div class="hold-box" style="margin-bottom:10px">
        <canvas id="hold" width="140" height="140"></canvas>
      </div>
      
      <div class="stat-line" style="margin-bottom: 8px;">
        <span>æ¨¡å¼</span>
        <strong class="stat-value" id="modeDisplay">é©¬æ‹‰æ¾</strong>
      </div>

      <div id="timerContainer" style="display:none;">
        <div class="timer-display" id="timerDisplay">00:00.00</div>
      </div>

      <div id="cheeseContainer" class="cheese-preview" style="display:none;">
        <div class="cheese-preview-title">åƒåœ¾è¡Œå‰©ä½™</div>
        <div class="stat-line">
          <span>å‰©ä½™</span>
          <strong class="stat-value" id="cheeseRemaining">0</strong>
        </div>
        <div class="cheese-bar">
          <div class="cheese-progress" id="cheeseProgress" style="width: 0%"></div>
        </div>
      </div>

      <div class="gamepad-indicator" id="gamepadIndicator">
        <div class="gamepad-icon"></div>
        <span id="gamepadName">æ‰‹æŸ„å·²è¿æ¥</span>
      </div>

      <div class="stats">
        <div class="stat-line" id="scoreRow">
          <span>åˆ†æ•°</span>
          <strong class="stat-value" id="score">0</strong>
        </div>
        <div class="stat-line">
          <span>çº§åˆ«</span>
          <strong class="stat-value" id="level">1</strong>
        </div>
        <div class="stat-line">
          <span>è¡Œæ•°</span>
          <strong class="stat-value" id="lines">0</strong>
        </div>
        <div class="stat-line">
          <span>è¿å‡»</span>
          <strong class="stat-value" id="combo">0</strong>
        </div>
        
        <div class="status-indicators">
          <div class="indicator combo-ind" id="comboInd">COMBO</div>
          <div class="indicator b2b-ind" id="b2bInd">B2B</div>
        </div>

        <div class="undo-controls" id="undoControls">
          <button id="btnUndo" title="æ’¤é”€ (Ctrl+Z)">â†¶ æ’¤é”€</button>
          <button id="btnRedo" title="é‡åš (Ctrl+Y)">â†· é‡åš</button>
        </div>

        <div class="badges">
          <span class="badge">è‡ªå®šä¹‰é”®ä½</span>
          <span class="badge">æ‰‹æŸ„æ”¯æŒ</span>
          <span class="badge">éœ‡åŠ¨åé¦ˆ</span>
          <span class="badge">å¤šç§æ¨¡å¼</span>
        </div>
      </div>
    </div>

    <div class="panel center">
      <div class="playfield-wrap">
        <div class="mobile-side mobile-left" id="mobileLeft">
          <div class="btn" data-act="left">â† å·¦</div>
          <div class="btn" data-act="rotateLeft">â†º å·¦æ—‹</div>
          <div class="btn" data-act="soft">â†“ è½¯é™</div>
          <div class="btn" data-act="hold">Hold</div>
        </div>
        
        <canvas id="playfield" class="playfield" width="300" height="600"></canvas>
        
        <div class="mobile-side mobile-right" id="mobileRight">
          <div class="btn" data-act="right">å³ â†’</div>
          <div class="btn" data-act="rotateRight">â†» å³æ—‹</div>
          <div class="btn" data-act="hard">â¤“ ç¡¬é™</div>
          <div class="btn" data-act="pause">â¸ æš‚åœ</div>
        </div>
      </div>


        <div class="combo-notification" id="comboNotif"></div>

        <div class="overlay" id="overlay">
          <div class="modal">
            <h3 id="modalTitle">æ¸¸æˆè®¾ç½®</h3>
            
            <div class="tab-nav">
              <button class="tab-btn active" data-tab="mode">æ¸¸æˆæ¨¡å¼</button>
              <button class="tab-btn" data-tab="general">å¸¸è§„è®¾ç½®</button>
              <button class="tab-btn" data-tab="controls">æ§åˆ¶è®¾ç½®</button>
            </div>

            <div class="tab-content active" id="tabMode">
              <div class="mode-selector">
                <div class="mode-card selected" data-mode="marathon">
                  <h4>ğŸƒ é©¬æ‹‰æ¾æ¨¡å¼</h4>
                  <p>ç»å…¸ç©æ³•ï¼Œéšåˆ†æ•°/è¡Œæ•°å‡çº§ï¼ŒæŒ‘æˆ˜é«˜åˆ†</p>
                </div>
                <div class="mode-card" data-mode="sprint">
                  <h4>âš¡ 40è¡Œç«é€Ÿ</h4>
                  <p>æ¶ˆé™¤40è¡Œï¼Œè®°å½•æœ€å¿«æ—¶é—´ï¼Œç«æŠ€é¦–é€‰</p>
                </div>
                <div class="mode-card" data-mode="ultra">
                  <h4>â±ï¸ é™æ—¶æ‰“åˆ†</h4>
                  <p>2åˆ†é’Ÿé™æ—¶ï¼Œè¿½æ±‚æœ€é«˜åˆ†æ•°</p>
                </div>
                <div class="mode-card" data-mode="cheese">
                  <h4>â›ï¸ æŒ–æ˜æ¨¡å¼</h4>
                  <p>æ¸…é™¤é¢„å¡«å……çš„åƒåœ¾è¡Œï¼Œè€ƒéªŒæŒ–æ˜æŠ€å·§</p>
                </div>
                <div class="mode-card" data-mode="master">
                  <h4>ğŸ‘‘ å¤§å¸ˆæ¨¡å¼</h4>
                  <p>20Gé‡åŠ›ï¼ŒæçŸ­é”å»¶ï¼Œç¡¬æ ¸æŒ‘æˆ˜</p>
                </div>
                <div class="mode-card" data-mode="practice">
                  <h4>ğŸ“š ç»ƒä¹ æ¨¡å¼</h4>
                  <p>æ”¯æŒæ’¤é”€/é‡åšï¼Œé€‚åˆç»ƒä¹ æŠ€å·§</p>
                </div>
              </div>

              <div id="cheeseSettings" style="display:none; margin-top:12px;">
                <div class="row">
                  <label>åƒåœ¾è¡Œæ•°é‡</label>
                  <input id="cfgCheeseLines" type="number" min="5" max="18" value="10">
                </div>
              </div>

              <div id="ultraSettings" style="display:none; margin-top:12px;">
                <div class="row">
                  <label>æ—¶é—´é™åˆ¶ï¼ˆç§’ï¼‰</label>
                  <input id="cfgUltraTime" type="number" min="60" max="300" value="120">
                </div>
              </div>
            </div>

            <div class="tab-content" id="tabGeneral">
              <div class="grid2">
                <div class="row">
                  <label>åˆ—æ•°ï¼ˆå®½åº¦ï¼‰</label>
                  <input id="cfgCols" type="number" min="6" max="20" step="1" value="10">
                </div>
                <div class="row">
                  <label>è¡Œæ•°ï¼ˆé«˜åº¦ï¼‰</label>
                  <input id="cfgRows" type="number" min="12" max="40" step="1" value="20">
                </div>
                <div class="row">
                  <label>é¢„è§ˆæ•°é‡</label>
                  <input id="cfgPreview" type="number" min="1" max="6" step="1" value="5">
                </div>
                <div class="row">
                  <label>èµ·å§‹çº§åˆ«</label>
                  <input id="cfgStartLevel" type="number" min="1" max="20" step="1" value="1">
                </div>
                <div class="row">
                  <label>æ˜¾ç¤ºé˜´å½±ï¼ˆGhostï¼‰</label>
                  <select id="cfgGhost"><option value="on">å¼€å¯</option><option value="off">å…³é—­</option></select>
                </div>
                <div class="row">
                  <label>é”å»¶è¿Ÿï¼ˆmsï¼‰</label>
                  <input id="cfgLockDelay" type="number" min="200" max="2000" step="50" value="500">
                </div>
                <div class="row">
                  <label>DAS å»¶è¿Ÿï¼ˆmsï¼‰</label>
                  <input id="cfgDAS" type="number" min="0" max="300" step="10" value="100">
                </div>
                <div class="row">
                  <label>ARR é€Ÿåº¦ï¼ˆmsï¼‰</label>
                  <input id="cfgARR" type="number" min="0" max="100" step="5" value="20">
                </div>
                <div class="row">
                  <label>æ–¹å—é…è‰²</label>
                  <select id="cfgSkin">
                    <option value="classic">ç»å…¸</option>
                    <option value="pastel">é©¬å¡é¾™</option>
                    <option value="neon">éœ“è™¹</option>
                  </select>
                </div>
                <div class="row">
                  <label>éœ‡åŠ¨åé¦ˆ</label>
                  <select id="cfgVibration">
                    <option value="on">å¼€å¯</option>
                    <option value="off">å…³é—­</option>
                  </select>
                </div>
              </div>
            </div>

            <div class="tab-content" id="tabControls">
              <div style="margin-bottom: 12px;">
                <button id="btnResetKeys" class="danger" style="width: 100%;">æ¢å¤é»˜è®¤é”®ä½</button>
              </div>
              <div class="keybind-grid" id="keybindGrid"></div>
              <div class="legend" style="margin-top: 12px;">
                <strong>æç¤ºï¼š</strong>ç‚¹å‡»æŒ‰é’®åæŒ‰ä¸‹æƒ³è¦ç»‘å®šçš„é”®ã€‚æ”¯æŒé”®ç›˜å’Œæ‰‹æŸ„æŒ‰é’®ã€‚
              </div>
            </div>

            <div class="actions">
              <button id="btnCloseSettings">å–æ¶ˆ</button>
              <button id="btnSaveStart" class="primary">ä¿å­˜å¹¶å¼€å§‹</button>
            </div>
          </div>
        </div>


      <div class="mobile-controls" id="mobileControls">
        <div class="btn" data-act="left">â† å·¦</div>
        <div class="btn" data-act="right">å³ â†’</div>
        <div class="btn" data-act="rotateLeft">â†º å·¦æ—‹</div>
        <div class="btn" data-act="rotateRight">â†» å³æ—‹</div>
        <div class="btn" data-act="soft">â†“ è½¯é™</div>
        <div class="btn" data-act="hard">â¤“ ç¡¬é™</div>
        <div class="btn" data-act="hold">Hold</div>
        <div class="btn" data-act="pause">â¸ æš‚åœ</div>
      </div>
    </div>

    <div class="panel right">  
      <div class="preview-title">ä¸‹ä¸€ä¸ªæ–¹å—é¢„è§ˆ</div>  
      <div class="previews" id="previews"></div>  
    </div>  
  </div>

  <footer>
    <div>ä¸“ä¸šç«æŠ€ç‰ˆï¼šå¤šæ¨¡å¼ | è‡ªå®šä¹‰é”®ä½ | æ‰‹æŸ„æ”¯æŒ | éœ‡åŠ¨åé¦ˆ</div>
  </footer>
</div>

<script>
(()=>{

// ========== ç«–å±æ£€æµ‹ç³»ç»Ÿ ==========
let wasPortraitPaused = false; // è®°å½•æ˜¯å¦å› ç«–å±è€Œæš‚åœ

function checkOrientation() {
  const portraitWarning = document.getElementById('portraitWarning');
  if (!portraitWarning) return;
  
  const isMobile = window.innerWidth <= 980;
  const isPortrait = window.innerHeight > window.innerWidth;
  
  if (isMobile && isPortrait) {
    // è¿›å…¥ç«–å±æ¨¡å¼
    portraitWarning.classList.add('show');
    portraitWarning.classList.add('active');
    
    // å¦‚æœæ¸¸æˆæ­£åœ¨è¿è¡Œä¸”æœªæš‚åœï¼Œè‡ªåŠ¨æš‚åœ
    if (running && !paused && !gameOver) {
      togglePause();
      wasPortraitPaused = true;
    }
  } else {
    // é€€å‡ºç«–å±æ¨¡å¼ï¼ˆæ¨ªå±æˆ–éç§»åŠ¨ç«¯ï¼‰
    const wasShowing = portraitWarning.classList.contains('show');
    portraitWarning.classList.remove('show');
    portraitWarning.classList.remove('active');
    
    // å¦‚æœæ˜¯ä»ç«–å±åˆ‡æ¢åˆ°æ¨ªå±ï¼Œä¸”ä¹‹å‰å› ç«–å±è€Œæš‚åœï¼Œè‡ªåŠ¨æ¢å¤
    if (wasShowing && wasPortraitPaused && running && paused && !gameOver) {
      togglePause();
      wasPortraitPaused = false;
    }
  }
}

function initOrientationDetection() {
  // ç›‘å¬å±å¹•æ–¹å‘å˜åŒ–
  window.addEventListener('orientationchange', () => {
    setTimeout(checkOrientation, 100); // å»¶è¿Ÿä»¥ç¡®ä¿è·å–æ­£ç¡®çš„å°ºå¯¸
  });
  
  // ç›‘å¬çª—å£å¤§å°å˜åŒ–
  window.addEventListener('resize', checkOrientation);
  
  // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶ä¹Ÿæ£€æµ‹
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      setTimeout(checkOrientation, 100);
    }
  });
  
  // åˆå§‹æ£€æµ‹
  setTimeout(checkOrientation, 100);
}

// ========== éŸ³é¢‘ç³»ç»Ÿ ==========
class AudioSystem {
  constructor() {
    this.enabled = true;
    this.musicVolume = 0.3;
    this.sfxVolume = 0.5;
    this.sounds = {};
    this.currentBGM = null;
    this.initSounds();
  }

  initSounds() {
    // ä½¿ç”¨ Web Audio API ç”ŸæˆéŸ³æ•ˆ
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // ç”±äºæ— æ³•ä½¿ç”¨å¤–éƒ¨éŸ³é¢‘æ–‡ä»¶ï¼Œæˆ‘ä»¬ä½¿ç”¨ç¨‹åºç”ŸæˆéŸ³æ•ˆ
    this.generateSounds();
  }

  generateSounds() {
    // è¿™é‡Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªç®€å•çš„éŸ³æ•ˆç”Ÿæˆç³»ç»Ÿ
    this.soundConfigs = {
      move: { freq: 200, duration: 0.05, type: 'square' },
      rotate: { freq: 400, duration: 0.08, type: 'sine' },
      softDrop: { freq: 150, duration: 0.03, type: 'triangle' },
      hardDrop: { freq: 100, duration: 0.15, type: 'sawtooth', envelope: 'punch' },
      lock: { freq: 300, duration: 0.1, type: 'square' },
      lineClear1: { freq: 440, duration: 0.2, type: 'sine' },
      lineClear2: { freq: 554, duration: 0.25, type: 'sine' },
      lineClear3: { freq: 659, duration: 0.3, type: 'sine' },
      lineClear4: { freq: 880, duration: 0.4, type: 'sine', envelope: 'swell' },
      tetris: { 
        freq: [523, 659, 784, 1046], 
        duration: 0.6, 
        type: 'sine', 
        envelope: 'arpeggio' 
      },
      hold: { freq: 350, duration: 0.12, type: 'triangle' },
      levelUp: { 
        freq: [440, 554, 659, 880], 
        duration: 0.5, 
        type: 'sine', 
        envelope: 'ascending' 
      },
      gameOver: { 
        freq: [440, 392, 349, 330], 
        duration: 1.0, 
        type: 'sawtooth', 
        envelope: 'descending' 
      },
      combo: { freq: 600, duration: 0.15, type: 'sine', envelope: 'bounce' }
    };
  }

  playSound(soundName, volumeMultiplier = 1.0) {
    if (!this.enabled || !this.audioContext) return;
    
    const config = this.soundConfigs[soundName];
    if (!config) return;

    try {
      const now = this.audioContext.currentTime;
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      oscillator.type = config.type;
      
      const volume = this.sfxVolume * volumeMultiplier;
      
      // æ ¹æ®ä¸åŒçš„åŒ…ç»œç±»å‹è®¾ç½®éŸ³é‡å˜åŒ–
      if (config.envelope === 'punch') {
        gainNode.gain.setValueAtTime(volume, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + config.duration);
      } else if (config.envelope === 'swell') {
        gainNode.gain.setValueAtTime(0.01, now);
        gainNode.gain.exponentialRampToValueAtTime(volume, now + config.duration * 0.3);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + config.duration);
      } else if (config.envelope === 'bounce') {
        gainNode.gain.setValueAtTime(volume, now);
        gainNode.gain.setValueAtTime(volume * 0.5, now + config.duration * 0.3);
        gainNode.gain.setValueAtTime(volume, now + config.duration * 0.6);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + config.duration);
      } else if (config.envelope === 'arpeggio' || config.envelope === 'ascending' || config.envelope === 'descending') {
        // å’Œå¼¦/éŸ³é˜¶æ•ˆæœ
        const freqs = Array.isArray(config.freq) ? config.freq : [config.freq];
        const noteTime = config.duration / freqs.length;
        
        freqs.forEach((freq, i) => {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          
          osc.connect(gain);
          gain.connect(this.audioContext.destination);
          
          osc.type = config.type;
          osc.frequency.setValueAtTime(freq, now + i * noteTime);
          
          gain.gain.setValueAtTime(volume, now + i * noteTime);
          gain.gain.exponentialRampToValueAtTime(0.01, now + (i + 1) * noteTime);
          
          osc.start(now + i * noteTime);
          osc.stop(now + (i + 1) * noteTime);
        });
        
        return; // æå‰è¿”å›ï¼Œé¿å…ä¸‹é¢çš„ start/stop
      } else {
        // é»˜è®¤åŒ…ç»œ
        gainNode.gain.setValueAtTime(volume, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + config.duration);
      }
      
      oscillator.frequency.setValueAtTime(config.freq, now);
      oscillator.start(now);
      oscillator.stop(now + config.duration);
      
    } catch (e) {
      console.warn('éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', e);
    }
  }

  playLineClear(lineCount) {
    if (lineCount === 4) {
      this.playSound('tetris', 1.2);
    } else if (lineCount === 3) {
      this.playSound('lineClear3');
    } else if (lineCount === 2) {
      this.playSound('lineClear2');
    } else if (lineCount === 1) {
      this.playSound('lineClear1');
    }
  }

  playComboSound(comboCount) {
    const volumeMultiplier = Math.min(1.5, 1.0 + comboCount * 0.1);
    this.playSound('combo', volumeMultiplier);
  }

  startBGM(level) {
    if (!this.enabled || !this.audioContext) return;
    
    // åœæ­¢å½“å‰BGM
    this.stopBGM();
    
    // åˆ›å»ºç®€å•çš„èƒŒæ™¯éŸ³ä¹å¾ªç¯
    const tempo = Math.min(180, 120 + level * 5); // BPMéšlevelå¢åŠ 
    const beatDuration = 60 / tempo;
    
    // ç®€å•çš„èŠ‚å¥å¾ªç¯
    this.bgmInterval = setInterval(() => {
      if (!this.enabled) return;
      
      const now = this.audioContext.currentTime;
      const osc = this.audioContext.createOscillator();
      const gain = this.audioContext.createGain();
      
      osc.connect(gain);
      gain.connect(this.audioContext.destination);
      
      // éšæœºéŸ³ç¬¦è¥é€ æ°›å›´
      const notes = [261.63, 293.66, 329.63, 392, 440]; // C, D, E, G, A
      const randomNote = notes[Math.floor(Math.random() * notes.length)];
      
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(randomNote, now);
      
      const volume = this.musicVolume * 0.1; // å¾ˆä½çš„éŸ³é‡ä½œä¸ºèƒŒæ™¯
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + beatDuration * 0.5);
      
      osc.start(now);
      osc.stop(now + beatDuration * 0.5);
      
    }, beatDuration * 1000);
  }

  stopBGM() {
    if (this.bgmInterval) {
      clearInterval(this.bgmInterval);
      this.bgmInterval = null;
    }
  }

  toggle() {
    this.enabled = !this.enabled;
    if (!this.enabled) {
      this.stopBGM();
    }
    return this.enabled;
  }

  setMusicVolume(vol) {
    this.musicVolume = Math.max(0, Math.min(1, vol));
  }

  setSFXVolume(vol) {
    this.sfxVolume = Math.max(0, Math.min(1, vol));
  }
}

// å…¨å±€éŸ³é¢‘ç³»ç»Ÿå®ä¾‹
let audioSystem = null;

// ========== å±å¹•éœ‡åŠ¨ç³»ç»Ÿ ==========
class ScreenShake {
  constructor(element) {
    this.element = element;
    this.shaking = false;
  }

  shake(intensity = 1, duration = 500) {
    if (this.shaking) return;
    
    this.shaking = true;
    this.element.classList.add('shake');
    
    // æ ¹æ®å¼ºåº¦è°ƒæ•´CSSå˜é‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
    this.element.style.setProperty('--shake-intensity', intensity);
    
    setTimeout(() => {
      this.element.classList.remove('shake');
      this.shaking = false;
    }, duration);
  }

  smallShake() {
    this.shake(0.5, 200);
  }

  mediumShake() {
    this.shake(1.0, 400);
  }

  bigShake() {
    this.shake(1.5, 600);
  }
}

let screenShaker = null;

// ========== åŠ¨æ€èƒŒæ™¯ç²’å­ç³»ç»Ÿ ==========
class BackgroundParticles {
  constructor(container) {
    this.container = container;
    this.particles = [];
    this.maxParticles = 15;
    this.colors = ['#4f8cff', '#3563e9', '#5b9fff', '#6ba5ff'];
    this.init();
  }

  init() {
    // åˆ›å»ºç²’å­å®¹å™¨
    this.particleContainer = document.createElement('div');
    this.particleContainer.className = 'background-particles';
    this.container.insertBefore(this.particleContainer, this.container.firstChild);
    
    // åˆå§‹ç”Ÿæˆä¸€äº›ç²’å­
    for (let i = 0; i < this.maxParticles; i++) {
      setTimeout(() => this.createParticle(), i * 300);
    }
  }

  createParticle() {
    const particle = document.createElement('div');
    particle.className = 'bg-particle';
    
    const size = 20 + Math.random() * 60;
    const startX = Math.random() * 100;
    const duration = 8 + Math.random() * 10;
    const delay = Math.random() * 5;
    const color = this.colors[Math.floor(Math.random() * this.colors.length)];
    
    particle.style.width = size + 'px';
    particle.style.height = size + 'px';
    particle.style.left = startX + '%';
    particle.style.bottom = '-' + size + 'px';
    particle.style.background = `radial-gradient(circle, ${color}40, transparent)`;
    particle.style.animationDuration = duration + 's';
    particle.style.animationDelay = delay + 's';
    
    this.particleContainer.appendChild(particle);
    
    // åŠ¨ç”»ç»“æŸåç§»é™¤å¹¶åˆ›å»ºæ–°ç²’å­
    particle.addEventListener('animationend', () => {
      particle.remove();
      this.createParticle();
    });
  }

  updateLevel(level) {
    // æ ¹æ®çº§åˆ«æ”¹å˜ç²’å­é¢œè‰²
    const levelColors = {
      1: ['#4f8cff', '#3563e9', '#5b9fff', '#6ba5ff'],
      5: ['#10b981', '#34d399', '#6ee7b7', '#a7f3d0'],
      10: ['#f59e0b', '#fbbf24', '#fcd34d', '#fde68a'],
      15: ['#ef4444', '#f87171', '#fca5a5', '#fecaca'],
      20: ['#a855f7', '#c084fc', '#d8b4fe', '#e9d5ff']
    };
    
    // æ‰¾åˆ°æœ€æ¥è¿‘çš„levelé…è‰²
    let targetLevel = 1;
    for (const lvl in levelColors) {
      if (level >= parseInt(lvl)) {
        targetLevel = parseInt(lvl);
      }
    }
    
    this.colors = levelColors[targetLevel];
  }

  clear() {
    this.particleContainer.innerHTML = '';
  }
}

let bgParticles = null;

  // ========== é…è‰²ä¸»é¢˜ ==========
const SKINS = {
  classic: {
    I:'#00f0f0', O:'#f0f000', T:'#a000f0', S:'#00f000', Z:'#f00000', J:'#0000f0', L:'#f0a000',
    G:'#606060',
    ghost:'rgba(122,162,255,0.45)',
    texture: 'flat'
  },
  pastel: {
    I:'#9be7ff', O:'#fff59b', T:'#d1b3ff', S:'#b2f7b2', Z:'#ffb3b3', J:'#b3c6ff', L:'#ffd1a6',
    G:'#a0a0a0',
    ghost:'rgba(147,197,253,0.45)',
    texture: 'flat'
  },
  neon: {
    I:'#22d3ee', O:'#facc15', T:'#a78bfa', S:'#34d399', Z:'#fb7185', J:'#60a5fa', L:'#f59e0b',
    G:'#505050',
    ghost:'rgba(56,189,248,0.5)',
    texture: 'glow'
  },
  glossy: {
    I:'#00d4e8', O:'#ffd700', T:'#b24bf3', S:'#00e676', Z:'#ff1744', J:'#2979ff', L:'#ff6d00',
    G:'#707070',
    ghost:'rgba(122,162,255,0.45)',
    texture: 'glossy'
  },
  retro: {
    I:'#00ffff', O:'#ffff00', T:'#ff00ff', S:'#00ff00', Z:'#ff0000', J:'#0000ff', L:'#ff7f00',
    G:'#808080',
    ghost:'rgba(255,255,255,0.3)',
    texture: 'pixel'
  },
  minimal: {
    I:'#e0e0e0', O:'#e0e0e0', T:'#e0e0e0', S:'#e0e0e0', Z:'#e0e0e0', J:'#e0e0e0', L:'#e0e0e0',
    G:'#909090',
    ghost:'rgba(200,200,200,0.4)',
    texture: 'outline'
  }
};

  
const SRS_STATES = {
    I: {
        0: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
        1: [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]],
        2: [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]],
        3: [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]]
    },
    O: {
        0: [[1,1], [1,1]],
        1: [[1,1], [1,1]],
        2: [[1,1], [1,1]],
        3: [[1,1], [1,1]]
    },
    T: {
        0: [[0,1,0], [1,1,1], [0,0,0]],
        1: [[0,1,0], [0,1,1], [0,1,0]],
        2: [[0,0,0], [1,1,1], [0,1,0]],
        3: [[0,1,0], [1,1,0], [0,1,0]]
    },
    S: {
        0: [[0,1,1], [1,1,0], [0,0,0]],
        1: [[0,1,0], [0,1,1], [0,0,1]],
        2: [[0,0,0], [0,1,1], [1,1,0]],
        3: [[1,0,0], [1,1,0], [0,1,0]]
    },
    Z: {
        0: [[1,1,0], [0,1,1], [0,0,0]],
        1: [[0,0,1], [0,1,1], [0,1,0]],
        2: [[0,0,0], [1,1,0], [0,1,1]],
        3: [[0,1,0], [1,1,0], [1,0,0]]
    },
    J: {
        0: [[1,0,0], [1,1,1], [0,0,0]],
        1: [[0,1,1], [0,1,0], [0,1,0]],
        2: [[0,0,0], [1,1,1], [0,0,1]],
        3: [[0,1,0], [0,1,0], [1,1,0]]
    },
    L: {
        0: [[0,0,1], [1,1,1], [0,0,0]],
        1: [[0,1,0], [0,1,0], [0,1,1]],
        2: [[0,0,0], [1,1,1], [1,0,0]],
        3: [[1,1,0], [0,1,0], [0,1,0]]
    }
};

const SHAPES = {
    I: SRS_STATES.I[0],
    O: SRS_STATES.O[0],
    T: SRS_STATES.T[0],
    S: SRS_STATES.S[0],
    Z: SRS_STATES.Z[0],
    J: SRS_STATES.J[0],
    L: SRS_STATES.L[0]
};
  
  const TYPES = ['I','O','T','L','J','S','Z'];

  const SRS_KICKS_JLSTZ = {
  '0->1': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '1->0': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '1->2': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '2->1': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '2->3': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
  '3->2': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '3->0': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '0->3': [[0,0],[1,0],[1,-1],[0,2],[1,2]]
};

  const SRS_KICKS_I = {
    '0->1': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    '1->0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    '1->2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
    '2->1': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    '2->3': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    '3->2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    '3->0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    '0->3': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]]
  };

  // ========== DOM å…ƒç´  ==========
  const cvs = document.getElementById('playfield');
  const ctx = cvs.getContext('2d');
  const holdCanvas = document.getElementById('hold');
  const holdCtx = holdCanvas.getContext('2d');
  const previewsEl = document.getElementById('previews');
  const comboNotif = document.getElementById('comboNotif');

  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const comboEl = document.getElementById('combo');
  const comboInd = document.getElementById('comboInd');
  const b2bInd = document.getElementById('b2bInd');
  const scoreRow = document.getElementById('scoreRow');
  const overlay = document.getElementById('overlay');
  const modeDisplayEl = document.getElementById('modeDisplay');
  const timerContainer = document.getElementById('timerContainer');
  const timerDisplay = document.getElementById('timerDisplay');
  const cheeseContainer = document.getElementById('cheeseContainer');
  const cheeseRemaining = document.getElementById('cheeseRemaining');
  const cheeseProgress = document.getElementById('cheeseProgress');
  const gamepadIndicator = document.getElementById('gamepadIndicator');
  const gamepadName = document.getElementById('gamepadName');

  const topHeader = document.getElementById('topHeader');
  const btnHeaderToggle = document.getElementById('btnHeaderToggle');

  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');
  const btnSettings = document.getElementById('btnSettings');
  const btnCloseSettings = document.getElementById('btnCloseSettings');
  const btnSaveStart = document.getElementById('btnSaveStart');
  const btnUndo = document.getElementById('btnUndo');
  const btnRedo = document.getElementById('btnRedo');
  const undoControls = document.getElementById('undoControls');
  const btnResetKeys = document.getElementById('btnResetKeys');

  const cfgCols = document.getElementById('cfgCols');
  const cfgRows = document.getElementById('cfgRows');
  const cfgPreview = document.getElementById('cfgPreview');
  const cfgStartLevel = document.getElementById('cfgStartLevel');
  const cfgGhost = document.getElementById('cfgGhost');
  const cfgLockDelay = document.getElementById('cfgLockDelay');
  const cfgDAS = document.getElementById('cfgDAS');
  const cfgARR = document.getElementById('cfgARR');
  const cfgSkin = document.getElementById('cfgSkin');
  const cfgVibration = document.getElementById('cfgVibration');
  const cfgCheeseLines = document.getElementById('cfgCheeseLines');
  const cfgUltraTime = document.getElementById('cfgUltraTime');

  const mobileControlsEl = document.getElementById('mobileControls');
  const mobileLeftEl = document.getElementById('mobileLeft');
  const mobileRightEl = document.getElementById('mobileRight');
  const keybindGrid = document.getElementById('keybindGrid');

  // ========== æ¸¸æˆçŠ¶æ€ ==========
  let COLS = 10, ROWS = 20;
  let BLOCK = 30;
  let board = createMatrix(COLS, ROWS);
  let running = false, paused = false, gameOver = false;
  let skin = SKINS.classic;

  let previewCount = 5;
  let bag = [];
  let queue = [];

  let holdType = null;
  let holdLocked = false;

  let piece = null;
  
  let score = 0, lines = 0, level = 1;
  let startLevel = 1;

  let combo = 0;
  let b2bCount = 0;
  let lastClearWasSpecial = false;

  let lastActionWasRotate = false;
  let tSpinType = null;

  let lastKickIndex = 0;

  let particles = [];

  let hardDropping = false;
  let hardDropStartY = 0;
  let hardDropTargetY = 0;
  let hardDropCurrentY = 0;
  let hardDropSpeed = 3;

  let clearingLines = false;
  let clearAnimationTimer = 0;
  const CLEAR_ANIMATION_DURATION = 800;

  let gravity = 800;
  const levelSpeed = lvl => Math.max(80, 900 - (lvl-1)*60);
  let dropTimer = 0;
  let lastTS = 0;

  let lockDelay = 500;
  let lockTimer = 0;
  let touchingGround = false;
  const LOCK_RESET_LIMIT = 15;
  const MAX_GROUND_LOCK_TIME = 2000;
  let lockResets = 0;
  let groundTime = 0;

  let ghostEnabled = true;

  let DAS = 100;
  let ARR = 20;
  let keyState = {};
  let dasTimer = {};
  let arrTimer = {};

  let touchStartX=0, touchStartY=0, touchStartTime=0;

  let pausedBeforeOverlay = false;
  let vibrationEnabled = true;

  // ========== æ¸¸æˆæ¨¡å¼ ==========
  let gameMode = 'marathon'; // marathon, sprint, ultra, cheese, master, practice
  const MODE_NAMES = {
    marathon: 'é©¬æ‹‰æ¾',
    sprint: '40è¡Œç«é€Ÿ',
    ultra: 'é™æ—¶æ‰“åˆ†',
    cheese: 'æŒ–æ˜æ¨¡å¼',
    master: 'å¤§å¸ˆæ¨¡å¼',
    practice: 'ç»ƒä¹ æ¨¡å¼'
  };

  // è®¡æ—¶å™¨
  let gameTimer = 0;
  let timerRunning = false;
  let ultraTimeLimit = 120;

  // æŒ–æ˜æ¨¡å¼
  let cheeseLines = 10;
  let initialCheeseLines = 10;

  // æ’¤é”€/é‡åšç³»ç»Ÿ
  let historyStates = [];
  let historyIndex = -1;
  const MAX_HISTORY = 50;

  // ========== é”®ä½ç»‘å®šç³»ç»Ÿ ==========
  const DEFAULT_KEYBINDS = {
    moveLeft: ['ArrowLeft'],
    moveRight: ['ArrowRight'],
    softDrop: ['ArrowDown'],
    hardDrop: [' ', 'Space'],
    rotateRight: ['ArrowUp', 'x', 'X'],
    rotateLeft: ['z', 'Z', 'Control'],
    hold: ['c', 'C', 'Shift'],
    pause: ['p', 'P', 'Escape']
  };

  let keyBindings = JSON.parse(JSON.stringify(DEFAULT_KEYBINDS));
  let listeningForKey = null;

  // æ‰‹æŸ„ç»‘å®š
  const GAMEPAD_BINDINGS = {
    moveLeft: [14], // D-Pad Left
    moveRight: [15], // D-Pad Right
    softDrop: [13], // D-Pad Down
    hardDrop: [0], // A/Cross
    rotateRight: [2], // X/Square
    rotateLeft: [1], // B/Circle
    hold: [3, 4, 5], // Y/Triangle, LB, RB
    pause: [9] // Start
  };

  let connectedGamepad = null;
  let gamepadState = {};
  let lastGamepadState = {};

  // ========== ç²’å­ç±» ==========
  class Particle {
    constructor(x, y, color, type = 'normal') {
      this.x = x;
      this.y = y;
      this.type = type;

      if(type === 'spark') {
        this.vx = (Math.random() - 0.5) * 12;
        this.vy = Math.random() * 4 - 1;
        this.life = 1.0;
        this.decay = 0.03 + Math.random() * 0.02;
        this.size = 2 + Math.random() * 3;
        this.gravity = 0.15;
      } else {
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10 - 3;
        this.life = 1.0;
        this.decay = 0.008 + Math.random() * 0.008;
        this.size = 4 + Math.random() * 5;
        this.gravity = 0.25;
      }

      this.color = color;
      this.rotation = Math.random() * Math.PI * 2;
      this.rotationSpeed = (Math.random() - 0.5) * 0.3;
    }

    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.vy += this.gravity;
      this.vx *= 0.98;
      this.life -= this.decay;
      this.rotation += this.rotationSpeed;
      return this.life > 0;
    }

    draw(ctx) {
      ctx.save();
      ctx.globalAlpha = this.life;
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);

      if(this.type === 'spark') {
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

        ctx.globalAlpha = this.life * 0.3;
        ctx.fillStyle = '#fff';
        ctx.fillRect(-this.size/3, -this.size/3, this.size*0.66, this.size*0.66);
      } else {
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
      }

      ctx.restore();
    }
  }

  // ========== å·¥å…·å‡½æ•° ==========
  function createMatrix(w,h){
    const m = [];
    for(let y=0;y<h;y++){ m.push(new Array(w).fill(0)); }
    return m;
  }
  function cloneMatrix(m){ return m.map(r=>r.slice()); }

  function refillBag(){
    const arr = TYPES.slice();
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    bag = arr;
  }

  function takeFromQueue(){
    while(queue.length < previewCount + 1){
      if(!bag.length) refillBag();
      queue.push(bag.pop());
    }
    return queue.shift();
  }
  

  function collide(b, p) {
    // æ£€æŸ¥æ–¹å—æœ¬èº«çš„è¾¹ç•Œ
    for(let y = 0; y < p.m.length; y++) {
        for(let x = 0; x < p.m[y].length; x++) {
            if(!p.m[y][x]) continue;
            const nx = p.x + x;
            const ny = p.y + y;
            
            // è¾¹ç•Œæ£€æŸ¥
            if(nx < 0 || nx >= COLS || ny >= ROWS) {
                return true; // è¶…å‡ºæ¸¸æˆåŒºåŸŸ
            }
            
            // æ¿å—ç¢°æ’æ£€æŸ¥ï¼ˆåªæ£€æŸ¥å¯è§åŒºåŸŸï¼‰
            if(ny >= 0 && b[ny][nx]) {
                return true; // ä¸ç°æœ‰æ–¹å—ç¢°æ’
            }
        }
    }
    return false;
}

  function checkBoundaries(piece) {
    // ç¡®ä¿æ–¹å—ä¸ä¼šè¶…å‡ºè¾¹ç•Œ
    if(piece.x < 0) piece.x = 0;
    if(piece.x + piece.m[0].length > COLS) {
        piece.x = COLS - piece.m[0].length;
    }
    
    // Iæ–¹å—ç‰¹æ®Šå¤„ç†
    if(piece.type === 'I' && piece.y < -2) {
        piece.y = -2;
    }
}

  function isGrounded(p){
    if(!p) return false;
    const test = { ...p, y: p.y + 1 };
    return collide(board, test);
  }

  function merge(b,p){
    for(let y=0;y<p.m.length;y++){
      for(let x=0;x<p.m[y].length;x++){
        if(p.m[y][x]){
          const nx = p.x + x;
          const ny = p.y + y;
          if(ny>=0 && ny<ROWS && nx>=0 && nx<COLS){
            b[ny][nx] = p.type;
          }
        }
      }
    }
  }

  function checkTSpin(p, kickIndex) {
  if(p.type !== 'T') return null;
  if(!lastActionWasRotate) return null;

  // Tæ–¹å—ä¸­å¿ƒå§‹ç»ˆåœ¨3x3çŸ©é˜µçš„(1,1)ä½ç½®
  const centerX = p.x + 1;
  const centerY = p.y + 1;

  // æ ¹æ®æ—‹è½¬çŠ¶æ€ç¡®å®š"å‰æ–¹"ä¸¤ä¸ªè§’è½
  // çŠ¶æ€0: ä¸Šæ–¹ä¸¤ä¸ªæ˜¯å‰æ–¹ (å·¦ä¸Šã€å³ä¸Š)
  // çŠ¶æ€1: å³æ–¹ä¸¤ä¸ªæ˜¯å‰æ–¹ (å³ä¸Šã€å³ä¸‹)
  // çŠ¶æ€2: ä¸‹æ–¹ä¸¤ä¸ªæ˜¯å‰æ–¹ (å·¦ä¸‹ã€å³ä¸‹)
  // çŠ¶æ€3: å·¦æ–¹ä¸¤ä¸ªæ˜¯å‰æ–¹ (å·¦ä¸Šã€å·¦ä¸‹)
  const frontCorners = {
    0: [{dx: -1, dy: -1}, {dx: 1, dy: -1}],
    1: [{dx: 1, dy: -1}, {dx: 1, dy: 1}],
    2: [{dx: -1, dy: 1}, {dx: 1, dy: 1}],
    3: [{dx: -1, dy: -1}, {dx: -1, dy: 1}]
  };

  const allCorners = [
    {dx: -1, dy: -1},
    {dx: 1, dy: -1},
    {dx: -1, dy: 1},
    {dx: 1, dy: 1}
  ];

  function isCornerFilled(corner) {
    const cx = centerX + corner.dx;
    const cy = centerY + corner.dy;
    if(cy < 0 || cy >= ROWS || cx < 0 || cx >= COLS) {
      return true;
    }
    return !!board[cy][cx];
  }

  let filledCorners = 0;
  for(const corner of allCorners) {
    if(isCornerFilled(corner)) filledCorners++;
  }

  if(filledCorners < 3) return null;

  // æ£€æŸ¥å‰æ–¹ä¸¤ä¸ªè§’è½æ˜¯å¦éƒ½è¢«å¡«å……
  const front = frontCorners[p.rotation] || frontCorners[0];
  const frontFilled = front.filter(c => isCornerFilled(c)).length;

  // T-Spin Miniæ¡ä»¶ï¼š
  // 1. ä½¿ç”¨äº†ç¬¬4æˆ–ç¬¬5ä¸ªè¸¢å¢™æµ‹è¯•ï¼ˆç´¢å¼•3æˆ–4ï¼‰
  // 2. æˆ–è€…å‰æ–¹ä¸¤ä¸ªè§’è½åªæœ‰ä¸€ä¸ªè¢«å¡«å……
  if(kickIndex >= 3 || frontFilled < 2) {
    // ç‰¹ä¾‹ï¼šå¦‚æœæ¶ˆé™¤3è¡Œï¼Œå³ä½¿æ˜¯miniæ¡ä»¶ä¹Ÿç®—ä½œnormal T-Spin
    return 'mini';
  }

  return 'normal';
}

  function clearLines(){
    const fullRows = [];
    for(let y=0; y<ROWS; y++){
      const isFull = board[y].every(v => v !== 0);
      if(isFull) fullRows.push(y);
    }

    const cleared = fullRows.length;    

    if(cleared > 0){
      vibrate([10, 20, 30][Math.min(cleared-1, 2)] || 30);

      for(const y of fullRows){
        for(let x=0; x<COLS; x++){
          const type = board[y][x];
          if(!type) continue;
          const color = skin[type];
          const px = x * BLOCK + BLOCK / 2;
          const py = y * BLOCK + BLOCK / 2;
          const count = 15 + Math.floor(Math.random() * 6);
          for(let i=0; i<count; i++){
            particles.push(new Particle(px, py, color, 'normal'));
          }
        }
      }

      const isTetris = (cleared === 4);
      const isTSpin = (tSpinType !== null && cleared > 0);
      const isSpecial = isTetris || isTSpin;

if(cleared > 0) {
  audioSystem.playLineClear(cleared);
  if(combo > 1) {
    audioSystem.playComboSound(combo);
  }
  if(cleared === 4 || isTSpin) {
    screenShaker.bigShake();
  } else {
    screenShaker.smallShake();
  }
}

      let b2bMultiplier = 1.0;
      if(isSpecial) {
        if(lastClearWasSpecial) {
          b2bCount++;
          b2bMultiplier = 1.5;
        } else {
          b2bCount = 1;
        }
        lastClearWasSpecial = true;
      } else {
        lastClearWasSpecial = false;
        b2bCount = 0;
      }

      let baseScore = 0;
      if(isTSpin) {
  // T-Spin Triple å³ä½¿æ»¡è¶³miniæ¡ä»¶ä¹Ÿç®—ä½œnormal
  let effectiveTSpinType = tSpinType;
  if(tSpinType === 'mini' && cleared >= 3) {
    effectiveTSpinType = 'normal';
  }
  
  const tSpinScores = {
    'mini': [100, 200, 400],
    'normal': [400, 800, 1200, 1600]
  };
  const scoreTable = tSpinScores[effectiveTSpinType] || tSpinScores['normal'];
  baseScore = scoreTable[Math.min(cleared - 1, scoreTable.length - 1)] || 0;
} else {
        const normalScores = {1:100, 2:300, 3:500, 4:800};
        baseScore = normalScores[cleared] || 0;
      }

      combo++;
      const comboBonus = combo > 1 ? 50 * (combo - 1) : 0;

      const totalScore = Math.floor((baseScore + comboBonus) * level * b2bMultiplier);
      score += totalScore;

      lines += cleared;
      
      // æ›´æ–°æŒ–æ˜æ¨¡å¼è¿›åº¦
      if(gameMode === 'cheese') {
        updateCheeseProgress();
      }

      updateLevelByLines();
      updateStats();

      showClearNotification(cleared, isTSpin, tSpinType, b2bMultiplier > 1);

      const fullSet = new Set(fullRows);
      const kept = [];
      for(let y=0; y<ROWS; y++){
        if(!fullSet.has(y)) kept.push(board[y]);
      }
      const empties = new Array(cleared).fill(0).map(()=> new Array(COLS).fill(0));
      board = [...empties, ...kept];

      const allClear = board.every(row => row.every(cell => cell === 0));
        if(allClear) {
            triggerAllClear();
        }

      clearingLines = true;
      clearAnimationTimer = 0;
      setTimeout(()=>{ clearingLines = false; }, CLEAR_ANIMATION_DURATION);

      // æ£€æŸ¥æ¨¡å¼å®Œæˆæ¡ä»¶
      checkModeCompletion();

      spawn();
    } else {
      combo = 0;
      updateStats();
      spawn();
    }

    tSpinType = null;
  }
  
  function triggerAllClear() {
    // All Clear å¥–åŠ±åˆ†æ•°
    const allClearBonus = 10000 * level;
    score += allClearBonus;
    
    // ç‰¹æ•ˆå’ŒéŸ³æ•ˆ
    audioSystem.playSound('tetris', 1.5); // æ’­æ”¾éŸ³æ•ˆ
    screenShaker.bigShake();
    
    // æ˜¾ç¤º All Clear é€šçŸ¥
    showAllClearNotification();
    
    // é¢å¤–çš„ç²’å­æ•ˆæœ
    createAllClearEffect();
}

function showAllClearNotification() {
    comboNotif.textContent = 'ALL CLEAR!';
    comboNotif.className = 'combo-notification combo-tspin show';
    
    // é¢å¤–çš„è§†è§‰æ•ˆæœ
    const canvas = document.getElementById('playfield');
    canvas.style.filter = 'brightness(1.5)';
    setTimeout(() => {
        canvas.style.filter = '';
    }, 500);
    
    setTimeout(() => {
        comboNotif.classList.remove('show');
    }, 2000);
}

function createAllClearEffect() {
    for(let x = 0; x < COLS; x++) {
        for(let y = 0; y < ROWS; y++) {
            if(Math.random() < 0.3) {
                const colors = ['#FFD700', '#FF69B4', '#00CED1', '#FF6347'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const px = x * BLOCK + BLOCK / 2;
                const py = y * BLOCK + BLOCK / 2;
                particles.push(new Particle(px, py, color, 'spark'));
            }
        }
    }
}

  function showClearNotification(count, isTSpin, tSpinVariant, isB2B) {
    let message = '';
    let cssClass = 'combo-notification';

    if(isTSpin) {
  const lineNames = ['', 'Single', 'Double', 'Triple'];
  const lineName = lineNames[count] || count + 'è¡Œ';
  
  if(tSpinVariant === 'mini') {
    message = `T-Spin Mini ${lineName}!`;
  } else {
    message = `T-Spin ${lineName}!`;
  }
  cssClass += ' combo-tspin';
} else if(count === 4) {
      message = 'TETRIS!';
      cssClass += ' combo-4';
    } else if(count === 3) {
      message = 'TRIPLE!';
      cssClass += ' combo-3';
    } else if(count === 2) {
      message = 'DOUBLE!';
      cssClass += ' combo-2';
    } else if(count === 1) {
      message = 'SINGLE';
      cssClass += ' combo-1';
    }

    if(isB2B && (isTSpin || count === 4)) {
      message = 'B2B ' + message;
      cssClass += ' combo-b2b';
    }

    if(combo > 1) {
      message += ` (Combo x${combo})`;
    }

    comboNotif.textContent = message;
    comboNotif.className = cssClass + ' show';

    setTimeout(() => {
      comboNotif.classList.remove('show');
    }, 1200);
  }
  
function rotate(dir = +1) {
    if(!piece || hardDropping) return false;
    
    if(piece.type === 'O') {
        return false;
    }
    
    const oldRotation = piece.rotation;
    const newRotation = (oldRotation + (dir > 0 ? 1 : 3)) % 4;
    
    const rotated = SRS_STATES[piece.type][newRotation];
    if(!rotated) {
        console.warn(`æœªæ‰¾åˆ°æ–¹å— ${piece.type} çš„æ—‹è½¬çŠ¶æ€ ${newRotation}`);
        return false;
    }
    
    const rotatedMatrix = rotated.map(row => [...row]);
    
    const kickKey = `${oldRotation}->${newRotation}`;
    let kicks = [];
    
    if(piece.type === 'I') {
        kicks = SRS_KICKS_I[kickKey] || [[0,0]];
    } else {
        kicks = SRS_KICKS_JLSTZ[kickKey] || [[0,0]];
    }
    
    for(let kickIdx = 0; kickIdx < kicks.length; kickIdx++) {
        const [dx, dy] = kicks[kickIdx];
        const test = {
            ...piece,
            x: piece.x + dx,
            y: piece.y + dy,
            m: rotatedMatrix,
            rotation: newRotation
        };
        
        if(!collide(board, test)) {
            piece.x = test.x;
            piece.y = test.y;
            piece.m = rotatedMatrix;
            piece.rotation = newRotation;
            lastActionWasRotate = true;
            lastKickIndex = kickIdx;
            
            audioSystem.playSound('rotate');
            maybeResetLockTimer();
            
            if(piece.type === 'T') {
                tSpinType = checkTSpin(piece, kickIdx);
            }
            
            vibrate(5);
            return true;
        }
    }
    
    lastActionWasRotate = false;
    return false;
}
  
function spawn() {
    piece = newPiece(takeFromQueue());
    holdLocked = false;
    lockTimer = 0;
    touchingGround = false;
    lockResets = 0;
    groundTime = 0;
    lastActionWasRotate = false;
    tSpinType = null;
    lastKickIndex = 0;
    
    // å¢å¼ºçš„ç”Ÿæˆç¢°æ’æ£€æµ‹
    if(piece) {
        // å¯¹äºIæ–¹å—ï¼Œå…è®¸å®ƒéƒ¨åˆ†åœ¨éšè—åŒºåŸŸ
        if(piece.type === 'I') {
            // æ£€æŸ¥å¯è§éƒ¨åˆ†æ˜¯å¦æœ‰ç¢°æ’
            let hasCollision = false;
            for(let y = 0; y < piece.m.length; y++) {
                for(let x = 0; x < piece.m[y].length; x++) {
                    if(!piece.m[y][x]) continue;
                    const ny = piece.y + y;
                    const nx = piece.x + x;
                    // åªæ£€æŸ¥å¯è§åŒºåŸŸçš„ç¢°æ’
                    if(ny >= 0 && ny < ROWS && board[ny][nx]) {
                        hasCollision = true;
                        break;
                    }
                }
                if(hasCollision) break;
            }
            
            if(hasCollision) {
                endGame();
            }
        } else {
            // å…¶ä»–æ–¹å—çš„å¸¸è§„ç¢°æ’æ£€æµ‹
            if(collide(board, piece)) {
                // å°è¯•å‘ä¸Šç§»åŠ¨ä¸€æ ¼
                piece.y--;
                if(collide(board, piece)) {
                    endGame();
                }
            }
        }
    }
    
    redrawSidePanels();
}
  
function newPiece(type) {
    // ä½¿ç”¨ SRS_STATES çš„åˆå§‹çŠ¶æ€ï¼ˆrotation 0ï¼‰
    const mat = SRS_STATES[type][0].map(row => [...row]); // æ·±æ‹·è´
    
    const p = {
        type,
        m: mat,
        x: Math.floor(COLS/2) - Math.ceil(mat[0].length/2),
        y: 0, // é»˜è®¤ä»é¡¶éƒ¨å¼€å§‹
        color: skin[type],
        animX: 0,
        animY: 0,
        rotation: 0
    };
    
    // Iæ–¹å—ç‰¹æ®Šå¤„ç†ï¼šéœ€è¦ä»æ›´é«˜ä½ç½®å¼€å§‹ä»¥é¿å…åˆå§‹ç¢°æ’
    if(type === 'I') {
        p.y = -2; // Iæ–¹å—ä»-2è¡Œå¼€å§‹
    }
    
    // ç¡®ä¿æ–¹å—åœ¨æ°´å¹³æ–¹å‘ä¸è¶…å‡ºè¾¹ç•Œ
    if(p.x < 0) {
        p.x = 0;
    }
    if(p.x + mat[0].length > COLS) {
        p.x = COLS - mat[0].length;
    }
    
    p.animX = p.x;
    p.animY = p.y;
    
    return p;
}

  function updateLevelByLines(){
    if(gameMode === 'sprint' || gameMode === 'ultra' || gameMode === 'cheese' || gameMode === 'practice') return;
    
    const computed = startLevel + Math.floor(lines / 10);
    const newLevel = Math.min(20, Math.max(1, computed));
    if(newLevel !== level){
  level = newLevel;
  if(gameMode !== 'master') {
    gravity = levelSpeed(level);
  }
  
  // å‡çº§æ•ˆæœ
  audioSystem.playSound('levelUp');
  cvs.classList.add('level-up');
  setTimeout(() => cvs.classList.remove('level-up'), 600);
  
  // æ›´æ–°èƒŒæ™¯ç²’å­
  if(bgParticles) {
    bgParticles.updateLevel(level);
  }
}
  }

  function move(dx){
  if(!piece || hardDropping) return false;
  piece.x += dx;
  if(collide(board, piece)){
    piece.x -= dx;
    return false;
  }
  lastActionWasRotate = false;
  tSpinType = null;
  maybeResetLockTimer();  
  audioSystem.playSound('move');
  return true;
}


  function softDropStep(){
  if(!piece || hardDropping) return false;
  piece.y += 1;
  if(collide(board, piece)){
    piece.y -= 1;
    return false;
  }else{
    lastActionWasRotate = false;
    tSpinType = null;
    score += 1;
    updateStats();
    
    audioSystem.playSound('softDrop');
    
    return true;
  }
}


  function hardDrop(){
  if(!piece || hardDropping) return;

  const gy = ghostY();
  const dist = Math.max(0, gy - piece.y);

  if(dist === 0) {
    lockPiece();
    return;
  }

  hardDropping = true;
  hardDropStartY = piece.y;
  hardDropTargetY = gy;
  hardDropCurrentY = piece.y;

  score += dist * 2;
  updateStats();
  lastActionWasRotate = false;
  
  audioSystem.playSound('hardDrop');
  screenShaker.mediumShake();
  
  vibrate(15);
}

  function updateHardDrop() {
    if(!hardDropping) return;

    hardDropCurrentY = Math.min(hardDropTargetY, hardDropCurrentY + hardDropSpeed);

    const pieceScreenY = hardDropCurrentY * BLOCK;

    for(let py = 0; py < piece.m.length; py++) {
      for(let px = 0; px < piece.m[py].length; px++) {
        if(!piece.m[py][px]) continue;

        const nx = piece.x + px;
        if(Math.random() < 0.3) {
          const sparkX = nx * BLOCK + (Math.random() < 0.5 ? 2 : BLOCK - 2);
          const sparkY = pieceScreenY + py * BLOCK + BLOCK / 2;

          const sparkColors = ['#ffaa00', '#ff6600', '#ffdd00', '#fff'];
          const sparkColor = sparkColors[Math.floor(Math.random() * sparkColors.length)];

          particles.push(new Particle(sparkX, sparkY, sparkColor, 'spark'));
        }
      }
    }

    piece.y = Math.floor(hardDropCurrentY);

    if(hardDropCurrentY >= hardDropTargetY) {
      piece.y = hardDropTargetY;
      hardDropping = false;

      for(let py = 0; py < piece.m.length; py++) {
        for(let px = 0; px < piece.m[py].length; px++) {
          if(!piece.m[py][px]) continue;
          const nx = piece.x + px;
          const ny = piece.y + py;

          const particleX = nx * BLOCK + BLOCK / 2;
          const particleY = (ny + 1) * BLOCK;

          for(let i = 0; i < 5; i++) {
            particles.push(new Particle(particleX, particleY, '#fff', 'spark'));
          }
        }
      }

      vibrate(20);
      lockPiece();
    }
  }

  function lockPiece(){
  audioSystem.playSound('lock'); 
  
  merge(board, piece);
  piece = null;
  clearLines();
  lockTimer = 0;
  touchingGround = false;
  lockResets = 0;
  groundTime = 0;
  
  if(gameMode === 'practice') {
    saveHistory();
  }
}


  function maybeResetLockTimer(){
    if(!isGrounded(piece)) return;
    if(lockResets < LOCK_RESET_LIMIT){
      lockTimer = 0;
      lockResets++;
    }
  }

  function ghostY(){
    let gy = piece.y;
    while(true){
      gy++;
      const test = { ...piece, y: gy };
      if(collide(board, test)) return gy - 1;
    }
  }

  function lerp(a,b,t){ return a + (b - a) * t; }

  function draw(){
    ctx.clearRect(0,0,cvs.width,cvs.height);

    ctx.fillStyle = '#0b0f23';
    ctx.fillRect(0,0,cvs.width,cvs.height);

    ctx.strokeStyle = '#1b2248';
    ctx.lineWidth = 1;
    for(let x=0;x<=COLS;x++){
      const px = Math.floor(x*BLOCK)+.5;
      ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,ROWS*BLOCK); ctx.stroke();
    }
    for(let y=0;y<=ROWS;y++){
      const py = Math.floor(y*BLOCK)+.5;
      ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(COLS*BLOCK,py); ctx.stroke();
    }

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const t = board[y][x];
        if(!t) continue;
        drawCell(x,y, skin[t]);
      }
    }

    if(ghostEnabled && piece && !hardDropping){
      const gy = ghostY();
      drawPiece({ ...piece, x: piece.animX, y: gy }, skin.ghost || 'rgba(122,162,255,0.45)', true);
    }

    if(piece){
      if(hardDropping) {
        const animPiece = { ...piece, y: hardDropCurrentY, x: piece.x };
        drawPiece(animPiece, piece.color, false, 0.9);
      } else {
        drawPiece({ ...piece, x: piece.animX, y: piece.animY }, piece.color, false);
      }
    }

    for(let i = particles.length - 1; i >= 0; i--) {
      if(!particles[i].update()) {
        particles.splice(i, 1);
      } else {
        particles[i].draw(ctx);
      }
    }
  }

  function varGap(){ return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap')) || 1; }

function drawCell(x, y, color, alpha = 1) {
  const px = x * BLOCK;
  const py = y * BLOCK;
  const gap = varGap();
  const size = BLOCK - 2 * gap;
  
  ctx.globalAlpha = alpha;
  
  const texture = skin.texture || 'flat';
  
  switch(texture) {
    case 'glossy':
      // æœå†»è´¨æ„Ÿ - å¸¦é«˜å…‰å’Œåº•éƒ¨é˜´å½±
      ctx.fillStyle = color;
      ctx.fillRect(px + gap, py + gap, size, size);
      
      // é«˜å…‰
      const glossGradient = ctx.createLinearGradient(px + gap, py + gap, px + gap, py + size * 0.4);
      glossGradient.addColorStop(0, 'rgba(255,255,255,0.6)');
      glossGradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = glossGradient;
      ctx.fillRect(px + gap, py + gap, size, size * 0.4);
      
      // åº•éƒ¨é˜´å½±
      const shadowGradient = ctx.createLinearGradient(px + gap, py + size * 0.6, px + gap, py + size);
      shadowGradient.addColorStop(0, 'rgba(0,0,0,0)');
      shadowGradient.addColorStop(1, 'rgba(0,0,0,0.4)');
      ctx.fillStyle = shadowGradient;
      ctx.fillRect(px + gap, py + size * 0.6, size, size * 0.4);
      
      // è¾¹æ¡†é«˜å…‰
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(px + gap + 0.5, py + gap + 0.5, size - 1, size - 1);
      break;
      
    case 'glow':
      // éœ“è™¹å‘å…‰æ•ˆæœ
      ctx.shadowBlur = 15 * alpha;
      ctx.shadowColor = color;
      ctx.fillStyle = color;
      ctx.fillRect(px + gap, py + gap, size, size);
      ctx.shadowBlur = 0;
      
      // å†…éƒ¨æ›´äº®çš„æ ¸å¿ƒ
      const glowGradient = ctx.createRadialGradient(
        px + BLOCK/2, py + BLOCK/2, 0,
        px + BLOCK/2, py + BLOCK/2, size/2
      );
      glowGradient.addColorStop(0, 'rgba(255,255,255,0.6)');
      glowGradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
      glowGradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = glowGradient;
      ctx.fillRect(px + gap, py + gap, size, size);
      break;
      
    case 'pixel':
      // å¤å¤åƒç´ é£ - å¸¦åƒç´ åŒ–è¾¹æ¡†
      ctx.fillStyle = color;
      ctx.fillRect(px + gap, py + gap, size, size);
      
      // åƒç´ åŒ–é«˜å…‰ï¼ˆå·¦ä¸Šè§’ï¼‰
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fillRect(px + gap, py + gap, size, 2);
      ctx.fillRect(px + gap, py + gap, 2, size);
      
      // åƒç´ åŒ–é˜´å½±ï¼ˆå³ä¸‹è§’ï¼‰
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(px + gap, py + gap + size - 2, size, 2);
      ctx.fillRect(px + gap + size - 2, py + gap, 2, size);
      break;
      
    case 'outline':
      // æç®€çº¿æ¡†é£æ ¼
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.strokeRect(px + gap + 1, py + gap + 1, size - 2, size - 2);
      
      // åŠé€æ˜å¡«å……
      ctx.fillStyle = color + '20'; // 20æ˜¯åå…­è¿›åˆ¶çš„é€æ˜åº¦
      ctx.fillRect(px + gap + 2, py + gap + 2, size - 4, size - 4);
      break;
      
    case 'flat':
    default:
      // åŸæœ‰çš„å¹³é¢é£æ ¼
      ctx.fillStyle = color;
      ctx.fillRect(px + gap, py + gap, size, size);
      
      // é¡¶éƒ¨é«˜å…‰
      ctx.globalAlpha = alpha * 0.4;
      ctx.fillStyle = 'rgba(255,255,255,0.10)';
      ctx.fillRect(px + gap, py + gap, size, 4);
      
      // åº•éƒ¨é˜´å½±
      ctx.globalAlpha = alpha * 0.35;
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(px + gap, py + size - 4, size, 4);
      break;
  }
  
  ctx.globalAlpha = 1;
}

  function drawPiece(p, color, isGhost=false, alpha=1){
    for(let y=0;y<p.m.length;y++){
      for(let x=0;x<p.m[y].length;x++){
        if(!p.m[y][x]) continue;
        const nx = p.x + x;
        const ny = p.y + y;
        if(ny<0) continue;
        drawCell(nx, ny, color, alpha);
      }
    }
  }

  function redrawSidePanels(){
    const items = previewsEl.querySelectorAll('canvas');
    items.forEach((cv, idx) => {
      const type = queue[idx];
      const c = cv.getContext('2d');
      c.clearRect(0,0,cv.width,cv.height);
      if(!type) return;
      drawMini(c, type);
    });
    
    holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
    if(holdType){ drawMini(holdCtx, holdType); }
  }

  function drawMini(c, type){
    const mat = SHAPES[type];
    const w = mat[0].length, h = mat.length;

    const margin = Math.floor(Math.min(c.canvas.width, c.canvas.height) * 0.1);
    const areaW = c.canvas.width - margin*2;
    const areaH = c.canvas.height - margin*2;

    const cell = Math.max(2, Math.floor(Math.min(areaW / w, areaH / h)));
    const shapeW = w*cell, shapeH = h*cell;
    const ox = Math.floor((c.canvas.width - shapeW)/2);
    const oy = Math.floor((c.canvas.height - shapeH)/2);

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        if(!mat[y][x]) continue;
        c.fillStyle = skin[type];
        c.fillRect(ox + x*cell + 1, oy + y*cell + 1, cell-2, cell-2);
      }
    }
  }

  function loop(ts){
    if(!running || paused) return;
    if(!lastTS) lastTS = ts;
    const dt = ts - lastTS;
    lastTS = ts;

    // æ›´æ–°è®¡æ—¶å™¨
    updateTimer(dt);

    // æ£€æŸ¥é™æ—¶æ¨¡å¼æ—¶é—´
    if(gameMode === 'ultra' && gameTimer >= ultraTimeLimit * 1000) {
      endGame('æ—¶é—´åˆ°ï¼');
      return;
    }

    if(hardDropping) {
      updateHardDrop();
    }

    if(clearingLines) {
      clearAnimationTimer += dt;
    }

    updateDASARR(dt);
    pollGamepad();

    // å¤§å¸ˆæ¨¡å¼ï¼š20Gé‡åŠ›ï¼ˆç¬é™ï¼‰
    if(gameMode === 'master') {
      if(piece && !hardDropping && !isGrounded(piece)) {
        while(!isGrounded(piece)) {
          piece.y++;
          if(collide(board, piece)) {
            piece.y--;
            break;
          }
        }
      }
    } else {
      // æ­£å¸¸é‡åŠ›
      dropTimer += dt;

      while(dropTimer >= gravity){
        dropTimer -= gravity;
        if(piece && !hardDropping) {
          piece.y += 1;
          if(collide(board, piece)){
            piece.y -= 1;
            dropTimer = 0;
            break;
          }
        } else {
          break;
        }
      }
    }

    if(piece && !hardDropping){
      const grounded = isGrounded(piece);
      const frac = grounded ? 0 : Math.min(0.999, dropTimer / gravity);
      const targetY = piece.y + frac;

      piece.animX = lerp(piece.animX, piece.x, 0.35);

      if(piece.animY > targetY){
        piece.animY = targetY;
      }else{
        piece.animY = lerp(piece.animY, targetY, 0.35);
      }

      if(grounded){
        dropTimer = 0;
        piece.animY = Math.min(piece.animY, piece.y);
      }
    }

    if(piece && !hardDropping && isGrounded(piece)){
      touchingGround = true;
      lockTimer += dt;
      groundTime += dt;
      if(lockTimer >= lockDelay || groundTime >= MAX_GROUND_LOCK_TIME){
        lockPiece();
      }
    }else{
      touchingGround = false;
      lockTimer = 0;
    }

    draw();
    requestAnimationFrame(loop);
  }

  function updateDASARR(dt) {
    for(const key in keyState) {
      if(!keyState[key]) continue;

      if(!dasTimer[key]) dasTimer[key] = 0;
      if(!arrTimer[key]) arrTimer[key] = 0;

      dasTimer[key] += dt;

      if(dasTimer[key] >= DAS) {
        arrTimer[key] += dt;
        
        if(ARR === 0) {
          if(key === 'moveLeft') {
            while(move(-1));
          } else if(key === 'moveRight') {
            while(move(1));
          }
          dasTimer[key] = DAS;
          arrTimer[key] = 0;
        } else {
          while(arrTimer[key] >= ARR) {
            arrTimer[key] -= ARR;
            if(key === 'moveLeft') {
              if(!move(-1)) break;
            } else if(key === 'moveRight') {
              if(!move(1)) break;
            }
          }
        }
      }
    }
  }

  function buildPreviewCanvases(){
    previewsEl.innerHTML = '';
    for(let i=0;i<previewCount;i++){
      const box = document.createElement('div');
      box.className = 'preview-item';
      const cv = document.createElement('canvas');
      cv.width = 140; cv.height = 100;
      box.appendChild(cv);
      previewsEl.appendChild(box);
    }
  }

  function updateStats(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
    comboEl.textContent = combo;

    if(combo > 1) {
      comboInd.classList.add('active');
    } else {
      comboInd.classList.remove('active');
    }

    if(b2bCount > 0) {
      b2bInd.classList.add('active');
    } else {
      b2bInd.classList.remove('active');
    }

    // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
    if(gameMode === 'practice') {
      btnUndo.disabled = historyIndex <= 0;
      btnRedo.disabled = historyIndex >= historyStates.length - 1;
    }
  }

  function resetGame(){
    board = createMatrix(COLS, ROWS);
    score = 0; lines = 0; combo = 0; b2bCount = 0;
    level = startLevel;
    
    // æ¨¡å¼ç‰¹å®šåˆå§‹åŒ–
    if(gameMode === 'master') {
      gravity = 0; // 20G
      lockDelay = 200; // æçŸ­é”å»¶è¿Ÿ
    } else {
      gravity = levelSpeed(level);
      lockDelay = parseInt(cfgLockDelay.value);
    }

    queue = [];
    bag = [];
    particles = [];
    hardDropping = false;
    clearingLines = false;
    clearAnimationTimer = 0;
    lastClearWasSpecial = false;
    lastActionWasRotate = false;
    tSpinType = null;
    
    gameTimer = 0;
    timerRunning = false;

    // æŒ–æ˜æ¨¡å¼åˆå§‹åŒ–
    if(gameMode === 'cheese') {
      initCheeseMode();
    }

    // æ’¤é”€/é‡åšé‡ç½®
    historyStates = [];
    historyIndex = -1;
    
    refillBag();
    for(let i=0;i<previewCount;i++){
      if(!bag.length) refillBag();
      queue.push(bag.pop());
    }
    
    holdType = null;
    holdLocked = false;
    gameOver = false;
    updateStats();
    buildPreviewCanvases();
    updateModeDisplay();
    spawn();
    redrawSidePanels();
    
    // åœ¨ç»ƒä¹ æ¨¡å¼ä¸‹ä¿å­˜åˆå§‹çŠ¶æ€
    if(gameMode === 'practice') {
        saveHistory();
    }
    
    draw();

    dropTimer = 0;
    lastTS = 0;
    lockTimer = 0;
    touchingGround = false;
    lockResets = 0;
    groundTime = 0;
  }

  function hold(){
  if(holdLocked || hardDropping) return;
  
  audioSystem.playSound('hold'); // æ·»åŠ éŸ³æ•ˆ
  
  const holdBox = document.querySelector('.hold-box');
  const t = piece.type;
  
  if(!holdType){
    // é¦–æ¬¡Hold - é£å…¥åŠ¨ç”»
    holdType = t;
    holdBox.classList.add('animate-in');
    setTimeout(() => holdBox.classList.remove('animate-in'), 500);
    
    piece = newPiece(takeFromQueue());
  }else{
    // äº¤æ¢Hold - é£å‡ºå†é£å…¥
    holdBox.classList.add('animate-out');
    
    setTimeout(() => {
      [holdType, piece] = [t, newPiece(holdType)];
      holdBox.classList.remove('animate-out');
      holdBox.classList.add('animate-in');
      
      redrawSidePanels();
      
      setTimeout(() => holdBox.classList.remove('animate-in'), 500);
    }, 400);
  }
  
  holdLocked = true;
  piece.y = piece.type==='I' ? -1 : 0;
  piece.x = Math.floor(COLS/2) - Math.ceil(piece.m[0].length/2);
  piece.animX = piece.x;
  piece.animY = piece.y;
  lockTimer = 0;
  touchingGround = false;
  lockResets = 0;
  groundTime = 0;
  lastActionWasRotate = false;
  tSpinType = null;
  vibrate(8);
  
  if(!holdType || holdBox.classList.contains('animate-out')) return;
  redrawSidePanels();
  draw();
}

  function inputAction(act) {
    if(!running || paused || gameOver) return;
    
    switch(act) {
        case 'moveLeft':
        case 'left': 
            move(-1); 
            break;
        case 'moveRight':
        case 'right': 
            move(1); 
            break;
        case 'rotateRight':
            rotate(+1); 
            break;
        case 'rotateLeft': 
            rotate(-1); 
            break;
        case 'softDrop':
        case 'soft': 
            softDropStep(); 
            break;
        case 'hardDrop':
        case 'hard': 
            hardDrop(); 
            break;
        case 'hold': 
            hold(); 
            break;
        case 'pause': 
            togglePause(); 
            break;
    }
    draw();
}

  // ========== é”®ç›˜äº‹ä»¶ ==========
  window.addEventListener('keydown', (e)=>{
    if(gameOver) return;

    // æ£€æŸ¥æ˜¯å¦åœ¨ç›‘å¬é”®ä½
    if(listeningForKey) {
      e.preventDefault();
      assignKey(listeningForKey, e.key);
      return;
    }

    // æ’¤é”€/é‡åšå¿«æ·é”®
    if(gameMode === 'practice' && e.ctrlKey) {
      if(e.key === 'z' || e.key === 'Z') {
        e.preventDefault();
        undo();
        return;
      }
      if(e.key === 'y' || e.key === 'Y') {
        e.preventDefault();
        redo();
        return;
      }
    }

    // æ£€æŸ¥é”®ä½ç»‘å®š
    for(const action in keyBindings) {
      if(keyBindings[action].includes(e.key)) {
        e.preventDefault();
        
        // DAS/ARR ç›¸å…³
        if(action === 'moveLeft' || action === 'moveRight') {
          if(!keyState[action]) {
            keyState[action] = true;
            dasTimer[action] = 0;
            arrTimer[action] = 0;
            if(action === 'moveLeft') move(-1);
            else move(1);
          }
        } else {
          inputAction(action);
        }
        return;
      }
    }
  }, {passive:false});

  window.addEventListener('keyup', (e)=>{
    for(const action in keyBindings) {
      if(keyBindings[action].includes(e.key)) {
        if(action === 'moveLeft' || action === 'moveRight') {
          keyState[action] = false;
          dasTimer[action] = 0;
          arrTimer[action] = 0;
        }
      }
    }
  });

  // ========== è§¦æ‘¸äº‹ä»¶ ==========
  cvs.addEventListener('touchstart', (e)=>{
    const t = e.changedTouches[0];
    touchStartX = t.clientX; touchStartY = t.clientY; touchStartTime = Date.now();
  }, {passive:true});
  
  cvs.addEventListener('touchmove', (e)=>{ e.preventDefault(); }, {passive:false});
  
  cvs.addEventListener('touchend', (e)=>{
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const dt = Date.now() - touchStartTime;
    const TH = 24;
    
    if(adx<TH && ady<TH && dt<220){
      const rect = cvs.getBoundingClientRect();
      const relY = t.clientY - rect.top;
      if(relY < rect.height*0.5) inputAction('rotateRight');
      else inputAction('soft');
      return;
    }
    
    if(adx > ady){
      if(dx > TH) inputAction('right');
      else if(dx < -TH) inputAction('left');
    }else{
      if(dy > TH) inputAction('soft');
      else if(dy < -TH) inputAction('hard');
    }
  }, {passive:false});

  function attachMobileHandlers(el) {
    if(!el) return;
    
    el.addEventListener('click', (e) => {
        const t = e.target.closest('.btn');
        if(!t || !t.dataset.act) return;
        const action = t.dataset.act;
        
        // æ›´æ–°åŠ¨ä½œæ˜ å°„
        const actionMap = {
            left: 'moveLeft',
            right: 'moveRight',
            rotateLeft: 'rotateLeft', 
            rotateRight: 'rotateRight',
            soft: 'softDrop',
            hard: 'hardDrop',
            hold: 'hold',
            pause: 'pause'
        };
        
        inputAction(actionMap[action] || action);
    });
    
    el.addEventListener('touchstart', (e) => {
        const t = e.target.closest('.btn');
        if(!t || !t.dataset.act) return;
        e.preventDefault();
        t.classList.add('pressed');
        const action = t.dataset.act;
        
        const actionMap = {
            left: 'moveLeft',
            right: 'moveRight',
            rotateLeft: 'rotateLeft',
            rotateRight: 'rotateRight', 
            soft: 'softDrop',
            hard: 'hardDrop',
            hold: 'hold',
            pause: 'pause'
        };
        
        inputAction(actionMap[action] || action);
    }, {passive: false});
    
    el.addEventListener('touchend', (e) => {
        const t = e.target.closest('.btn');
        if(t) t.classList.remove('pressed');
    }, {passive: true});
    
    el.addEventListener('touchcancel', (e) => {
        const t = e.target.closest('.btn');
        if(t) t.classList.remove('pressed');
    }, {passive: true});
}
  
  attachMobileHandlers(mobileControlsEl);
  attachMobileHandlers(mobileLeftEl);
  attachMobileHandlers(mobileRightEl);

  function resize(){
    const wrap = cvs.parentElement;
    const w = wrap.clientWidth - 8;
    const h = wrap.clientHeight - 8;
    const blockW = Math.floor(w / COLS);
    const blockH = Math.floor(h / ROWS);
    BLOCK = Math.max(14, Math.min(blockW, blockH));
    cvs.width = COLS * BLOCK;
    cvs.height = ROWS * BLOCK;
    draw();
    redrawSidePanels();
  }
  window.addEventListener('resize', resize);

  // ========== æ§åˆ¶æŒ‰é’® ==========
  btnStart.addEventListener('click', startOrResume);
  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', ()=> showSettingsOverlay(true, 'é‡æ–°å¼€å§‹'));
  btnSettings.addEventListener('click', ()=> showSettingsOverlay(true));
  btnCloseSettings.addEventListener('click', ()=> showSettingsOverlay(false));
  btnSaveStart.addEventListener('click', saveSettingsAndStart);
  btnUndo.addEventListener('click', undo);
  btnRedo.addEventListener('click', redo);
  btnResetKeys.addEventListener('click', resetKeybindings);

  btnHeaderToggle.addEventListener('click', ()=>{
    topHeader.classList.toggle('header-visible');
  });

  // ========== Tab å¯¼èˆª ==========
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const tab = btn.dataset.tab;
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
    });
  });

  // ========== æ¨¡å¼é€‰æ‹© ==========
  document.querySelectorAll('.mode-card').forEach(card => {
    card.addEventListener('click', () => {
      document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      gameMode = card.dataset.mode;
      
      // æ˜¾ç¤º/éšè—æ¨¡å¼ç‰¹å®šè®¾ç½®
      document.getElementById('cheeseSettings').style.display = 
        gameMode === 'cheese' ? 'block' : 'none';
      document.getElementById('ultraSettings').style.display = 
        gameMode === 'ultra' ? 'block' : 'none';
    });
  });

  function showSettingsOverlay(v, title){
    if(v){
      const h3 = document.getElementById('modalTitle');
      h3.textContent = title || 'æ¸¸æˆè®¾ç½®';

      pausedBeforeOverlay = paused;
      if(running && !paused && !gameOver){
        paused = true;
        timerRunning = false;
        btnPause.textContent = 'ç»§ç»­';
      }
    }else{
      if(running && !gameOver && paused && !pausedBeforeOverlay){
        paused = false;
        timerRunning = true;
        btnPause.textContent = 'æš‚åœ';
        lastTS = 0;
        requestAnimationFrame(loop);
      }
    }
    overlay.classList.toggle('visible', v);
  }

  function applySkin(name){
    skin = SKINS[name] || SKINS.classic;
  }

  function clampInt(v,min,max){
    v = parseInt(v,10);
    if(isNaN(v)) v = min;
    return Math.max(min, Math.min(max, v));
  }

  function saveSettingsAndStart(){
    COLS = clampInt(cfgCols.value,6,20);
    ROWS = clampInt(cfgRows.value,12,40);
    previewCount = clampInt(cfgPreview.value,1,6);
    ghostEnabled = cfgGhost.value==='on';
    lockDelay = clampInt(cfgLockDelay.value,200,2000);
    DAS = clampInt(cfgDAS.value, 0, 300);
    ARR = clampInt(cfgARR.value, 0, 100);
    applySkin(cfgSkin.value);
    vibrationEnabled = cfgVibration.value === 'on';

    startLevel = clampInt(cfgStartLevel.value,1,20);
    level = startLevel;
    gravity = levelSpeed(level);

    cheeseLines = clampInt(cfgCheeseLines.value, 5, 18);
    initialCheeseLines = cheeseLines;

    ultraTimeLimit = clampInt(cfgUltraTime.value, 60, 300);

    resetGame();
    resize();
    showSettingsOverlay(false);
    startOrResume();
  }

  function startOrResume(){
  if(gameOver){
    showSettingsOverlay(true, 'é‡æ–°å¼€å§‹');
    return;
  }
  running = true;
  paused = false;
  timerRunning = true;
  btnPause.textContent = 'æš‚åœ';
  lastTS = 0;
  
  if(audioSystem) {
    audioSystem.startBGM(level);
  }
  
  requestAnimationFrame(loop);
}

  function togglePause(){
    if(!running) return;
    paused = !paused;
    timerRunning = !paused;
    btnPause.textContent = paused ? 'ç»§ç»­' : 'æš‚åœ';
    if(!paused){
      lastTS = 0;
      requestAnimationFrame(loop);
    }
  }

  
function endGame(message) {
  gameOver = true;
  running = false;
  paused = false;
  timerRunning = false;
  btnPause.textContent = 'æš‚åœ';
  
  audioSystem.playSound('gameOver'); // æ·»åŠ æ¸¸æˆç»“æŸéŸ³æ•ˆ
  audioSystem.stopBGM(); // åœæ­¢èƒŒæ™¯éŸ³ä¹
  screenShaker.bigShake(); // å¤§éœ‡åŠ¨

  let msg = message || 'æ¸¸æˆç»“æŸ';
  let details = '';

  if(gameMode === 'sprint') {
    const time = formatTime(gameTimer);
    details = `å®Œæˆæ—¶é—´ï¼š${time}`;
  } else if(gameMode === 'ultra') {
    details = `æœ€ç»ˆå¾—åˆ†ï¼š${score}`;
  } else if(gameMode === 'cheese') {
    details = `å‰©ä½™åƒåœ¾è¡Œï¼š${countCheeseLines()}`;
  } else {
    details = `æœ€ç»ˆå¾—åˆ†ï¼š${score} | è¡Œæ•°ï¼š${lines}`;
  }

  vibrate([50, 100, 50]);
  showSettingsOverlay(true, msg, details);
}

  // ========== è®¡æ—¶å™¨ ==========
  function updateTimer(dt) {
    if(!timerRunning) return;
    
    gameTimer += dt;
    
    if(gameMode === 'sprint' || gameMode === 'cheese') {
      timerDisplay.textContent = formatTime(gameTimer);
    } else if(gameMode === 'ultra') {
      const remaining = ultraTimeLimit * 1000 - gameTimer;
      timerDisplay.textContent = formatTime(Math.max(0, remaining));
      
      if(remaining < 30000) {
        timerDisplay.classList.add('warning');
      }
      if(remaining < 10000) {
        timerDisplay.classList.remove('warning');
        timerDisplay.classList.add('danger');
      }
    }
  }

  function formatTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const centiseconds = Math.floor((ms % 1000) / 10);
    return `${pad(minutes)}:${pad(seconds)}.${pad(centiseconds)}`;
  }

  function pad(n) {
    return n.toString().padStart(2, '0');
  }

  function updateModeDisplay() {
    modeDisplayEl.textContent = MODE_NAMES[gameMode] || gameMode;
    
    // æ˜¾ç¤º/éšè—è®¡æ—¶å™¨
    if(gameMode === 'sprint' || gameMode === 'ultra' || gameMode === 'cheese') {
      timerContainer.style.display = 'block';
      timerDisplay.className = 'timer-display';
    } else {
      timerContainer.style.display = 'none';
    }

    // æ˜¾ç¤º/éšè—æŒ–æ˜æ¨¡å¼è¿›åº¦
    if(gameMode === 'cheese') {
      cheeseContainer.style.display = 'block';
    } else {
      cheeseContainer.style.display = 'none';
    }

    // æ˜¾ç¤º/éšè—æ’¤é”€æ§åˆ¶
    if(gameMode === 'practice') {
      undoControls.classList.add('visible');
    } else {
      undoControls.classList.remove('visible');
    }
  }

  // ========== æŒ–æ˜æ¨¡å¼ ==========
  function initCheeseMode() {
    // å¡«å……åº•éƒ¨åƒåœ¾è¡Œ
    const startRow = ROWS - cheeseLines;
    for(let y = startRow; y < ROWS; y++) {
      const holePos = Math.floor(Math.random() * COLS);
      for(let x = 0; x < COLS; x++) {
        if(x !== holePos) {
          board[y][x] = 'G';
        }
      }
    }
    updateCheeseProgress();
  }

  function countCheeseLines() {
    let count = 0;
    for(let y = 0; y < ROWS; y++) {
      if(board[y].some(cell => cell === 'G')) {
        count++;
      }
    }
    return count;
  }

  function updateCheeseProgress() {
    const remaining = countCheeseLines();
    cheeseRemaining.textContent = remaining;
    const progress = Math.max(0, (initialCheeseLines - remaining) / initialCheeseLines * 100);
    cheeseProgress.style.width = progress + '%';
  }

  function checkModeCompletion() {
    if(gameMode === 'sprint' && lines >= 40) {
      endGame('ğŸ‰ å®Œæˆï¼');
    } else if(gameMode === 'cheese' && countCheeseLines() === 0) {
      endGame('ğŸ‰ æ¸…ç†å®Œæˆï¼');
    }
  }

  // ========== æ’¤é”€/é‡åšç³»ç»Ÿ ==========
  function saveHistory() {
    if(gameMode !== 'practice') return;

    const state = {
      board: cloneMatrix(board),
      score,
      lines,
      level,
      combo,
      b2bCount,
      lastClearWasSpecial,
      holdType,
      holdLocked,
      queue: [...queue],
      bag: [...bag],
      piece: piece ? {
        type: piece.type,
        x: piece.x,
        y: piece.y,
        m: piece.m.map(row => [...row]),
        rotation: piece.rotation,
        color: piece.color,
        animX: piece.animX,
        animY: piece.animY
      } : null
    };

    // ç§»é™¤å½“å‰ä½ç½®ä¹‹åçš„å†å²
    historyStates = historyStates.slice(0, historyIndex + 1);
    
    historyStates.push(state);
    historyIndex = historyStates.length - 1;
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡
    while(historyStates.length > MAX_HISTORY) {
      historyStates.shift();
      historyIndex--;
    }

    updateStats();
}


  function undo() {
    if(gameMode !== 'practice' || historyIndex <= 0) return;

    historyIndex--;
    restoreHistory();
    vibrate(5);
  }

  function redo() {
    if(gameMode !== 'practice' || historyIndex >= historyStates.length - 1) return;

    historyIndex++;
    restoreHistory();
    vibrate(5);
  }

  function restoreHistory() {
    const state = historyStates[historyIndex];
    board = cloneMatrix(state.board);
    score = state.score;
    lines = state.lines;
    level = state.level;
    combo = state.combo;
    b2bCount = state.b2bCount;
    lastClearWasSpecial = state.lastClearWasSpecial;
    holdType = state.holdType;
    holdLocked = state.holdLocked;
    queue = [...state.queue];
    bag = [...state.bag];
    
    if(state.piece) {
      piece = {
        type: state.piece.type,
        x: state.piece.x,
        y: state.piece.y,
        m: state.piece.m.map(row => [...row]),
        rotation: state.piece.rotation,
        color: state.piece.color,
        animX: state.piece.animX,
        animY: state.piece.animY
      };
    } else {
      piece = null;
    }

    updateStats();
    redrawSidePanels();
    draw();
}


  // ========== é”®ä½è‡ªå®šä¹‰ ==========
  function buildKeybindUI() {
    keybindGrid.innerHTML = '';
    
    const actionNames = {
        moveLeft: 'å·¦ç§»',
        moveRight: 'å³ç§»',
        softDrop: 'è½¯é™',
        hardDrop: 'ç¡¬é™',
        rotateRight: 'é¡ºæ—¶é’ˆæ—‹è½¬ â†»', 
        rotateLeft: 'é€†æ—¶é’ˆæ—‹è½¬ â†º',   
        hold: 'æš‚å­˜',
        pause: 'æš‚åœ'
    };
    
    for(const action in keyBindings) {
        const item = document.createElement('div');
        item.className = 'keybind-item';
        
        const label = document.createElement('div');
        label.className = 'keybind-label';
        label.textContent = actionNames[action] || action;
        
        const button = document.createElement('div');
        button.className = 'keybind-button';
        button.textContent = formatKeys(keyBindings[action]);
        button.dataset.action = action;
        
        button.addEventListener('click', () => {
            startListening(action, button);
        });
        
        item.appendChild(label);
        item.appendChild(button);
        keybindGrid.appendChild(item);
    }
}

  function formatKeys(keys) {
    if(!keys || keys.length === 0) return 'æœªè®¾ç½®';
    return keys.map(k => {
      if(k === ' ') return 'Space';
      if(k.length === 1) return k.toUpperCase();
      return k;
    }).join(', ');
  }

  function startListening(action, button) {
    if(listeningForKey) {
      document.querySelector('.keybind-button.listening').classList.remove('listening');
    }
    
    listeningForKey = action;
    button.classList.add('listening');
    button.textContent = 'æŒ‰ä¸‹æŒ‰é”®...';
  }

  function assignKey(action, key) {
    // ç§»é™¤å…¶ä»–åŠ¨ä½œä¸­çš„æ­¤é”®
    for(const act in keyBindings) {
      keyBindings[act] = keyBindings[act].filter(k => k !== key);
    }
    
    // æ·»åŠ åˆ°å½“å‰åŠ¨ä½œ
    keyBindings[action] = [key];
    
    // æ›´æ–°UI
    const button = document.querySelector(`[data-action="${action}"]`);
    button.textContent = formatKeys(keyBindings[action]);
    button.classList.remove('listening');
    
    listeningForKey = null;
  }

  function resetKeybindings() {
    keyBindings = JSON.parse(JSON.stringify(DEFAULT_KEYBINDS));
    buildKeybindUI();
  }

  // ========== æ‰‹æŸ„æ”¯æŒ ==========
  window.addEventListener('gamepadconnected', (e) => {
    connectedGamepad = e.gamepad;
    gamepadIndicator.classList.add('connected');
    gamepadName.textContent = e.gamepad.id.substring(0, 20) + '...';
    console.log('æ‰‹æŸ„å·²è¿æ¥:', e.gamepad.id);
  });

  window.addEventListener('gamepaddisconnected', (e) => {
    connectedGamepad = null;
    gamepadIndicator.classList.remove('connected');
    console.log('æ‰‹æŸ„å·²æ–­å¼€');
  });

  function pollGamepad() {
    if(!connectedGamepad) return;

    const gamepads = navigator.getGamepads();
    const gp = gamepads[connectedGamepad.index];
    if(!gp) return;

    // æ£€æŸ¥æŒ‰é’®çŠ¶æ€
    for(const action in GAMEPAD_BINDINGS) {
      const buttons = GAMEPAD_BINDINGS[action];
      let pressed = false;
      
      for(const btnIdx of buttons) {
        if(gp.buttons[btnIdx] && gp.buttons[btnIdx].pressed) {
          pressed = true;
          break;
        }
      }

      const wasPressed = gamepadState[action] || false;

      if(pressed && !wasPressed) {
        // æŒ‰é’®åˆšè¢«æŒ‰ä¸‹
        if(action === 'moveLeft' || action === 'moveRight') {
          keyState[action] = true;
          dasTimer[action] = 0;
          arrTimer[action] = 0;
          if(action === 'moveLeft') move(-1);
          else move(1);
        } else {
          inputAction(action);
        }
      } else if(!pressed && wasPressed) {
        // æŒ‰é’®åˆšè¢«é‡Šæ”¾
        if(action === 'moveLeft' || action === 'moveRight') {
          keyState[action] = false;
          dasTimer[action] = 0;
          arrTimer[action] = 0;
        }
      }

      gamepadState[action] = pressed;
    }

    // æ–¹å‘é”®ï¼ˆè½´ï¼‰æ”¯æŒ
    const threshold = 0.5;
    const leftStickX = gp.axes[0];
    
    if(leftStickX < -threshold) {
      if(!gamepadState['axisLeft']) {
        keyState['moveLeft'] = true;
        dasTimer['moveLeft'] = 0;
        arrTimer['moveLeft'] = 0;
        move(-1);
        gamepadState['axisLeft'] = true;
      }
    } else {
      if(gamepadState['axisLeft']) {
        keyState['moveLeft'] = false;
        dasTimer['moveLeft'] = 0;
        arrTimer['moveLeft'] = 0;
        gamepadState['axisLeft'] = false;
      }
    }

    if(leftStickX > threshold) {
      if(!gamepadState['axisRight']) {
        keyState['moveRight'] = true;
        dasTimer['moveRight'] = 0;
        arrTimer['moveRight'] = 0;
        move(1);
        gamepadState['axisRight'] = true;
      }
    } else {
      if(gamepadState['axisRight']) {
        keyState['moveRight'] = false;
        dasTimer['moveRight'] = 0;
        arrTimer['moveRight'] = 0;
        gamepadState['axisRight'] = false;
      }
    }
  }

  // ========== éœ‡åŠ¨åé¦ˆ ==========
  function vibrate(duration) {
    if(!vibrationEnabled) return;
    
    // ç§»åŠ¨ç«¯éœ‡åŠ¨
    if(navigator.vibrate) {
      navigator.vibrate(duration);
    }

    // æ‰‹æŸ„éœ‡åŠ¨
    if(connectedGamepad && connectedGamepad.vibrationActuator) {
      const intensity = Math.min(1.0, duration / 50);
      connectedGamepad.vibrationActuator.playEffect('dual-rumble', {
        startDelay: 0,
        duration: duration,
        weakMagnitude: intensity * 0.5,
        strongMagnitude: intensity
      });
    }
  }

  // ========== åˆå§‹åŒ– ==========
(function init(){
  audioSystem = new AudioSystem();
  screenShaker = new ScreenShake(document.querySelector('.playfield-wrap'));
  bgParticles = new BackgroundParticles(document.querySelector('.playfield-wrap'));  
  applySkin('classic');
  buildPreviewCanvases();
  buildKeybindUI();
  resize();
  updateModeDisplay();
  showSettingsOverlay(true);
  draw();
  
  // åˆå§‹åŒ–ç«–å±æ£€æµ‹
  initOrientationDetection();
})();

})();
</script>
</body>
</html>