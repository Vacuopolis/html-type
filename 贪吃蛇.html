<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>终极贪吃蛇</title>
    <style>
        * {
    margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
background: linear-gradient(135deg, #1a1a2e, #16213e);
color: white;
font-family: 'Arial', sans-serif;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
height: 100vh;
overflow: hidden;
touch-action: manipulation;
}
#game-container {
position: relative;
width: 90vmin;
height: 90vmin;
max-width: 600px;
max-height: 600px;
box-shadow: 0 0 20px rgba(0, 255, 150, 0.2);
border-radius: 8px;
overflow: visible;
perspective: 1000px;
margin-bottom: 20px;
}

#game-canvas {
background: #0f0f23;
width: 100%;
height: 100%;
display: block;
transition: transform 0.3s ease;
}

/* 游戏UI元素 */
#score-container {
position: absolute;
top: 10px;
left: 10px;
font-size: 18px;
background: rgba(0, 0, 0, 0.6);
padding: 8px 12px;
border-radius: 20px;
display: flex;
gap: 20px;
z-index: 10;
}

#high-score {
color: #ffd700;
}
#status-display {
position: absolute;
top: 10px;
right: 10px;
background: rgba(0, 0, 0, 0.6);
padding: 8px 12px;
border-radius: 20px;
font-size: 16px;
z-index: 10;
display: flex;
flex-direction: column;
gap: 5px;
align-items: flex-end;
}
#food-info {
position: absolute;
top: calc(100% + 10px);
left: 10px;
background: rgba(0, 0, 0, 0.6);
padding: 8px 12px;
border-radius: 20px;
font-size: 16px;
opacity: 0;
transition: opacity 0.3s;
z-index: 10;
}
#food-info.show {
opacity: 1;
}
#power-up-indicator {
position: absolute;
top: calc(100% + 10px);
right: 10px;
background: rgba(0, 0, 0, 0.6);
padding: 8px 12px;
border-radius: 20px;
font-size: 16px;
opacity: 0;
transition: opacity 0.3s;
z-index: 10;
}
#power-up-indicator.show {
opacity: 1;
}
/* 控制按钮 */
#controls {
display: grid;
grid-template-columns: repeat(3, 1fr);
grid-template-rows: repeat(3, 1fr);
gap: 10px;
width: 200px;
height: 200px;
max-width: 60vmin;
max-height: 60vmin;
}
.control-btn {
background: rgba(255, 255, 255, 0.15);
border: 2px solid rgba(255, 255, 255, 0.3);
border-radius: 50%;
display: flex;
justify-content: center;
align-items: center;
font-size: 24px;
color: white;
cursor: pointer;
user-select: none;
touch-action: manipulation;
transition: transform 0.1s, background 0.2s;
}
.control-btn:active {
background: rgba(0, 255, 150, 0.3);
transform: scale(1.1);
}
#up-btn {
grid-column: 2;
grid-row: 1;
}
#left-btn {
grid-column: 1;
grid-row: 2;
}
#right-btn {
grid-column: 3;
grid-row: 2;
}
#down-btn {
grid-column: 2;
grid-row: 3;
}
/* 菜单和对话框 */
.overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.85);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 20;
text-align: center;
padding: 20px;
}
.dialog {
background: rgba(20, 30, 50, 0.95);
border-radius: 10px;
padding: 20px;
width: 80%;
max-width: 400px;
box-shadow: 0 0 20px rgba(0, 255, 150, 0.2);
border: 1px solid rgba(0, 255, 150, 0.3);
}
.dialog h2 {
margin-bottom: 15px;
color: #00ff96;
}
.btn {
background: linear-gradient(135deg, #00b894, #00cec9);
color: white;
border: none;
padding: 10px 20px;
margin: 8px;
border-radius: 5px;
font-size: 16px;
cursor: pointer;
transition: transform 0.1s, filter 0.2s;
}
.btn:hover {
filter: brightness(1.1);
}
.btn:active {
transform: scale(0.97);
}
.btn.secondary {
background: linear-gradient(135deg, #636e72, #b2bec3);
}
.btn.pause {
position: absolute;
top: 10px;
right: 10px;
background: rgba(0, 0, 0, 0.6);
color: white;
padding: 8px;
font-size: 14px;
z-index: 10;
}
/* 设置面板 */
.settings-group {
margin: 15px 0;
text-align: left;
}
.settings-group h3 {
margin-bottom: 10px;
color: #00ff96;
}
.slider-container {
display: flex;
align-items: center;
margin: 10px 0;
}
.slider-container label {
flex: 1;
}
.slider-container input {
flex: 2;
}
.checkbox-container {
display: flex;
align-items: center;
margin: 10px 0;
}
.checkbox-container label {
flex: 1;
margin-left: 10px;
}
/* 动画效果 */
.score-popup {
position: absolute;
font-size: 20px;
font-weight: bold;
pointer-events: none;
z-index: 15;
text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
animation: score-popup 0.8s ease-out forwards;
}

@keyframes score-popup {
0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
50% { transform: translate(-50%, -20px) scale(1.2); opacity: 1; }
100% { transform: translate(-50%, -40px) scale(1); opacity: 0; }
}

.combo-popup {
position: absolute;
font-size: 24px;
font-weight: bold;
pointer-events: none;
z-index: 15;
text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
animation: combo-popup 1s ease-out forwards;
}
@keyframes combo-popup {
0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
20% { transform: translate(-50%, -30px) scale(1.5); opacity: 1; }
80% { transform: translate(-50%, -60px) scale(1.2); opacity: 0.8; }
100% { transform: translate(-50%,
-80px) scale(1); opacity: 0; }
}

/* 游戏开始前的3D效果 */
.rotate-effect {
animation: rotate-canvas 15s infinite linear;
transform-style: preserve-3d;
}

@keyframes rotate-canvas {
0% { transform: rotateX(5deg) rotateY(0); }
50% { transform: rotateX(5deg) rotateY(5deg); }
100% { transform: rotateX(5deg) rotateY(0); }
}
/* 多人游戏UI样式 */
.input-group {
margin: 15px 0;
display: flex;
flex-direction: column;
}

.input-group label {
margin-bottom: 5px;
}

.input-group input {
padding: 10px;
border-radius: 5px;
border: 1px solid #444;
background: rgba(0, 0, 0, 0.2);
color: white;
}
.player-list {
margin: 15px 0;
text-align: left;
max-height: 200px;
overflow-y: auto;
}

.player-list ul {
list-style: none;
padding: 0;
}

.player-list li {
padding: 5px 10px;
margin: 5px 0;
background: rgba(0, 0, 0, 0.2);
border-radius: 5px;
display: flex;
justify-content: space-between;
align-items: center;
}
.player-list .current-player {
font-weight: bold;
border-left: 3px solid #00ff96;
padding-left: 8px;
}
.host-indicator {
color: #ffcc00;
margin-left: 5px;
}
.player-list .host {
font-weight: bold;
color: #00ff96;
}
/* 玩家分数样式 - 修改后的代码 */
.player-scores {
position: fixed;
top: 0;
left: 0;
right: 0;
background: rgba(0, 0, 0, 0.7);
padding: 10px;
max-height: 30vh;
overflow-y: auto;
z-index: 100;
display: flex;
flex-wrap: wrap;
justify-content: center;
transform: translateY(-100%);
transition: transform 0.3s ease;
}

.player-scores.show {
transform: translateY(0);
}

.player-score {
margin: 3px 5px;
padding: 3px 8px;
border-radius: 10px;
background: rgba(0, 0, 0, 0.5);
white-space: nowrap;
}

.player-scores .current-player {
font-weight: bold;
border-left: 3px solid #00ff96;
padding-left: 5px;
}

/* 聊天功能 - 修改后的代码 */
#multiplayer-chat {
position: fixed;
bottom: 0;
left: 0;
right: 0;
width: 100%;
height: 30vh;
max-height: 30vh;
background: rgba(0, 0, 0, 0.85);
border-radius: 10px 10px 0 0;
z-index: 100;
display: flex;
flex-direction: column;
transform: translateY(100%);
transition: transform 0.3s ease;
pointer-events: auto;
}

#multiplayer-chat.show {
transform: translateY(0);
}

.chat-handle {
position: absolute;
top: -25px;
left: 50%;
transform: translateX(-50%);
width: 50px;
height: 5px;
background: rgba(255, 255, 255, 0.5);
border-radius: 5px;
cursor: pointer;
}

.chat-messages {
flex: 1;
height: calc(100% - 50px);
overflow-y: auto;
padding: 10px;
font-size: 14px;
pointer-events: none;
}

.chat-input {
display: flex;
pointer-events: auto;
padding: 10px;
border-top: 1px solid rgba(255, 255, 255, 0.2);
}

.chat-input input {
flex: 1;
padding: 8px;
border-radius: 3px;
border: none;
background: rgba(255, 255, 255, 0.1);
color: white;
}

.chat-input button {
    margin-left: 5px;
    padding: 8px;
    background: linear-gradient(135deg, #00b894, #00cec9);
    color: white;
    border: none;
    border-radius: 5px;
    font-size: 18px;
    cursor: pointer;
}

/* 复活倒计时消息样式 */
.respawn-message {
  animation: pulse 1.5s infinite;
  pointer-events: none;
  text-align: center;
  z-index: 999;
}

/* 死亡时的视觉效果 */
.death-flash {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 0, 0, 0.3);
  animation: death-flash 0.5s ease-out;
  pointer-events: none;
  z-index: 50;
}

@keyframes death-flash {
  0% { opacity: 1; }
  100% { opacity: 0; }
}

/* 复活时的视觉效果 */
.respawn-flash {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 255, 0, 0.3);
  animation: respawn-flash 0.8s ease-out;
  pointer-events: none;
  z-index: 50;
}

@keyframes respawn-flash {
  0% { opacity: 1; }
  100% { opacity: 0; }
}

/* 状态图标样式 */
.status-icon {
  display: inline-block;
  margin-right: 5px;
  font-size: 1.2em;
  vertical-align: middle;
}

/* 复活中状态特效 */
.respawning {
  animation: respawning-pulse 1s infinite alternate;
}

@keyframes respawning-pulse {
  0% { opacity: 0.6; }
  100% { opacity: 1; }
}

@keyframes pulse {
  0% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.1); }
  100% { transform: translate(-50%, -50%) scale(1); }
}

/* 生命值显示样式 */
.player-score .lives-count {
  margin-left: 5px;
  color: #ff4081;
}


/* 游戏大厅样式 */
.game-info {
background: rgba(0, 0, 0, 0.3);
padding: 10px;
border-radius: 5px;
margin-bottom: 15px;
text-align: center;
}

#lobby-game-id {
font-weight: bold;
color: #00ff96;
font-size: 24px;
letter-spacing: 2px;
}

.share-tip {
font-size: 14px;
opacity: 0.8;
margin-top: 5px;
}

.player-list-container {
background: rgba(0, 0, 0, 0.2);
padding: 10px;
border-radius: 5px;
margin-bottom: 15px;
max-height: 200px;
overflow-y: auto;
}

/* 游戏设置面板样式 */
.game-settings {
background: rgba(0, 0, 0, 0.2);
padding: 10px;
border-radius: 5px;
margin-bottom: 15px;
max-height: 200px;
overflow-y: auto;
}

.settings-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 10px;
cursor: pointer;
}

.settings-header h3 {
margin: 0;
color: #00ff96;
}

.toggle-icon {
font-size: 18px;
transition: transform 0.3s ease;
}
.toggle-icon.open {
transform: rotate(180deg);
}

.settings-content {
overflow: hidden;
max-height: 0;
transition: max-height 0.5s ease-out, opacity 0.3s ease-in;
opacity: 0;
}

.settings-content.open {
max-height: 500px;
opacity: 1;
}

.setting-item {
margin: 8px 0;
display: flex;
justify-content: space-between;
align-items: center;
}

.setting-item label {
flex: 1;
margin-right: 10px;
}

.setting-item input {
width: 60px;
padding: 5px;
background: rgba(0, 0, 0, 0.3);
border: 1px solid #444;
border-radius: 3px;
color: white;
}

.setting-item input[type="range"] {
width: 100px;
}

.setting-item select {
padding: 5px;
background: rgba(0, 0, 0, 0.3);
border: 1px solid #444;
border-radius: 3px;
color: white;
}

.host-only {
display: none;
}

.host-only.show {
display: block;
}

/* 移动设备响应式布局 */
@media (max-width: 768px) {
#game-container {
width: 95vmin;
height: 95vmin;
margin-bottom: 10px;
}
#controls {
    width: 180px;
    height: 180px;
    margin-top: 10px;
}

/* 食物信息和能力提示调整 */
#food-info, #power-up-indicator {
    font-size: 12px;
    padding: 5px 8px;
}


/* 重生按钮调整 */
#respawn-btn {
    bottom: auto;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 999;
    padding: 10px 20px;
    font-size: 16px;
}

/* 移动设备上暂停按钮调整 */
.btn.pause {
    padding: 5px;
    font-size: 12px;
}

/* 移动设备上的对话框调整 */
.dialog {
    width: 90%;
    padding: 15px;
}

.dialog h2 {
    font-size: 18px;
}

.btn {
    padding: 8px 15px;
    font-size: 14px;
    margin: 5px;
}

/* 多人游戏UI在移动端的调整 */
.toggle-scores-btn, .toggle-chat-btn {
    font-size: 24px;
    padding: 8px 12px;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* 玩家分数在移动端的样式 */
.player-score {
    font-size: 12px;
    padding: 2px 6px;
    margin: 2px 3px;
}

/* 添加到现有CSS */
#joystick-container {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 150px;
    height: 150px;
    z-index: 15;
}

#joystick-base {
    position: relative;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.4);
    border-radius: 50%;
}

#joystick-stick {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    background: rgba(0, 255, 150, 0.6);
    border-radius: 50%;
    cursor: pointer;
    user-select: none;
    touch-action: none;
}

.joystick-left {
    left: 20px;
    transform: translateX(0);
}

.joystick-right {
    left: auto;
    right: 20px;
    transform: translateX(0);
}

.key-binding-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.key-binding {
    display: flex;
    align-items: center;
    gap: 8px;
}

.key-binding label {
    width: 60px;
}

.key-binding input {
    flex: 1;
    background: rgba(0, 0, 0, 0.3);
    color: white;
    border: 1px solid #444;
    border-radius: 4px;
    padding: 5px;
    cursor: pointer;
}

.key-binding .reset-key {
    padding: 3px 8px;
    background: rgba(100, 100, 100, 0.4);
    border: 1px solid #555;
    border-radius: 3px;
    color: white;
    cursor: pointer;
}

.radio-container {
    display: flex;
    gap: 15px;
    margin-bottom: 10px;
}

.radio-container input[type="radio"] {
    margin-right: 5px;
}

.select-container {
    display: flex;
    align-items: center;
    margin: 10px 0;
}

.select-container label {
    flex: 1;
}

.select-container select {
    flex: 2;
    padding: 5px;
    background: rgba(0, 0, 0, 0.3);
    color: white;
    border: 1px solid #444;
    border-radius: 4px;
}

/* 添加多人游戏控制按钮样式 */
#multiplayer-controls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    display: flex;
    flex-direction: row;
    gap: 10px;
    z-index: 101;
    display: none;  /* 默认隐藏 */
}

.toggle-scores-btn, .toggle-chat-btn {
    font-size: 24px;
    padding: 8px 12px;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.6);
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.3);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    transition: all 0.2s ease;
}

.toggle-scores-btn:hover, .toggle-chat-btn:hover {
    background: rgba(0, 255, 150, 0.3);
    transform: scale(1.1);
}

/* 通知样式 */
#notification-container {
    pointer-events: none; /* 确保不拦截按钮点击 */
}

.system-notification {
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    margin: 5px;
    max-width: 80%;
    text-align: center;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    pointer-events: none;
}

/* 多人游戏暂停菜单特殊样式 */
.pause-menu-multiplayer h2 {
    color: #4CAF50;
}

.pause-menu-multiplayer .btn {
    background: linear-gradient(135deg, #4CAF50, #45a049);
}

.setting-description {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 5px;
    margin-bottom: 10px;
    padding-left: 10px;
    border-left: 2px solid rgba(0, 255, 150, 0.5);
}

.mode-info-btn {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    font-size: 14px;
    font-weight: bold;
    margin-left: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, #00b894, #00cec9);
    border: none;
    cursor: pointer;
    color: white;
    padding: 0;
    box-shadow: 0 0 5px rgba(0, 255, 150, 0.5);
    z-index: 5;
}

.mode-info-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 8px rgba(0, 255, 150, 0.8);
}


/* 模式说明对话框样式 */
.mode-info-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(20, 30, 50, 0.95);
    padding: 20px;
    border-radius: 10px;
    z-index: 30;
    max-width: 400px;
    box-shadow: 0 0 20px rgba(0, 255, 150, 0.2);
    border: 1px solid rgba(0, 255, 150, 0.3);
}

.mode-info-dialog h3 {
    color: #00ff96;
    margin-top: 0;
    margin-bottom: 15px;
}

.mode-info-dialog p {
    margin-bottom: 15px;
}

.mode-info-dialog .close-btn {
    background: linear-gradient(135deg, #00b894, #00cec9);
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
}

.mode-info-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    z-index: 25;
}

/* 在现有CSS部分添加传送门样式 */
.portal {
  position: absolute;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  animation: portal-pulse 2s infinite alternate;
  box-shadow: 0 0 20px currentColor;
}

.portal-blue {
  background: radial-gradient(#2196F3, #0D47A1);
  color: #2196F3;
}

.portal-pink {
  background: radial-gradient(#E91E63, #880E4F);
  color: #E91E63;
}

@keyframes portal-pulse {
  0% { transform: scale(0.9); opacity: 0.8; }
  100% { transform: scale(1.1); opacity: 1; }
}

.teleport-effect {
  position: absolute;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.3);
  z-index: 100;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s;
}

.teleport-effect.active {
  opacity: 1;
  animation: teleport-flash 0.5s;
}

@keyframes teleport-flash {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}

/* 添加以下CSS样式 */
.game-settings .setting-item {
    transition: opacity 0.3s ease, max-height 0.5s ease;
}

.game-settings .settings-content:not(.open) + .setting-item,
.game-settings .settings-content:not(.open) ~ .setting-item {
    max-height: 0;
    opacity: 0;
    overflow: hidden;
    margin: 0;
    padding: 0;
}

.game-settings .settings-content.open + .setting-item,
.game-settings .settings-content.open ~ .setting-item {
    max-height: 50px;
    opacity: 1;
    margin: 8px 0;
}

    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>
    <!-- 游戏容器 -->
    <div id="game-container">
        <canvas id="game-canvas" class="rotate-effect"></canvas>
        <div id="score-container">
            <div>分数: <span id="score">0</span></div>
            <div>最高分: <span id="high-score">0</span></div>
        </div>
        <div id="status-display">
            <div id="speed-display">速度: 正常</div>
            <div id="mode-display">模式: 普通</div>
        </div>
        <div id="food-info"></div>
        <div id="power-up-indicator"></div>
        <button id="pause-btn" class="btn pause">暂停</button>
    </div>

    <!-- 控制按钮 -->
    <div id="controls">
        <div class="control-btn" id="up-btn">↑</div>
        <div class="control-btn" id="left-btn">←</div>
        <div class="control-btn" id="right-btn">→</div>
        <div class="control-btn" id="down-btn">↓</div>
    </div>

    <!-- 主菜单 -->
<div id="main-menu" class="overlay">
    <div class="dialog">
        <h2>终极贪吃蛇</h2>
        <p>选择一个游戏模式开始游戏</p>
        <button id="rules-btn" class="btn" style="position: absolute; top: 20px; right: 20px; width: 40px; height: 40px; border-radius: 50%; font-size: 20px; display: flex; justify-content: center; align-items: center; background: linear-gradient(135deg, #00b894, #00cec9);">?</button>
        <button id="classic-btn" class="btn">经典模式</button>
        <button id="challenge-btn" class="btn">夺冠模式</button>
        <button id="multiplayer-btn" class="btn">多人游戏</button>
        <button id="settings-btn" class="btn secondary">设置</button>
    </div>
</div>


    <!-- 游戏结束菜单 -->
    <div id="game-over" class="overlay" style="display: none;">
        <div class="dialog">
            <h2 id="game-over-title">游戏结束</h2>
            <p id="final-score">最终分数: 0</p>
            <p id="final-length">蛇的长度: 0</p>
            <p id="game-over-message"></p>
            <button id="restart-btn" class="btn">再来一局</button>
            <button id="menu-btn" class="btn secondary">返回菜单</button>
        </div>
    </div>

    <!-- 暂停菜单 -->
    <div id="pause-menu" class="overlay" style="display: none;">
        <div class="dialog">
            <h2>游戏暂停</h2>
            <button id="resume-btn" class="btn">继续游戏</button>
            <button id="pause-menu-btn" class="btn secondary">返回菜单</button>
        </div>
    </div>
    
<!-- 虚拟摇杆控制 -->
<div id="joystick-container" style="display: none;">
    <div id="joystick-base">
        <div id="joystick-stick"></div>
    </div>
</div>

    <!-- 设置菜单 -->
<div id="settings-menu" class="overlay" style="display: none;">
    <div class="dialog">
        <h2>游戏设置</h2>
        
        <div class="settings-group">
            <h3>游戏速度</h3>
            <div class="slider-container">
                <label for="speed-slider">速度:</label>
                <input type="range" id="speed-slider" min="5" max="20" value="10">
                <span id="speed-value">10</span>
            </div>
        </div>
        
        <div class="settings-group">
            <h3>游戏选项</h3>
            <div class="checkbox-container">
                <input type="checkbox" id="sound-checkbox" checked>
                <label for="sound-checkbox">音效</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="particles-checkbox" checked>
                <label for="particles-checkbox">粒子效果</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="grid-checkbox" checked>
                <label for="grid-checkbox">显示网格</label>
            </div>
        </div>
        
        <!-- 新增: 控制设置组 -->
        <div class="settings-group" id="mobile-controls-group">
            <h3>移动设备控制</h3>
            <div class="radio-container">
    <input type="radio" id="control-buttons" name="control-type" value="buttons">
    <label for="control-buttons">方向按钮</label>
    <input type="radio" id="control-joystick" name="control-type" value="joystick" checked>
    <label for="control-joystick">虚拟摇杆</label>
</div>
            </div>
            <div class="slider-container">
                <label for="control-size-slider">大小:</label>
                <input type="range" id="control-size-slider" min="50" max="150" value="100">
                <span id="control-size-value">100%</span>
            </div>
            <div class="select-container">
                <label for="control-position">位置:</label>
                <select id="control-position">
                    <option value="center">居中</option>
                    <option value="left">靠左</option>
                    <option value="right">靠右</option>
                </select>
            </div>
        </div>
        
        <!-- 新增: 键盘控制设置组 -->
        <div class="settings-group" id="keyboard-controls-group">
            <h3>键盘控制</h3>
            <div class="key-binding-container">
                <div class="key-binding">
                    <label for="key-up">向上:</label>
                    <input type="text" id="key-up" readonly value="↑, W" data-direction="up">
                    <button class="reset-key" data-direction="up">重置</button>
                </div>
                <div class="key-binding">
                    <label for="key-down">向下:</label>
                    <input type="text" id="key-down" readonly value="↓, S" data-direction="down">
                    <button class="reset-key" data-direction="down">重置</button>
                </div>
                <div class="key-binding">
                    <label for="key-left">向左:</label>
                    <input type="text" id="key-left" readonly value="←, A" data-direction="left">
                    <button class="reset-key" data-direction="left">重置</button>
                </div>
                <div class="key-binding">
                    <label for="key-right">向右:</label>
                    <input type="text" id="key-right" readonly value="→, D" data-direction="right">
                    <button class="reset-key" data-direction="right">重置</button>
                </div>
                <div class="key-binding">
                    <label for="key-pause">暂停:</label>
                    <input type="text" id="key-pause" readonly value="Space, P" data-direction="pause">
                    <button class="reset-key" data-direction="pause">重置</button>
                </div>
            </div>
        </div>
        
        <button id="save-settings-btn" class="btn">保存设置</button>
        <button id="settings-menu-btn" class="btn secondary">返回菜单</button>
    </div>
</div>

<!-- 在body中添加游戏规则对话框 -->
<div id="rules-menu" class="overlay" style="display: none;">
    <div class="dialog" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
        <h2>游戏规则与说明</h2>
        
        <div class="setting-item">
    <label for="game-mode-setting">多人游戏模式:</label>
    <select id="game-mode-setting">
        <option value="classic" selected>经典模式</option>
        <option value="challenge">夺冠模式</option>
    </select>
    <button id="mode-info-btn" class="btn mode-info-btn">?</button>
</div>

        
        <div class="settings-group">
            <h3>食物类型</h3>
            <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                <tr style="border-bottom: 1px solid rgba(255,255,255,0.2); padding: 8px 0;">
                    <td style="padding: 8px;"><div style="width: 20px; height: 20px; border-radius: 50%; background-color: #ff3333; display: inline-block;"></div></td>
                    <td style="padding: 8px;"><strong>红色食物</strong></td>
                    <td style="padding: 8px;">增加速度 (+15分)</td>
                </tr>
                <tr style="border-bottom: 1px solid rgba(255,255,255,0.2); padding: 8px 0;">
                    <td style="padding: 8px;"><div style="width: 20px; height: 20px; border-radius: 50%; background-color: #ffcc00; display: inline-block;"></div></td>
                    <td style="padding: 8px;"><strong>黄色食物</strong></td>
                    <td style="padding: 8px;">翻倍得分5秒 (+10分)</td>
                </tr>
                <tr style="border-bottom: 1px solid rgba(255,255,255,0.2); padding: 8px 0;">
                    <td style="padding: 8px;"><div style="width: 20px; height: 20px; border-radius: 50%; background-color: #33cc33; display: inline-block;"></div></td>
                    <td style="padding: 8px;"><strong>绿色食物</strong></td>
                    <td style="padding: 8px;">降低速度 (+10分)</td>
                </tr>
                <tr style="border-bottom: 1px solid rgba(255,255,255,0.2); padding: 8px 0;">
                    <td style="padding: 8px;"><div style="width: 20px; height: 20px; border-radius: 50%; background-color: #3399ff; display: inline-block;"></div></td>
                    <td style="padding: 8px;"><strong>蓝色食物</strong></td>
                    <td style="padding: 8px;">穿墙能力5秒 (+30分)</td>
                </tr>
                <tr style="border-bottom: 1px solid rgba(255,255,255,0.2); padding: 8px 0;">
                    <td style="padding: 8px;"><div style="width: 20px; height: 20px; border-radius: 50%; background-color: #9933ff; display: inline-block;"></div></td>
                    <td style="padding: 8px;"><strong>紫色食物</strong></td>
                    <td style="padding: 8px;">无敌能力5秒 (+40分)</td>
                </tr>
            </table>
        </div>
        
        <div class="settings-group">
            <h3>障碍物与特殊元素</h3>
            <div style="display: flex; align-items: center; margin: 10px 0;">
                <div style="width: 30px; height: 30px; background-color: #ad1457; margin-right: 10px; display: flex; justify-content: center; align-items: center;">
                    <div style="width: 20px; height: 20px; background-color: #ffeb3b; clip-path: polygon(50% 0%, 0% 100%, 100% 100%);"></div>
                </div>
                <span><strong>障碍物：</strong>触碰将导致游戏结束（无敌状态除外）</span>
            </div>
            
            <div style="display: flex; align-items: center; margin: 10px 0;">
                <div style="width: 30px; height: 30px; border-radius: 50%; background-color: #00E5FF; margin-right: 10px; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;">🚪</div>
                <span><strong>穿墙能力：</strong>蓝色环绕效果，允许蛇穿过游戏边界</span>
            </div>
            
            <div style="display: flex; align-items: center; margin: 10px 0;">
                <div style="width: 30px; height: 30px; border-radius: 50%; background-color: #E040FB; margin-right: 10px; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;">🛡️</div>
                <span><strong>无敌能力：</strong>紫色环绕效果，可以穿过障碍物和自身</span>
                
            </div>
<div style="display: flex; align-items: center; margin: 10px 0;">
    <div style="width: 30px; height: 30px; border-radius: 50%; background: radial-gradient(#2196F3, #0D47A1); margin-right: 10px; box-shadow: 0 0 10px #2196F3;"></div>
    <span><strong>传送门(仅多人模式)：</strong>随机出现的门户，进入后会传送到另一个门户位置</span>
</div>

            <div class="settings-group">
    <h3>多人游戏控制</h3>
    <div style="display: flex; align-items: center; margin: 10px 0;">
        <div style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; background: rgba(0, 0, 0, 0.6); color: white; display: flex; justify-content: center; align-items: center; font-size: 24px;">🏆</div>
        <span><strong>分数按钮：</strong>点击显示或隐藏所有玩家的分数面板/血量，查看比赛实时排名/情况。</span>
    </div>
    
    <div style="display: flex; align-items: center; margin: 10px 0;">
        <div style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; background: rgba(0, 0, 0, 0.6); color: white; display: flex; justify-content: center; align-items: center; font-size: 24px;">💬</div>
        <span><strong>聊天按钮：</strong>点击打开聊天界面，与其他玩家实时交流或查看游戏通知。</span>
    </div>
</div>

        </div>
        
        <div class="settings-group">
            <h3>操作方式</h3>
            <p><strong>键盘：</strong> 方向键或WASD控制方向，空格键或P键暂停游戏</p>
            <p><strong>触摸屏：</strong> 使用屏幕底部的方向按钮或虚拟摇杆控制</p>
            <p><strong>连击奖励：</strong> 连续吃到食物会获得分数加成</p>
        </div>
        
        <button id="rules-back-btn" class="btn">返回</button>
    </div>
</div>


<!-- 多人游戏菜单和UI -->
<div id="multiplayer-menu" class="overlay" style="display: none;">
    <div class="dialog">
        <h2>多人游戏</h2>
        <div class="input-group">
            <label for="player-name">您的名字:</label>
            <input type="text" id="player-name" maxlength="15" placeholder="输入名字...">
        </div>
        <div class="button-group">
            <button id="create-game-btn" class="btn">创建游戏</button>
            <button id="join-game-btn" class="btn">加入游戏</button>
        </div>
        <button id="multiplayer-back-btn" class="btn secondary">返回</button>
    </div>
</div>

<div id="join-game-menu" class="overlay" style="display: none;">
    <div class="dialog">
        <h2>加入游戏</h2>
        <div class="input-group">
            <label for="game-id">游戏ID:</label>
            <input type="text" id="game-id" maxlength="4" placeholder="输入房间ID...">
        </div>
        <button id="join-btn" class="btn">加入</button>
        <button id="join-back-btn" class="btn secondary">返回</button>
    </div>
</div>

<div id="game-lobby" class="overlay" style="display: none;">
    <div class="dialog">
        <h2>游戏大厅</h2>
        <div class="game-info">
            <p>游戏ID: <span id="lobby-game-id">XXXXXX</span></p>
            <p class="share-tip">分享此ID给好友加入游戏</p>
        </div>
        
        <div class="game-settings host-only">
    <div class="settings-header">
        <h3>游戏设置</h3>
        <span class="toggle-icon">▼</span>
    </div>
    <div class="settings-content">
        <div class="setting-item">
            <label for="game-mode-setting">游戏模式:</label>
            <div style="display: flex; align-items: center;">
                <select id="game-mode-setting">
                    <option value="classic" selected>经典模式</option>
                    <option value="challenge">夺冠模式</option>
                </select>
                <button id="mode-info-btn" class="mode-info-btn">?</button>
            </div>
        </div>
        
        <div class="setting-item">
            <label for="grid-size-setting">网格大小:</label>
            <input type="range" id="grid-size-setting" min="20" max="50" value="30">
            <span id="grid-size-value">30</span>
        </div>
        
        <div class="setting-item">
            <label for="game-speed-setting">游戏速度:</label>
            <select id="game-speed-setting">
                <option value="slow">慢速</option>
                <option value="normal" selected>正常</option>
                <option value="fast">快速</option>
                <option value="extreme">极速</option>
            </select>
        </div>
        
        <div class="setting-item">
            <label for="food-count-setting">食物数量:</label>
            <input type="range" id="food-count-setting" min="1" max="10" value="5">
            <span id="food-count-value">5</span>
        </div>
        
        <div class="setting-item">
            <label for="obstacle-density-setting">障碍物密度:</label>
            <select id="obstacle-density-setting">
                <option value="none">无</option>
                <option value="low">低</option>
                <option value="medium" selected>中</option>
                <option value="high">高</option>
            </select>
        </div>
        
        <div class="setting-item">
            <label for="power-ups-setting">能力道具:</label>
            <select id="power-ups-setting">
                <option value="normal" selected>正常</option>
                <option value="frequent">频繁</option>
                <option value="rare">稀有</option>
                <option value="none">无</option>
            </select>
        </div>
    </div>
</div>

        
        <div class="player-list-container">
            <h3>玩家列表:</h3>
            <ul id="player-list"></ul>
        </div>
        <button id="start-game-btn" class="btn">开始游戏</button>
        <button id="leave-game-btn" class="btn secondary">离开游戏</button>
    </div>
</div>



<div id="multiplayer-status" style="display: none;">
    <div class="player-scores"></div>
</div>

<div id="multiplayer-chat" style="display: none;">
    <div class="chat-messages"></div>
    <div class="chat-input">
        <input type="text" id="chat-input" placeholder="输入消息...">
        <button id="send-chat-btn">发送</button>
    </div>
</div>

    <script>

    
        // ============== 游戏初始化与核心变量 ==============
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // 扩展游戏设置对象
const settings = {
    gridSize: 30,               // 网格大小
    baseSpeed: 150,             // 基础速度(毫秒)
    challengeTarget: 1000,      // 挑战模式目标分数
    soundEnabled: true,         // 音效开关
    particlesEnabled: true,     // 粒子效果开关
    gridEnabled: true,          // 网格显示开关
    speedMultiplier: 1.0,       // 速度倍率
    
    // 控制设置
    controlType: 'joystick',     // 移动设备控制类型: 'buttons' 或 'joystick'
    controlSize: 1.0,           // 控制按钮大小倍率
    controlPosition: 'center',  // 控制按钮位置: 'center', 'left', 'right'
    keyBindings: {              // 自定义键盘绑定
        up: ['ArrowUp', 'w', 'W'],
        down: ['ArrowDown', 's', 'S'],
        left: ['ArrowLeft', 'a', 'A'],
        right: ['ArrowRight', 'd', 'D'],
        pause: [' ', 'p', 'P']
    }
};

        
        // 游戏状态
        let gameState = {
            snake: [],                  // 蛇的身体段
            snakeInterpolated: [],      // 用于平滑动画的插值位置
            food: null,                 // 当前食物
            obstacles: [],              // 障碍物
            direction: 'right',         // 当前方向
            nextDirection: 'right',     // 下一次更新时的方向
            score: 0,                   // 分数
            highScore: 0,               // 最高分
            combo: 0,                   // 连击数
            speed: settings.baseSpeed,  // 当前速度
            gameMode: '',               // 游戏模式
            isPlaying: false,           // 游戏是否进行中
            isPaused: false,            // 游戏是否暂停
            isGameOver: false,          // 游戏是否结束
            powerUpActive: false,       // 能力是否激活
            powerUpType: null,          // 激活的能力类型
            powerUpTimeLeft: 0,         // 能力剩余时间
            lastFrameTime: 0,           // 上一帧时间
            accumulatedTime: 0,         // 累积时间
            animationFrame: null,       // 当前动画帧
            particles: [],              // 粒子效果
            trail: [],                   // 移动轨迹
            scoreMultiplierActive: false,  // 分数翻倍是否激活
            scoreMultiplierTimeLeft: 0    // 分数翻倍剩余时间
        };
        
        // ============== 多人游戏代码 ==============
let socket;
let isMultiplayerGame = false;
let multiplayerGameId = null;
let isHost = false;
let playerName = '';
let playerId = '';
let connectedPlayers = [];
let multiplayerGameState = null;

// 初始化Socket.io
function initializeMultiplayer() {
    try {
        socket = io();
        
        // 连接事件
        socket.on('connect', () => {
            console.log('已连接到服务器');
            playerId = socket.id;
        });
        
        // 连接错误处理
        socket.on('connect_error', (error) => {
            console.error('连接服务器失败:', error);
            alert('无法连接到游戏服务器，请检查网络连接');
            // 确保返回按钮仍然可用
            ensureBackButtonWorks();
        });
        
        // 错误处理
        socket.on('error', (message) => {
            alert('错误: ' + message);
            // 确保返回按钮仍然可用
            ensureBackButtonWorks();
        });
        
        // 游戏创建成功
        socket.on('gameCreated', (gameId) => {
            multiplayerGameId = gameId;
            isHost = true;
            document.getElementById('multiplayer-menu').style.display = 'none';
            document.getElementById('lobby-game-id').textContent = gameId;
            document.getElementById('game-lobby').style.display = 'flex';
            // 确保设置面板可见性正确
            updateSettingsVisibility();
            setTimeout(setupLobbyEvents, 300); // 使用延时确保DOM完全渲染
        });
        
        // 加入游戏成功
        socket.on('gameJoined', (gameId) => {
            multiplayerGameId = gameId;
            isHost = false;
            document.getElementById('join-game-menu').style.display = 'none';
            document.getElementById('lobby-game-id').textContent = gameId;
            document.getElementById('game-lobby').style.display = 'flex';
            // 确保设置面板可见性正确
            updateSettingsVisibility();
            setTimeout(setupLobbyEvents, 300); // 使用延时确保DOM完全渲染
        });
        
        // 玩家加入/更新
        socket.on('playerJoined', (players) => {
            connectedPlayers = players;
            updatePlayerList();
            updateSettingsVisibility();
        });
        
        // 玩家离开
        socket.on('playerLeft', (data) => {
            connectedPlayers = data.players;
            updatePlayerList();
            addChatMessage(`${data.playerName} 离开了游戏`, 'system');
        });
        
        // 游戏开始
        socket.on('gameStarted', (gameData) => {
            document.getElementById('game-lobby').style.display = 'none';
            startMultiplayerGame(gameData);
        });
        
        // 游戏状态更新
        socket.on('gameStateUpdate', (gameState) => {
            updateMultiplayerGameState(gameState);
        });
        
        // 食物被吃掉
        socket.on('foodEaten', (data) => {
            // 显示食物被吃提示
            if (data.playerId === playerId) {
                createScorePopup(data.position.x, data.position.y, data.points);
            }
            addChatMessage(`${data.playerName} 吃到了食物 (+${data.points})`, 'system');
        });
        
        // 新食物生成
        socket.on('foodSpawned', (food) => {
            // 可以添加提示动画
        });
        
        // 新障碍物生成
        socket.on('obstacleSpawned', (obstacle) => {
            // 可以添加提示动画
        });
        
        // 能力道具激活
        socket.on('powerUpActivated', (data) => {
            const powerUpName = data.powerUpType === 'phase' ? '穿墙' : '无敌';
            addChatMessage(`${data.playerName} 激活了${powerUpName}能力!`, 'system');
        });
        
        // 玩家死亡
        // playerDied 事件监听
// 在客户端修改playerDied事件处理，让夺冠模式玩家能重生
socket.on('playerDied', (data) => {
    let message = `${data.playerName} 死亡了`;
    console.log('收到playerDied事件:', data);
    
    // 添加死亡原因
    if (data.reason === 'player' && data.killerName) {
        message += ` (被 ${data.killerName} 击败)`;
    } else if (data.reason === 'boundary') {
        message += ' (撞墙)';
    } else if (data.reason === 'obstacle') {
        message += ' (撞到障碍物)';
    } else if (data.reason === 'self') {
        message += ' (撞到自己)';
    }
    
    // 如果是当前玩家，处理界面
    if (data.playerId === playerId) {
        // 经典模式下，根据剩余生命处理
        if (data.gameMode === 'classic') {
            if (data.livesLeft > 0) {
                // 还有生命，显示复活倒计时
                showRespawnOption();
            } else {
                // 没有生命了，显示最终死亡消息
                const gameOverMessage = document.createElement('div');
                gameOverMessage.id = 'death-message';
                gameOverMessage.textContent = '你已用尽所有生命!';
                gameOverMessage.style.position = 'absolute';
                gameOverMessage.style.top = '40%';
                gameOverMessage.style.left = '50%';
                gameOverMessage.style.transform = 'translate(-50%, -50%)';
                gameOverMessage.style.color = '#FF5252';
                gameOverMessage.style.fontSize = '28px';
                gameOverMessage.style.fontWeight = 'bold';
                gameOverMessage.style.textShadow = '0 0 10px rgba(255, 0, 0, 0.5)';
                gameOverMessage.style.zIndex = '999';
                gameOverMessage.style.textAlign = 'center';
                gameOverMessage.style.padding = '15px 30px';
                gameOverMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                gameOverMessage.style.borderRadius = '10px';
                document.getElementById('game-container').appendChild(gameOverMessage);
            }
        } 
        // 夺冠模式，显示手动重生按钮
        else if (data.gameMode === 'challenge') {
            const deathMessage = document.createElement('div');
            deathMessage.id = 'death-message';
            deathMessage.textContent = '你已死亡! 点击下方按钮重生';
            deathMessage.style.position = 'absolute';
            deathMessage.style.top = '40%';
            deathMessage.style.left = '50%';
            deathMessage.style.transform = 'translate(-50%, -50%)';
            deathMessage.style.color = '#FF5252';
            deathMessage.style.fontSize = '28px';
            deathMessage.style.fontWeight = 'bold';
            deathMessage.style.textShadow = '0 0 10px rgba(255, 0, 0, 0.5)';
            deathMessage.style.zIndex = '999';
            deathMessage.style.textAlign = 'center';
            deathMessage.style.padding = '15px 30px';
            deathMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            deathMessage.style.borderRadius = '10px';
            document.getElementById('game-container').appendChild(deathMessage);
            
            // 创建重生按钮
            const container = document.getElementById('game-container');
            const respawnBtn = document.createElement('button');
            respawnBtn.id = 'respawn-btn';
            respawnBtn.className = 'btn';
            respawnBtn.textContent = '点击重生';
            
            // 调整按钮样式以适应设备
            if (window.innerWidth <= 768) {
                // 移动设备样式 - 居中显示
                respawnBtn.style.position = 'absolute';
                respawnBtn.style.top = '60%';
                respawnBtn.style.left = '50%';
                respawnBtn.style.transform = 'translate(-50%, -50%)';
            } else {
                // 桌面样式 - 在画布下方
                respawnBtn.style.position = 'absolute';
                respawnBtn.style.top = 'calc(40% + 80px)';
                respawnBtn.style.left = '50%';
                respawnBtn.style.transform = 'translateX(-50%)';
            }
            
            respawnBtn.style.zIndex = '999';
            respawnBtn.style.fontSize = window.innerWidth <= 768 ? '16px' : '24px';
            respawnBtn.style.padding = window.innerWidth <= 768 ? '10px 20px' : '15px 30px';
            respawnBtn.style.backgroundColor = '#4CAF50';
            respawnBtn.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.8)';
            respawnBtn.style.animation = 'pulse 1.5s infinite';
            
            respawnBtn.addEventListener('click', () => {
                console.log('重生按钮被点击，发送respawn事件');
                socket.emit('respawn');
                hideRespawnOption();
            });
            
            container.appendChild(respawnBtn);
        }
        // 其他模式
        else {
            // 非经典模式，显示普通的死亡信息
            const deathMessage = document.createElement('div');
            deathMessage.id = 'death-message';
            deathMessage.textContent = '你已死亡!';
            deathMessage.style.position = 'absolute';
            deathMessage.style.top = '40%';
            deathMessage.style.left = '50%';
            deathMessage.style.transform = 'translate(-50%, -50%)';
            deathMessage.style.color = '#FF5252';
            deathMessage.style.fontSize = '28px';
            deathMessage.style.fontWeight = 'bold';
            deathMessage.style.textShadow = '0 0 10px rgba(255, 0, 0, 0.5)';
            deathMessage.style.zIndex = '999';
            deathMessage.style.textAlign = 'center';
            deathMessage.style.padding = '15px 30px';
            deathMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            deathMessage.style.borderRadius = '10px';
            document.getElementById('game-container').appendChild(deathMessage);
            
            // 如果允许重生，显示重生按钮
            if (multiplayerGameState && multiplayerGameState.allowRespawn) {
                const respawnBtn = document.createElement('button');
                respawnBtn.id = 'respawn-btn';
                respawnBtn.className = 'btn';
                respawnBtn.textContent = '重生';
                
                respawnBtn.style.position = 'absolute';
                respawnBtn.style.top = 'calc(40% + 80px)';
                respawnBtn.style.left = '50%';
                respawnBtn.style.transform = 'translateX(-50%)';
                respawnBtn.style.zIndex = '999';
                
                respawnBtn.addEventListener('click', () => {
                    console.log('重生按钮被点击，发送respawn事件');
                    socket.emit('respawn');
                    hideRespawnOption();
                });
                
                container.appendChild(respawnBtn);
            }
        }
    }
    
    addChatMessage(message, 'system');
    updateScoreBoard(); // 更新分数板显示
});


        
        // playerRespawned 事件监听
socket.on('playerRespawned', (data) => {
    console.log('收到playerRespawned事件:', data);
    
    // 如果是当前玩家复活
    if (data.playerId === playerId) {
        // 隐藏复活倒计时UI
        hideRespawnOption();
        
        // 提供更明显的视觉反馈
        const container = document.getElementById('game-container');
        const respawnEffect = document.createElement('div');
        respawnEffect.style.position = 'absolute';
        respawnEffect.style.top = '0';
        respawnEffect.style.left = '0';
        respawnEffect.style.width = '100%';
        respawnEffect.style.height = '100%';
        respawnEffect.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
        respawnEffect.style.zIndex = '50';
        respawnEffect.style.pointerEvents = 'none';
        container.appendChild(respawnEffect);
        
        // 淡出效果
        setTimeout(() => {
            let opacity = 0.2;
            const fadeInterval = setInterval(() => {
                opacity -= 0.01;
                respawnEffect.style.backgroundColor = `rgba(0, 255, 0, ${opacity})`;
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    respawnEffect.remove();
                }
            }, 20);
        }, 500);
    }
    
    // 构建复活消息，添加生命值信息
    let message = `${data.playerName} 已复活`;
    
    // 如果是经典模式且有生命值信息，显示剩余生命
    if (data.gameMode === 'classic' && typeof data.livesLeft === 'number') {
        message += ` [剩余生命: ${data.livesLeft}]`;
    }
    
    // 添加系统消息
    addChatMessage(message, 'system');
    
    // 更新分数板显示
    updateScoreBoard();
});

        
        // 游戏结束
        socket.on('gameEnd', (data) => {
            endMultiplayerGame(data);
        });
        
        // 设置更新
        socket.on('settingsUpdated', (settings) => {
            // 更新游戏设置UI
            addChatMessage('游戏设置已更新', 'system');
        });
        
        // 聊天消息
        socket.on('newMessage', (data) => {
            addChatMessage(`${data.playerName}: ${data.message}`, 'chat', data.playerId);
        });
        
        // 网格大小变更
        socket.on('gridSizeChanged', (newGridSize) => {
            console.log('网格大小已更改为:', newGridSize);
            settings.gridSize = newGridSize;
            
            // 立即重新调整画布大小以适应新的网格
            resizeCanvas();
            
            // 清除现有游戏元素，避免位置错乱
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 如果正在多人游戏中，强制重新渲染
            if (isMultiplayerGame && gameState.isPlaying) {
                requestAnimationFrame(multiplayerGameLoop);
            }
            
            addChatMessage(`游戏网格大小已更改为 ${newGridSize}x${newGridSize}`, 'system');
        });
        
        socket.on('gameCreated', (gameId) => {
            // 确保先清理之前的游戏状态
            if (isMultiplayerGame) {
                resetMultiplayerGameState();
            }
            
            multiplayerGameId = gameId;
            isHost = true;
            document.getElementById('multiplayer-menu').style.display = 'none';
            document.getElementById('lobby-game-id').textContent = gameId;
            document.getElementById('game-lobby').style.display = 'flex';
            updateSettingsVisibility();
            setTimeout(setupLobbyEvents, 100);
        });
        
        // 在Socket.io事件监听部分添加传送门相关事件
socket.on('portalsSpawned', (data) => {
    console.log('传送门已生成:', data);
    if (!multiplayerGameState) return;
    
    multiplayerGameState.portals = data.portals;
    multiplayerGameState.portalExpireTime = data.expireTime;
    
    // 显示传送门生成提示
    addChatMessage('传送门已出现！可以在两处位置之间快速移动', 'system');
});

socket.on('portalsExpired', () => {
    console.log('传送门已消失');
    if (!multiplayerGameState) return;
    
    multiplayerGameState.portals = [];
    
    // 显示传送门消失提示
    addChatMessage('传送门已消失', 'system');
});

socket.on('playerTeleported', (data) => {
    console.log('玩家传送:', data);
    
    // 播放传送音效
    if (settings.soundEnabled) {
        sounds.teleport.currentTime = 0;
        sounds.teleport.play();
    }
    
    // 创建传送特效
    const teleportEffect = document.createElement('div');
    teleportEffect.className = 'teleport-effect';
    document.getElementById('game-container').appendChild(teleportEffect);
    
    // 触发动画
    setTimeout(() => {
        teleportEffect.classList.add('active');
    }, 10);
    
    // 移除特效
    setTimeout(() => {
        teleportEffect.remove();
    }, 600);
    
    // 显示传送提示
    if (data.playerId === playerId) {
        addChatMessage('你通过传送门移动了！', 'system');
    } else {
        addChatMessage(`${data.playerName} 通过传送门移动！`, 'system');
    }
});

        
        socket.on('gameJoined', (gameId) => {
            // 确保先清理之前的游戏状态
            if (isMultiplayerGame) {
                resetMultiplayerGameState();
            }
            
            multiplayerGameId = gameId;
            isHost = false;
            document.getElementById('join-game-menu').style.display = 'none';
            document.getElementById('lobby-game-id').textContent = gameId;
            document.getElementById('game-lobby').style.display = 'flex';
            updateSettingsVisibility();
            setTimeout(setupLobbyEvents, 100);
        });
    } catch (error) {
        console.error('初始化Socket.io失败:', error);
        alert('无法初始化多人游戏功能，请刷新页面重试');
        // 确保返回按钮仍然可用
        ensureBackButtonWorks();
    }
    
    // 无论是否连接成功，都确保返回按钮正常工作
    ensureBackButtonWorks();
}



// 游戏记录对象
const gameRecords = {
    firstLaunch: true,         // 是否首次启动
    launchCount: 0,            // 启动次数
    totalPlayTime: 0,          // 总游戏时间(秒)
    playerName: '',            // 多人游戏玩家名称
    highScores: {              // 各模式最高分
        classic: 0,
        challenge: 0
    },
    lastPlayedMode: '',        // 上次玩的模式
    lastPlayedDate: null,      // 上次游戏日期
    multiplayerGamesPlayed: 0, // 多人游戏次数
    singleplayerGamesPlayed: 0 // 单人游戏次数
};

// 初始化游戏记录
function initGameRecords() {
    const savedRecords = localStorage.getItem('snakeGameRecords');
    if (savedRecords) {
        // 已有记录，加载它
        const parsed = JSON.parse(savedRecords);
        Object.assign(gameRecords, parsed);
        gameRecords.firstLaunch = false;
    } else {
        // 第一次启动游戏，显示欢迎信息
        showWelcomeMessage();
    }
    
    // 更新启动次数
    gameRecords.launchCount++;
    gameRecords.lastPlayedDate = new Date().toISOString();
    
    // 保存更新后的记录
    saveGameRecords();
    
    console.log('游戏记录已初始化:', gameRecords);
}

// 保存游戏记录
function saveGameRecords() {
    localStorage.setItem('snakeGameRecords', JSON.stringify(gameRecords));
}

// 显示欢迎信息
function showWelcomeMessage() {
    const welcomeOverlay = document.createElement('div');
    welcomeOverlay.className = 'overlay';
    welcomeOverlay.style.zIndex = '30';
    
    const welcomeDialog = document.createElement('div');
    welcomeDialog.className = 'dialog';
    welcomeDialog.innerHTML = `
        <h2>欢迎来到终极贪吃蛇！</h2>
        <p>这是您第一次启动游戏。以下是一些游戏特点：</p>
        <ul style="text-align: left; margin: 15px 0; padding-left: 20px;">
            <li>多种游戏模式：经典模式和夺冠模式</li>
            <li>五种特殊食物，各具不同能力</li>
            <li>多人游戏模式，与朋友一起竞技</li>
            <li>可自定义控制方式和游戏参数</li>
        </ul>
        <p>您的游戏进度和设置将自动保存。</p>
        <button id="welcome-btn" class="btn">开始游戏</button>
    `;
    
    welcomeOverlay.appendChild(welcomeDialog);
    document.body.appendChild(welcomeOverlay);
    
    document.getElementById('welcome-btn').addEventListener('click', () => {
        welcomeOverlay.remove();
    });
}

// 更新游戏记录
function updateGameRecord(type, data) {
    switch(type) {
        case 'score':
            // 更新最高分
            if (data.score > gameRecords.highScores[data.mode]) {
                gameRecords.highScores[data.mode] = data.score;
            }
            break;
        case 'mode':
            // 更新上次游戏模式
            gameRecords.lastPlayedMode = data.mode;
            break;
        case 'multiplayer':
            // 更新多人游戏数据
            gameRecords.multiplayerGamesPlayed++;
            if (data.playerName) {
                gameRecords.playerName = data.playerName;
            }
            break;
        case 'singleplayer':
            // 更新单人游戏数据
            gameRecords.singleplayerGamesPlayed++;
            break;
        case 'playtime':
            // 更新游戏时间
            gameRecords.totalPlayTime += data.time;
            break;
    }
    
    // 保存更新后的记录
    saveGameRecords();
}


// 确保返回按钮正常工作的辅助函数
function ensureBackButtonWorks() {
    const multiplayerBackBtn = document.getElementById('multiplayer-back-btn');
    if (multiplayerBackBtn) {
        // 移除所有现有事件监听器并重新绑定
        const newBackBtn = multiplayerBackBtn.cloneNode(true);
        if (multiplayerBackBtn.parentNode) {
            multiplayerBackBtn.parentNode.replaceChild(newBackBtn, multiplayerBackBtn);
        }
        
        // 添加返回主菜单的事件
        newBackBtn.addEventListener('click', () => {
            console.log('点击返回按钮');
            document.getElementById('multiplayer-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            
            // 如果连接失败，尝试清理socket状态
            if (socket && socket.disconnected) {
                try {
                    socket.removeAllListeners();
                    socket.disconnect();
                } catch (e) {
                    console.error('清理Socket失败:', e);
                }
            }
        });
        
        // 添加触摸事件，确保在移动设备上也能工作
        newBackBtn.addEventListener('touchend', function(e) {
            e.preventDefault();
            console.log('触摸点击多人游戏返回按钮');
            document.getElementById('multiplayer-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        });
        
        console.log('多人游戏返回按钮事件已重新绑定');
    } else {
        console.error('找不到多人游戏返回按钮');
    }
}


function startMultiplayerGame(gameData) {
    console.log('开始多人游戏，游戏数据:', gameData);
    
    // 重置之前的游戏状态
    resetMultiplayerGameState();
    
    // 设置游戏为多人模式
    isMultiplayerGame = true;
    
    // 应用服务器发送的游戏设置
    if (gameData.gameSettings) {
        settings.gridSize = gameData.gameSettings.gridSize || settings.gridSize;
        console.log('应用网格大小设置:', settings.gridSize);
        
        // 如果速度设置被改变
        if (gameData.gameSettings.gameSpeed) {
            settings.baseSpeed = gameData.gameSettings.gameSpeed;
        }
    }
    
    // 重新调整画布大小以适应新的网格
    resizeCanvas();
    
    // 隐藏单人游戏UI
    document.getElementById('score-container').style.display = 'none'; // 隐藏分数显示
    document.getElementById('status-display').style.display = 'none'; // 隐藏状态显示

    const deathMessage = document.getElementById('death-message');
    if (deathMessage && deathMessage.parentNode) {
        deathMessage.remove();
    }

    // 移除所有可能存在的复活按钮和倒计时
    hideRespawnOption();

    // 初始化多人游戏UI元素
    const multiplayerStatus = document.getElementById('multiplayer-status');
    const chatBox = document.getElementById('multiplayer-chat');
    const gameContainer = document.getElementById('game-container');
    const scoreBoard = document.querySelector('.player-scores');
    
    // 设置UI显示
    multiplayerStatus.style.display = 'block';
    chatBox.style.display = 'flex'; // 使用flex布局更好控制内部元素
    
    // 确保分数板默认显示 - 这是关键修改
    scoreBoard.classList.add('show');
    
    // 创建多人游戏控制按钮容器（如果不存在）
    let multiplayerControls = document.getElementById('multiplayer-controls');
    if (!multiplayerControls) {
        multiplayerControls = document.createElement('div');
        multiplayerControls.id = 'multiplayer-controls';
        multiplayerControls.style.position = 'fixed';
        multiplayerControls.style.bottom = '20px';
        multiplayerControls.style.right = '20px';
        multiplayerControls.style.display = 'flex';
        multiplayerControls.style.flexDirection = 'row';
        multiplayerControls.style.gap = '10px';
        multiplayerControls.style.zIndex = '101';
        document.body.appendChild(multiplayerControls);
    } else {
        // 清空已有的按钮
        multiplayerControls.innerHTML = '';
    }
    
    // 添加分数切换按钮
    const toggleScoresBtn = document.createElement('button');
    toggleScoresBtn.className = 'toggle-scores-btn';
    toggleScoresBtn.textContent = '🏆';
    toggleScoresBtn.style.fontSize = '24px';
    toggleScoresBtn.style.padding = '8px 12px';
    toggleScoresBtn.style.borderRadius = '50%';
    toggleScoresBtn.style.width = '40px';
    toggleScoresBtn.style.height = '40px';
    toggleScoresBtn.style.display = 'flex';
    toggleScoresBtn.style.alignItems = 'center';
    toggleScoresBtn.style.justifyContent = 'center';
    toggleScoresBtn.style.background = 'rgba(0, 0, 0, 0.6)';
    toggleScoresBtn.style.color = 'white';
    toggleScoresBtn.style.border = '2px solid rgba(255, 255, 255, 0.3)';
    toggleScoresBtn.style.cursor = 'pointer';
    toggleScoresBtn.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.3)';
    toggleScoresBtn.style.transition = 'all 0.2s ease';
    
    toggleScoresBtn.addEventListener('click', () => {
        document.querySelector('.player-scores').classList.toggle('show');
    });
    
    // 添加聊天切换按钮
    const toggleChatBtn = document.createElement('button');
    toggleChatBtn.className = 'toggle-chat-btn';
    toggleChatBtn.textContent = '💬';
    toggleChatBtn.style.fontSize = '24px';
    toggleChatBtn.style.padding = '8px 12px';
    toggleChatBtn.style.borderRadius = '50%';
    toggleChatBtn.style.width = '40px';
    toggleChatBtn.style.height = '40px';
    toggleChatBtn.style.display = 'flex';
    toggleChatBtn.style.alignItems = 'center';
    toggleChatBtn.style.justifyContent = 'center';
    toggleChatBtn.style.background = 'rgba(0, 0, 0, 0.6)';
    toggleChatBtn.style.color = 'white';
    toggleChatBtn.style.border = '2px solid rgba(255, 255, 255, 0.3)';
    toggleChatBtn.style.cursor = 'pointer';
    toggleChatBtn.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.3)';
    toggleChatBtn.style.transition = 'all 0.2s ease';
    
    toggleChatBtn.addEventListener('click', () => {
        document.getElementById('multiplayer-chat').classList.toggle('show');
    });
    
    // 将按钮添加到容器
    multiplayerControls.appendChild(toggleScoresBtn);
    multiplayerControls.appendChild(toggleChatBtn);
    
    // 显示控制按钮
    multiplayerControls.style.display = 'flex';
    
    // 添加聊天拖动手柄
    if (!chatBox.querySelector('.chat-handle')) {
        const chatHandle = document.createElement('div');
        chatHandle.className = 'chat-handle';
        chatBox.prepend(chatHandle);
    }
    
    // 配置触摸事件处理聊天面板滑动
    setupChatSwipeInteraction();
    
    // 设置游戏模式和选项
    gameState.gameMode = gameData.gameMode || 'classic';
    
    // 创建游戏模式显示
    const modeDisplay = document.createElement('div');
    modeDisplay.id = 'multiplayer-mode-display';
    modeDisplay.style.position = 'absolute';
    modeDisplay.style.top = '10px';
    modeDisplay.style.left = '50%';
    modeDisplay.style.transform = 'translateX(-50%)';
    modeDisplay.style.background = 'rgba(0, 0, 0, 0.6)';
    modeDisplay.style.padding = '8px 12px';
    modeDisplay.style.borderRadius = '20px';
    modeDisplay.style.fontSize = '16px';
    modeDisplay.style.zIndex = '10';
    
    // 根据游戏模式设置不同的显示文本
    if (gameData.gameMode === 'classic') {
        modeDisplay.textContent = `模式: 经典 (三条命)`;
    } else if (gameData.gameMode === 'challenge') {
        modeDisplay.textContent = `模式: 夺冠 (目标500分)`;
        console.log('设置为夺冠模式显示');
    } else {
        modeDisplay.textContent = `模式: ${getModeText(gameData.gameMode)}`;
    }

    gameContainer.appendChild(modeDisplay);
    
    // 记录游戏选项
    const allowRespawn = gameData.allowRespawn !== undefined ? gameData.allowRespawn : true;
    console.log('游戏是否允许重生:', allowRespawn);
    
    // 重置本地游戏状态
    gameState.isPlaying = true;
    gameState.isPaused = false;
    gameState.isGameOver = false;
    gameState.score = 0;
    
    // 显示玩家分数板
    updateScoreBoard();
    
    // 隐藏所有菜单
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('game-lobby').style.display = 'none';
    document.getElementById('game-over').style.display = 'none';
    
    // 移除3D效果
    canvas.classList.remove('rotate-effect');
    
    // 确保食物信息和能力提示不会遮挡游戏区域
    const foodInfo = document.getElementById('food-info');
    const powerUpIndicator = document.getElementById('power-up-indicator');
    
    if (foodInfo) {
        foodInfo.style.top = 'calc(100% + 10px)';
        foodInfo.style.bottom = 'auto';
    }
    
    if (powerUpIndicator) {
        powerUpIndicator.style.top = 'calc(100% + 10px)';
        powerUpIndicator.style.bottom = 'auto';
        powerUpIndicator.style.right = '10px';
    }
    
    // 添加游戏区域边界线，帮助玩家识别游戏边界
    const borderStyle = document.createElement('style');
    borderStyle.textContent = `
        #game-canvas {
            border: 2px solid rgba(0, 255, 150, 0.5);
            box-sizing: border-box;
        }
    `;
    document.head.appendChild(borderStyle);
    
    // 开始游戏循环(只负责渲染，逻辑由服务器处理)
    if (gameState.animationFrame) {
        cancelAnimationFrame(gameState.animationFrame);
    }
    gameState.lastFrameTime = 0;
    gameState.animationFrame = requestAnimationFrame(multiplayerGameLoop);
    
    console.log('多人游戏UI已调整，防止遮挡游戏区域');
}



function setupChatSwipeInteraction() {
    const chatBox = document.getElementById('multiplayer-chat');
    const chatHandle = chatBox.querySelector('.chat-handle');
    
    if (!chatHandle) return;
    
    let startY = 0;
    let currentY = 0;
    
    // 处理触摸开始
    chatHandle.addEventListener('touchstart', function(e) {
        startY = e.touches[0].clientY;
        chatBox.style.transition = 'none';
    });
    
    // 处理触摸移动
    chatHandle.addEventListener('touchmove', function(e) {
        currentY = e.touches[0].clientY;
        const deltaY = currentY - startY;
        
        // 下拉时显示，上推时隐藏
        if (deltaY < 0) {
            // 向上滑动，显示聊天
            chatBox.classList.add('show');
        } else if (deltaY > 50) {
            // 向下滑动超过阈值，隐藏聊天
            chatBox.classList.remove('show');
        }
    });
    
    // 处理触摸结束
    chatHandle.addEventListener('touchend', function() {
        chatBox.style.transition = 'transform 0.3s ease';
    });
}


// 多人游戏循环
function multiplayerGameLoop(timestamp) {
    // 如果游戏状态已经不是多人游戏，停止循环
    if (!isMultiplayerGame || !gameState.isPlaying) {
        console.log('多人游戏已停止，结束渲染循环');
        return;
    }
    
    if (!gameState.lastFrameTime) gameState.lastFrameTime = timestamp;
    
    const deltaTime = timestamp - gameState.lastFrameTime;
    
    if (!gameState.isPaused) {
        // 清空画布
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 绘制背景网格
        if (settings.gridEnabled) {
            drawGrid();
        }
        
        // 验证多人游戏状态是否存在
        if (!multiplayerGameState) {
            console.log('警告: 多人游戏状态缺失');
            requestAnimationFrame(multiplayerGameLoop);
            return;
        }
        
        // 检查cellSize是否有效
        if (!cellSize || cellSize <= 0) {
            console.error('警告: multiplayerGameLoop中cellSize无效:', cellSize);
            resizeCanvas();
        }
        
        // 绘制从服务器接收的游戏状态
        drawMultiplayerGame();
    }
    
    gameState.lastFrameTime = timestamp;
    
    // 如果游戏仍在进行中，继续动画循环
    if (isMultiplayerGame && gameState.isPlaying) {
        gameState.animationFrame = requestAnimationFrame(multiplayerGameLoop);
    }
}



// 更新多人游戏状态
// 确保updateMultiplayerGameState函数正确保存传送门数据
function updateMultiplayerGameState(newState) {
    // 更新本地游戏状态
    multiplayerGameState = newState;
    
    // 确保游戏模式也更新
    if (newState && newState.gameMode) {
        gameState.gameMode = newState.gameMode;
        
        // 更新模式显示
        const modeDisplay = document.getElementById('multiplayer-mode-display');
        if (modeDisplay) {
            if (newState.gameMode === 'classic') {
                modeDisplay.textContent = `模式: 经典 (三条命)`;
            } else if (newState.gameMode === 'challenge') {
                modeDisplay.textContent = `模式: 夺冠 (目标500分)`;
            } else {
                modeDisplay.textContent = `模式: ${getModeText(newState.gameMode)}`;
            }
        }
    }
    
    // 确保网格大小正确
    if (newState && newState.gridSize && newState.gridSize !== settings.gridSize) {
        console.log('从服务器更新网格大小:', newState.gridSize);
        settings.gridSize = newState.gridSize;
        resizeCanvas();
    }
    
    // 保存传送门信息
    if (newState && newState.portals) {
        multiplayerGameState.portals = newState.portals;
        multiplayerGameState.portalExpireTime = newState.portalExpireTime;
    }
    
    // 检查cellSize是否有效
    if (!cellSize || cellSize <= 0) {
        console.error('警告: updateMultiplayerGameState后cellSize无效:', cellSize);
        resizeCanvas();
    }
    
    // 更新玩家分数
    updateScoreBoard();
    
    // 添加调试日志
    if (newState) {
        console.log('收到多人游戏状态更新:', 
                  '网格大小:', newState.gridSize,
                  '障碍物:', (newState.obstacles || []).length,
                  '食物:', (newState.foods || []).length, 
                  '玩家:', (newState.players || []).length,
                  '游戏模式:', newState.gameMode,
                  '传送门:', (newState.portals || []).length);
    } else {
        console.warn('收到空的游戏状态更新');
    }
}




// 绘制多人游戏
// 修改drawMultiplayerGame函数添加传送门绘制 - 完整函数
function drawMultiplayerGame() {
    if (!multiplayerGameState) {
        console.log('无多人游戏状态可绘制');
        return;
    }
    
    // 检查cellSize是否已正确初始化
    if (!cellSize || cellSize <= 0) {
        console.error('错误: cellSize未正确初始化:', cellSize);
        // 尝试重新计算
        resizeCanvas();
        return;
    }
    
    console.log('绘制多人游戏状态，使用cellSize:', cellSize,
                '障碍物:', (multiplayerGameState.obstacles || []).length,
                '食物:', (multiplayerGameState.foods || []).length, 
                '玩家:', (multiplayerGameState.players || []).length);
    
    // 确保网格尺寸与服务器匹配
    if (multiplayerGameState.gridSize && multiplayerGameState.gridSize !== settings.gridSize) {
        settings.gridSize = multiplayerGameState.gridSize;
        console.log('更新网格尺寸为:', settings.gridSize);
        resizeCanvas();
    }
    
    // 绘制障碍物
    if (multiplayerGameState.obstacles && Array.isArray(multiplayerGameState.obstacles)) {
        multiplayerGameState.obstacles.forEach(obstacle => {
            if (obstacle && typeof obstacle.x === 'number' && typeof obstacle.y === 'number') {
                drawMultiplayerObstacle(obstacle);
            } else {
                console.warn('跳过无效的障碍物:', obstacle);
            }
        });
    }
    
    // 绘制传送门 - 新增传送门绘制
    if (multiplayerGameState.portals && Array.isArray(multiplayerGameState.portals)) {
        drawPortals();
    }
    
    // 绘制食物
    if (multiplayerGameState.foods && Array.isArray(multiplayerGameState.foods)) {
        multiplayerGameState.foods.forEach(food => {
            if (food && typeof food.x === 'number' && typeof food.y === 'number') {
                drawMultiplayerFood(food);
            } else {
                console.warn('跳过无效的食物:', food);
            }
        });
    } else if (multiplayerGameState.food && Array.isArray(multiplayerGameState.food)) {
        // 尝试替代字段名
        multiplayerGameState.food.forEach(food => {
            if (food && typeof food.x === 'number' && typeof food.y === 'number') {
                drawMultiplayerFood(food);
            } else {
                console.warn('跳过无效的食物:', food);
            }
        });
    }
    
    // 绘制所有玩家的蛇
    if (multiplayerGameState.players && Array.isArray(multiplayerGameState.players)) {
        multiplayerGameState.players.forEach(player => {
            if (!player.isAlive) return;
            if (player.snake && player.snake.segments && player.snake.segments.length > 0) {
                drawMultiplayerSnake(player);
            } else {
                console.warn('跳过无效的玩家蛇:', player.id);
            }
        });
    }
}


// 绘制多人游戏中的障碍物
function drawMultiplayerObstacle(obstacle) {
    if (!obstacle || typeof obstacle.x !== 'number' || typeof obstacle.y !== 'number') {
        console.log('无效的障碍物数据:', obstacle);
        return;
    }
    
    // 检查cellSize是否有效
    if (!cellSize || cellSize <= 0) {
        console.error('cellSize无效:', cellSize);
        return;
    }
    
    const padding = cellSize * 0.1;
    const x = obstacle.x * cellSize + padding;
    const y = obstacle.y * cellSize + padding;
    const size = cellSize - padding * 2;
    
    // 添加发光效果
    ctx.shadowColor = '#ff0066';
    ctx.shadowBlur = 10;
    
    // 绘制障碍物主体
    ctx.fillStyle = '#ad1457';
    ctx.fillRect(x, y, size, size);
    
    // 绘制障碍物图案 (警告标志)
    ctx.fillStyle = '#ffeb3b';
    ctx.beginPath();
    
    // 三角形警告标志
    ctx.moveTo(x + size/2, y + size/4);
    ctx.lineTo(x + size/4, y + size*3/4);
    ctx.lineTo(x + size*3/4, y + size*3/4);
    ctx.closePath();
    ctx.fill();
    
    // 内部感叹号
    ctx.fillStyle = '#ad1457';
    ctx.fillRect(x + size/2 - size/10, y + size/2 - size/10, size/5, size/5);
    ctx.fillRect(x + size/2 - size/10, y + size*2/3 - size/10, size/5, size/5);
    
    // 重置阴影
    ctx.shadowBlur = 0;
}

// 绘制多人游戏中的食物
function drawMultiplayerFood(food) {
    if (!food || typeof food.x !== 'number' || typeof food.y !== 'number') {
        console.log('无效的食物数据:', food);
        return;
    }
    
    // 检查cellSize是否有效
    if (!cellSize || cellSize <= 0) {
        console.error('cellSize无效:', cellSize);
        return;
    }
    
    const foodTypes = {
        'red': { color: '#ff3333', borderColor: '#cc0000' },
        'yellow': { color: '#ffcc00', borderColor: '#cc9900' },
        'green': { color: '#33cc33', borderColor: '#009900' },
        'blue': { color: '#3399ff', borderColor: '#0066cc' },
        'purple': { color: '#9933ff', borderColor: '#6600cc' }
    };
    
    const foodInfo = foodTypes[food.type] || foodTypes.red;
    
    // 计算脉动效果
    const pulsePhase = (Date.now() / 200) % (Math.PI * 2);
    const scale = 1 + Math.sin(pulsePhase) * 0.1;
    const centerX = (food.x + 0.5) * cellSize;
    const centerY = (food.y + 0.5) * cellSize;
    const radius = cellSize * 0.4 * scale;
    
    // 绘制食物
    ctx.save();
    
    // 闪光效果
    ctx.shadowColor = foodInfo.color;
    ctx.shadowBlur = 10;
    
    // 主体
    ctx.fillStyle = foodInfo.color;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
    
    // 边框
    ctx.strokeStyle = foodInfo.borderColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // 内部装饰
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.beginPath();
    ctx.arc(centerX - radius * 0.3, centerY - radius * 0.3, radius * 0.2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
}


// 绘制多人游戏中的蛇
function drawMultiplayerSnake(player) {
    if (!player.snake || !player.snake.segments || !Array.isArray(player.snake.segments)) {
        console.log('无效的蛇数据:', player);
        return;
    }
    
    // 检查cellSize是否有效
    if (!cellSize || cellSize <= 0) {
        console.error('cellSize无效:', cellSize);
        return;
    }
    
    const isCurrentPlayer = player.id === playerId;
    
    // 绘制蛇身体
    player.snake.segments.forEach((segment, index) => {
        if (!segment || typeof segment.x !== 'number' || typeof segment.y !== 'number') {
            return; // 跳过无效的段
        }
        
        const isHead = index === 0;
        
        // 计算颜色
        let color;
        if (isHead) {
            color = player.powerUpActive ? 
                (player.powerUpType === 'phase' ? '#00E5FF' : '#E040FB') : 
                player.color || '#00E676';
        } else {
            // 身体颜色渐变
            const baseHue = hexToHsl(player.color || '#00E676')[0];
            const hue = player.powerUpActive ? 
                (player.powerUpType === 'phase' ? 180 : 280) : 
                baseHue - (index / player.snake.segments.length * 40);
            const saturation = 80 - (index / player.snake.segments.length * 30);
            const lightness = 60 - (index / player.snake.segments.length * 20);
            color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        
        // 绘制身体段
        const x = segment.x * cellSize;
        const y = segment.y * cellSize;
        const radius = isHead ? cellSize * 0.45 : cellSize * 0.35;
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(
            x + cellSize / 2,
            y + cellSize / 2,
            radius,
            0,
            Math.PI * 2
        );
        ctx.fill();
        
        // 如果是头部，添加眼睛
        if (isHead) {
            drawMultiplayerSnakeEyes(segment, player.snake.direction || 'right');
        }
    });
    
    // 为当前玩家添加名称标签
    if (player.snake.segments.length > 0 && player.name) {
        const head = player.snake.segments[0];
        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(
            player.name,
            (head.x + 0.5) * cellSize,
            head.y * cellSize - 5
        );
    }
}

// 绘制多人游戏中的蛇眼睛
function drawMultiplayerSnakeEyes(head, direction) {
    const eyeSize = cellSize * 0.15;
    const eyeDistance = cellSize * 0.18;
    
    // 根据方向调整眼睛位置
    let leftEyePos, rightEyePos;
    const centerX = (head.x + 0.5) * cellSize;
    const centerY = (head.y + 0.5) * cellSize;
    
    switch (direction) {
        case 'up':
            leftEyePos = {x: centerX - eyeDistance, y: centerY - eyeDistance};
            rightEyePos = {x: centerX + eyeDistance, y: centerY - eyeDistance};
            break;
        case 'down':
            leftEyePos = {x: centerX - eyeDistance, y: centerY + eyeDistance};
            rightEyePos = {x: centerX + eyeDistance, y: centerY + eyeDistance};
            break;
        case 'left':
            leftEyePos = {x: centerX - eyeDistance, y: centerY - eyeDistance};
            rightEyePos = {x: centerX - eyeDistance, y: centerY + eyeDistance};
            break;
        case 'right':
            leftEyePos = {x: centerX + eyeDistance, y: centerY - eyeDistance};
            rightEyePos = {x: centerX + eyeDistance, y: centerY + eyeDistance};
            break;
        default:
            leftEyePos = {x: centerX - eyeDistance, y: centerY - eyeDistance};
            rightEyePos = {x: centerX + eyeDistance, y: centerY - eyeDistance};
    }
    
    // 绘制眼睛
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(leftEyePos.x, leftEyePos.y, eyeSize, 0, Math.PI * 2);
    ctx.arc(rightEyePos.x, rightEyePos.y, eyeSize, 0, Math.PI * 2);
    ctx.fill();
    
    // 绘制瞳孔
    const pupilOffset = eyeSize * 0.4;
    const pupilSize = eyeSize * 0.6;
    
    // 计算瞳孔位置偏移(根据方向)
    let pupilOffsetX = 0, pupilOffsetY = 0;
    switch (direction) {
        case 'up': pupilOffsetY = -pupilOffset; break;
        case 'down': pupilOffsetY = pupilOffset; break;
        case 'left': pupilOffsetX = -pupilOffset; break;
        case 'right': pupilOffsetX = pupilOffset; break;
    }
    
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(
        leftEyePos.x + pupilOffsetX, 
        leftEyePos.y + pupilOffsetY, 
        pupilSize, 
        0, 
        Math.PI * 2
    );
    ctx.arc(
        rightEyePos.x + pupilOffsetX, 
        rightEyePos.y + pupilOffsetY, 
        pupilSize, 
        0, 
        Math.PI * 2
    );
    ctx.fill();
}



// 更新玩家列表
function updatePlayerList() {
    const playerList = document.getElementById('player-list');
    playerList.innerHTML = '';
    
    connectedPlayers.forEach(player => {
        const li = document.createElement('li');
        
        // 标记当前玩家
        if (player.id === playerId) {
            li.classList.add('current-player');
        }
        
        // 创建玩家名称元素
        const nameSpan = document.createElement('span');
        nameSpan.textContent = player.name;
        li.appendChild(nameSpan);
        
        // 添加主机标记
        if (player.isHost) {
            const hostIcon = document.createElement('span');
            hostIcon.className = 'host-indicator';
            hostIcon.textContent = ' 👑 房主';
            li.appendChild(hostIcon);
        }
        
        playerList.appendChild(li);
        
        // 只有房主可以看到开始游戏按钮
        document.getElementById('start-game-btn').style.display = 
            (playerId === connectedPlayers.find(p => p.isHost)?.id) ? 'block' : 'none';
    });
    
    // 检查并更新当前玩家是否是房主
    isHost = connectedPlayers.some(p => p.id === playerId && p.isHost);
    
    // 更新设置面板可见性
    updateSettingsVisibility();
}


// 更新分数板
function updateScoreBoard() {
    if (!multiplayerGameState || !multiplayerGameState.players) return;
    
    const scoreBoard = document.querySelector('.player-scores');
    scoreBoard.innerHTML = '';
    
    // 确保分数板有正确的类
    if (!scoreBoard.classList.contains('show')) {
        // 在移动设备上默认隐藏分数板
        scoreBoard.classList.remove('show');
    }
    
    // 获取当前游戏模式
    const gameMode = multiplayerGameState.gameMode || 'classic';
    
    // 按分数排序
    const sortedPlayers = [...multiplayerGameState.players].sort((a, b) => b.score - a.score);
    
    sortedPlayers.forEach(player => {
        const scoreDiv = document.createElement('div');
        scoreDiv.className = 'player-score';
        
        // 为当前玩家添加标记
        if (player.id === playerId) {
            scoreDiv.classList.add('current-player');
        }
        
        // 添加生存状态指示
        let statusMark = player.isAlive ? '🟢' : '🔴';
        if (player.isRespawning) {
            statusMark = '🟡'; // 黄色表示复活中
        }
        
        // 添加生命值显示（仅在经典模式下）
        let livesMark = '';
        if (gameMode === 'classic' && player.snake && typeof player.snake.lives === 'number') {
            livesMark = ` ❤️×${player.snake.lives}`;
        }
        
        // 添加能力道具指示
        let powerUpMark = '';
        if (player.powerUpActive) {
            powerUpMark = player.powerUpType === 'phase' ? ' 🚪' : ' 🛡️';
        }
        
        // 添加分数翻倍指示
        let multiplierMark = '';
        if (player.scoreMultiplierActive) {
            multiplierMark = ' 💰×2';
            scoreDiv.style.color = '#ffcc00'; // 使用黄色突出显示有翻倍效果的玩家
        }
        
        scoreDiv.innerHTML = `${statusMark} ${player.name}: ${player.score}${livesMark}${powerUpMark}${multiplierMark}`;
        
        // 设置颜色指示
        scoreDiv.style.borderLeft = `3px solid ${player.color || '#00E676'}`;
        
        scoreBoard.appendChild(scoreDiv);
    });
}


// 添加聊天消息
function addChatMessage(message, type, senderId = null) {
    const chatMessages = document.querySelector('.chat-messages');
    const messageDiv = document.createElement('div');
    
    if (type === 'system') {
    // 创建顶部通知
    const notification = document.createElement('div');
    notification.className = 'system-notification';
    notification.textContent = message;
    
    // 将通知添加到专门的通知容器中
    let notificationContainer = document.getElementById('notification-container');
    if (!notificationContainer) {
        // 如果容器不存在，创建一个
        notificationContainer = document.createElement('div');
        notificationContainer.id = 'notification-container';
        notificationContainer.style.position = 'fixed';
        notificationContainer.style.top = '10px';
        notificationContainer.style.left = '0';
        notificationContainer.style.right = '0';
        notificationContainer.style.display = 'flex';
        notificationContainer.style.flexDirection = 'column';
        notificationContainer.style.alignItems = 'center';
        notificationContainer.style.zIndex = '50';
        notificationContainer.style.pointerEvents = 'none'; // 确保不会阻止点击
        document.body.appendChild(notificationContainer);
    }
    
    // 设置通知样式
    notification.style.background = 'rgba(0, 0, 0, 0.7)';
    notification.style.color = 'white';
    notification.style.padding = '8px 15px';
    notification.style.borderRadius = '20px';
    notification.style.margin = '5px';
    notification.style.maxWidth = '80%';
    notification.style.textAlign = 'center';
    notification.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.3)';
    notification.style.transform = 'translateY(-20px)';
    notification.style.opacity = '0';
    notification.style.transition = 'transform 0.3s, opacity 0.3s';
    
    // 添加通知
    notificationContainer.appendChild(notification);
    
    // 触发动画效果
    setTimeout(() => {
        notification.style.transform = 'translateY(0)';
        notification.style.opacity = '1';
    }, 10);
    
    // 动画结束后自动移除通知
    setTimeout(() => {
        notification.style.transform = 'translateY(-20px)';
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.remove();
        }, 300);
    }, 2500);
    
    // 同时在聊天区域添加消息
    messageDiv.className = 'game-message system-message';
    messageDiv.textContent = message;
} else {
        messageDiv.className = 'game-message chat-message';
        
        // 如果是当前玩家的消息，添加样式
        if (senderId === playerId) {
            messageDiv.classList.add('my-message');
        }
        
        messageDiv.innerHTML = message;
    }
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}


// 显示复活倒计时
function showRespawnOption() {
    // 创建复活提示而不是按钮
    const container = document.getElementById('game-container');
    
    // 检查是否已存在复活提示
    if (document.getElementById('respawn-message')) return;
    
    const respawnMessage = document.createElement('div');
    respawnMessage.id = 'respawn-message';
    respawnMessage.className = 'respawn-message';
    respawnMessage.textContent = '复活倒计时: 3...';
    
    // 设置样式
    respawnMessage.style.position = 'absolute';
    respawnMessage.style.top = '50%';
    respawnMessage.style.left = '50%';
    respawnMessage.style.transform = 'translate(-50%, -50%)';
    respawnMessage.style.padding = '15px 30px';
    respawnMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    respawnMessage.style.color = '#4CAF50';
    respawnMessage.style.borderRadius = '10px';
    respawnMessage.style.fontSize = '24px';
    respawnMessage.style.fontWeight = 'bold';
    respawnMessage.style.zIndex = '999';
    respawnMessage.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.5)';
    respawnMessage.style.animation = 'pulse 1.5s infinite';
    respawnMessage.style.pointerEvents = 'none'; // 确保不会干扰点击事件
    
    container.appendChild(respawnMessage);
    
    // 创建倒计时动画
    let countdown = 3;
    const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            respawnMessage.textContent = `复活倒计时: ${countdown}...`;
        } else {
            respawnMessage.textContent = '正在复活...';
            clearInterval(countdownInterval);
            
            // 3秒后自动移除消息
            setTimeout(() => {
                hideRespawnOption();
            }, 500);
        }
    }, 1000);
    
    // 将倒计时间隔ID存储到元素上，以便后续清除
    respawnMessage.dataset.intervalId = countdownInterval;
}



// 隐藏复活倒计时
function hideRespawnOption() {
    const respawnMessage = document.getElementById('respawn-message');
    if (respawnMessage) {
        // 清除可能的倒计时计时器
        if (respawnMessage.dataset.intervalId) {
            clearInterval(parseInt(respawnMessage.dataset.intervalId));
        }
        
        // 添加淡出动画
        respawnMessage.style.opacity = '0';
        respawnMessage.style.transition = 'opacity 0.3s ease';
        
        // 动画结束后移除元素
        setTimeout(() => {
            if (respawnMessage.parentNode) {
                respawnMessage.remove();
            }
        }, 300);
    }
    
    // 移除死亡消息提示
    const deathMessage = document.getElementById('death-message');
    if (deathMessage) {
        deathMessage.style.opacity = '0';
        deathMessage.style.transition = 'opacity 0.3s ease';
        
        setTimeout(() => {
            if (deathMessage.parentNode) {
                deathMessage.remove();
            }
        }, 300);
    }
}



// 设置游戏大厅界面事件
function setupLobbyEvents() {
    console.log('设置游戏大厅界面事件');
    
    // 网格大小设置实时更新
    const gridSizeSetting = document.getElementById('grid-size-setting');
    const gridSizeValue = document.getElementById('grid-size-value');
    if (gridSizeSetting && gridSizeValue) {
        // 克隆并替换元素以清除现有事件监听器
        const newGridSizeSetting = gridSizeSetting.cloneNode(true);
        gridSizeSetting.parentNode.replaceChild(newGridSizeSetting, gridSizeSetting);
        
        newGridSizeSetting.addEventListener('input', () => {
            gridSizeValue.textContent = newGridSizeSetting.value;
        });
    }

    // 食物数量设置实时更新
    const foodCountSetting = document.getElementById('food-count-setting');
    const foodCountValue = document.getElementById('food-count-value');
    if (foodCountSetting && foodCountValue) {
        // 克隆并替换元素以清除现有事件监听器
        const newFoodCountSetting = foodCountSetting.cloneNode(true);
        foodCountSetting.parentNode.replaceChild(newFoodCountSetting, foodCountSetting);
        
        newFoodCountSetting.addEventListener('input', () => {
            foodCountValue.textContent = newFoodCountSetting.value;
        });
    }

    // 游戏速度设置
    const gameSpeedSetting = document.getElementById('game-speed-setting');
    if (gameSpeedSetting) {
        const newGameSpeedSetting = gameSpeedSetting.cloneNode(true);
        gameSpeedSetting.parentNode.replaceChild(newGameSpeedSetting, gameSpeedSetting);
    }

    // 障碍物密度设置
    const obstacleDensitySetting = document.getElementById('obstacle-density-setting');
    if (obstacleDensitySetting) {
        const newObstacleDensitySetting = obstacleDensitySetting.cloneNode(true);
        obstacleDensitySetting.parentNode.replaceChild(newObstacleDensitySetting, obstacleDensitySetting);
    }

    // 能力道具设置
    const powerUpsSetting = document.getElementById('power-ups-setting');
    if (powerUpsSetting) {
        const newPowerUpsSetting = powerUpsSetting.cloneNode(true);
        powerUpsSetting.parentNode.replaceChild(newPowerUpsSetting, powerUpsSetting);
    }

    // 游戏模式设置
    const gameModeSelect = document.getElementById('game-mode-setting');
    if (gameModeSelect) {
        const newGameModeSelect = gameModeSelect.cloneNode(true);
        gameModeSelect.parentNode.replaceChild(newGameModeSelect, gameModeSelect);
    }
    
    // 统一的方式处理所有模式信息按钮
    setupModeInfoButtons();
    
    // 设置大厅内设置面板切换事件
    setupLobbySettingsToggle();

    console.log('游戏大厅界面事件设置完成');
}


// 新增函数，统一处理所有模式信息按钮
function setupModeInfoButtons() {
    // 移除所有现有的模式信息按钮事件监听器
    const allModeInfoBtns = document.querySelectorAll('.mode-info-btn');
    
    allModeInfoBtns.forEach(btn => {
        // 克隆按钮以移除所有事件监听器
        const newBtn = btn.cloneNode(true);
        if (btn.parentNode) {
            btn.parentNode.replaceChild(newBtn, btn);
        }
        
        // 为新按钮添加点击事件
        newBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation(); // 阻止事件冒泡
            
            // 获取当前选择的游戏模式
            let selectedMode = 'classic';
            const settingSelect = this.closest('.setting-item')?.querySelector('select');
            if (settingSelect) {
                selectedMode = settingSelect.value;
            } else {
                // 尝试从其他地方获取模式
                const lobbyModeSelect = document.querySelector('#game-lobby #game-mode-setting');
                if (lobbyModeSelect) {
                    selectedMode = lobbyModeSelect.value;
                }
            }
            
            console.log('模式信息按钮被点击，显示模式:', selectedMode);
            showModeInfoDialog(selectedMode);
        });
    });
    
    console.log('所有模式信息按钮事件已重新绑定');
}


// 显示模式信息对话框函数
// 修改 showModeInfoDialog 函数，增加检查避免重复显示
function showModeInfoDialog(mode) {
    // 检查是否已经存在对话框，如果存在则先移除
    const existingOverlay = document.querySelector('.mode-info-overlay');
    const existingDialog = document.querySelector('.mode-info-dialog');
    if (existingOverlay) existingOverlay.remove();
    if (existingDialog) existingDialog.remove();
    
    // 创建覆盖层
    const overlay = document.createElement('div');
    overlay.className = 'mode-info-overlay';
    document.body.appendChild(overlay);
    
    // 创建对话框
    const dialog = document.createElement('div');
    dialog.className = 'mode-info-dialog';
    
    let title, description;
    
    if (mode === 'classic') {
        title = '经典模式';
        description = '每位玩家有3条生命，撞墙或碰撞后3秒自动复活，最后存活的玩家获胜。';
    } else if (mode === 'challenge') {
        title = '夺冠模式';
        description = '更高难度，更多障碍物，玩家需要达到目标分数（500分）才能获胜。';
    }
    
    dialog.innerHTML = `
        <h3>${title}</h3>
        <p>${description}</p>
        <button class="close-btn">关闭</button>
    `;
    
    document.body.appendChild(dialog);
    
    // 添加关闭功能
    const closeBtn = dialog.querySelector('.close-btn');
    const closeDialog = () => {
        overlay.remove();
        dialog.remove();
    };
    
    closeBtn.addEventListener('click', closeDialog);
    overlay.addEventListener('click', closeDialog);
}


// 切换设置面板显示/隐藏状态的函数
function toggleSettings() {
    console.log('切换设置面板显示状态');
    const settingsContent = document.querySelector('.game-settings .settings-content');
    const toggleIcon = document.querySelector('.game-settings .toggle-icon');
    
    if (settingsContent && toggleIcon) {
        settingsContent.classList.toggle('open');
        toggleIcon.classList.toggle('open');
        console.log('设置面板状态:', settingsContent.classList.contains('open') ? '已展开' : '已折叠');
    }
}


// 修改 endMultiplayerGame 函数
function endMultiplayerGame(data) {
    // 标记为游戏结束但保持多人游戏模式标识
    gameState.isPlaying = false;
    gameState.isGameOver = true;
    
    // 恢复单人游戏UI
document.getElementById('score-container').style.display = 'flex';
document.getElementById('status-display').style.display = 'flex'; // 恢复状态显示

    
    // 显示游戏结束菜单
    document.getElementById('game-over-title').textContent = '游戏结束';
    if (data && data.winner) {
        const finalScore = document.getElementById('final-score');
        const finalLength = document.getElementById('final-length');
        const gameOverMessage = document.getElementById('game-over-message');
        
        finalScore.textContent = `获胜者: ${data.winner.name}`;
        finalLength.textContent = `得分: ${data.winner.score}`;
        
        if (data.winner.id === playerId) {
            gameOverMessage.textContent = '恭喜你获得胜利！';
        } else {
            gameOverMessage.textContent = '再接再厉！';
        }
    }

    // 确保游戏结束菜单中有返回大厅按钮，但不重复添加
    const gameOverDialog = document.querySelector('#game-over .dialog');
    let backToLobbyBtn = document.getElementById('back-to-lobby-btn');
    
    if (!backToLobbyBtn) {
        backToLobbyBtn = document.createElement('button');
        backToLobbyBtn.id = 'back-to-lobby-btn';
        backToLobbyBtn.textContent = '返回游戏大厅';
        backToLobbyBtn.className = 'btn';
        backToLobbyBtn.style.backgroundColor = '#4CAF50';
        backToLobbyBtn.onclick = function() {
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('game-lobby').style.display = 'flex';
        };
        
        // 在菜单按钮前插入
        const menuBtn = document.getElementById('menu-btn');
        if (menuBtn && menuBtn.parentNode === gameOverDialog) {
            gameOverDialog.insertBefore(backToLobbyBtn, menuBtn);
        } else {
            gameOverDialog.appendChild(backToLobbyBtn);
        }
    }

    document.getElementById('game-over').style.display = 'flex';
    
    // 停止游戏循环
    if (gameState.animationFrame) {
        cancelAnimationFrame(gameState.animationFrame);
    }
    
    // 重要：不清除多人游戏状态标志，只隐藏UI元素
    document.getElementById('multiplayer-status').style.display = 'none';
    document.getElementById('multiplayer-chat').style.display = 'none';
    
    // 恢复3D旋转效果
    canvas.classList.add('rotate-effect');
}


function resetMultiplayerGameState() {
    console.log('重置多人游戏状态');
    
    // 重置游戏状态标志，但保持多人游戏连接
    multiplayerGameState = null;
    
    // 重置本地游戏状态
    gameState.isPlaying = false;
    gameState.isPaused = false;
    gameState.isGameOver = false;
    gameState.score = 0;
    gameState.snake = [];
    gameState.snakeInterpolated = [];
    gameState.obstacles = [];
    gameState.trail = [];
    gameState.particles = [];
    gameState.food = null;
    gameState.direction = 'right';
    gameState.nextDirection = 'right';
    gameState.combo = 0;
    gameState.powerUpActive = false;
    gameState.powerUpType = null;
    particleSystem.clear();
    
    // 停止任何现有动画
    if (gameState.animationFrame) {
        cancelAnimationFrame(gameState.animationFrame);
        gameState.animationFrame = null;
    }
    
    // 清除任何能力道具计时器
    if (powerUpTimeout) {
        clearTimeout(powerUpTimeout);
        powerUpTimeout = null;
    }
    
    // 清除任何食物信息计时器
    if (foodInfoTimeout) {
        clearTimeout(foodInfoTimeout);
        foodInfoTimeout = null;
    }
    
    // 清除所有游戏元素的显示
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 清除所有弹出效果
    const popups = document.querySelectorAll('.score-popup, .combo-popup');
    popups.forEach(popup => popup.remove());
    
    // 清除死亡消息
    const deathMessage = document.getElementById('death-message');
    if (deathMessage && deathMessage.parentNode) {
        deathMessage.remove();
    }
    
    // 移除所有可能存在的复活按钮和倒计时
    hideRespawnOption();
    
    console.log('多人游戏状态已重置');
}


// 重置控制按钮状态的函数
function resetControls() {
    // 确保控制按钮在单人游戏中正常显示
    const controls = document.getElementById('controls');
    if (settings.controlType === 'buttons') {
        controls.style.display = 'grid';
    } else if (settings.controlType === 'joystick') {
        document.getElementById('joystick-container').style.display = 'block';
        controls.style.display = 'none';
    }
}

// 修复暂停按钮功能
function setupPauseButton() {
    const pauseBtn = document.getElementById('pause-btn');
    // 移除可能存在的旧事件处理器
    const newPauseBtn = pauseBtn.cloneNode(true);
    pauseBtn.parentNode.replaceChild(newPauseBtn, pauseBtn);
    
    newPauseBtn.addEventListener('click', function() {
        console.log('暂停按钮被点击, 多人游戏模式:', isMultiplayerGame);
        if (!isMultiplayerGame) {
            // 单人游戏使用暂停逻辑
            togglePause();
        } else {
            // 多人游戏中显示一个特殊的信息菜单
            const pauseMenu = document.getElementById('pause-menu');
            const pauseTitle = pauseMenu.querySelector('h2');
            const resumeBtn = document.getElementById('resume-btn');
            const pauseMenuBtn = document.getElementById('pause-menu-btn');
            
            // 修改暂停菜单内容
            pauseTitle.textContent = '游戏信息';
            resumeBtn.textContent = '继续游戏';
            pauseMenuBtn.textContent = '返回主菜单';
            
            // 显示菜单
            pauseMenu.style.display = 'flex';
            
            // 同时打开聊天窗口方便交流
            document.getElementById('multiplayer-chat').classList.add('show');
            
            // 设置游戏暂停状态(仅本地视觉暂停)
            gameState.isPaused = true;
        }
    });
}

// 修改暂停菜单中的返回菜单按钮事件处理
function setupPauseMenuButton() {
    const pauseMenuBtn = document.getElementById('pause-menu-btn');
    
    // 移除可能存在的旧事件处理器
    const newPauseMenuBtn = pauseMenuBtn.cloneNode(true);
    pauseMenuBtn.parentNode.replaceChild(newPauseMenuBtn, pauseMenuBtn);
    
    newPauseMenuBtn.addEventListener('click', function() {
        // 停止游戏循环
        if (gameState.animationFrame) {
            cancelAnimationFrame(gameState.animationFrame);
            gameState.animationFrame = null;
        }
        
        // 重置游戏状态
        gameState.isPlaying = false;
        gameState.isPaused = false;
        
        // 隐藏暂停菜单
        document.getElementById('pause-menu').style.display = 'none';
        
        // 根据游戏模式重置
        if (isMultiplayerGame) {
            // 彻底清理多人游戏状态
            resetMultiplayerGame();
        } else {
            // 显示主菜单
            document.getElementById('main-menu').style.display = 'flex';
            
            // 恢复3D旋转效果
            canvas.classList.add('rotate-effect');
        }
    });
}



// 辅助函数: 将十六进制颜色转换为HSL
function hexToHsl(hex) {
// 移除前导#
hex = hex.replace(/^#/, '');
// 解析十六进制
let r, g, b;
if (hex.length === 3) {
    r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
    g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
    b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
} else {
    r = parseInt(hex.substring(0, 2), 16) / 255;
    g = parseInt(hex.substring(2, 4), 16) / 255;
    b = parseInt(hex.substring(4, 6), 16) / 255;
}

// 计算HSL
const max = Math.max(r, g, b);
const min = Math.min(r, g, b);
let h, s, l = (max + min) / 2;

if (max === min) {
    h = s = 0; // 灰色
} else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    
    switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
    }
    
    h /= 6;
}

return [h * 360, s * 100, l * 100];
}


// 设置多人游戏事件监听器
function setupMultiplayerEvents() {
    console.log('设置多人游戏事件监听器');
    
    // 清除可能存在的旧监听器
    const elements = [
        'multiplayer-back-btn', 'create-game-btn', 'join-game-btn',
        'join-btn', 'join-back-btn', 'start-game-btn', 'leave-game-btn',
        'send-chat-btn', 'chat-input', 'menu-btn'
    ];
    
    elements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            const newElement = element.cloneNode(true);
            element.parentNode.replaceChild(newElement, element);
        }
    });
    
    // 返回主菜单 - 特别加强处理，确保多种情况下都能工作
    const multiplayerBackBtn = document.getElementById('multiplayer-back-btn');
    if (multiplayerBackBtn) {
        multiplayerBackBtn.addEventListener('click', function() {
            console.log('点击多人游戏返回按钮');
            document.getElementById('multiplayer-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            
            // 如果有连接错误，尝试重置socket
            if (socket && socket.disconnected) {
                console.log('检测到断开连接状态，尝试清理Socket');
                try {
                    socket.removeAllListeners();
                    socket.disconnect();
                } catch (e) {
                    console.error('清理Socket失败:', e);
                }
            }
        });
        
        // 额外添加触摸事件，确保在移动设备上也能工作
        multiplayerBackBtn.addEventListener('touchend', function(e) {
            e.preventDefault();
            console.log('触摸点击多人游戏返回按钮');
            document.getElementById('multiplayer-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        });
    } else {
        console.error('找不到多人游戏返回按钮');
    }

    // 创建游戏
const createGameBtn = document.getElementById('create-game-btn');
if (createGameBtn) {
    createGameBtn.addEventListener('click', () => {
        playerName = document.getElementById('player-name').value.trim();
        if (!playerName) {
            alert('请输入您的名字');
            return;
        }
        
        // 更新游戏记录
        updateGameRecord('multiplayer', { playerName: playerName });
        
        if (socket && socket.connected) {
            socket.emit('createGame', {
                playerName: playerName,
                playerColor: getRandomPlayerColor()
            });
        } else {
            alert('无法连接到服务器，请检查网络连接');
            ensureBackButtonWorks(); // 确保返回按钮可用
        }
    });
}

    // 显示加入游戏界面
    const joinGameBtn = document.getElementById('join-game-btn');
    if (joinGameBtn) {
        joinGameBtn.addEventListener('click', () => {
            playerName = document.getElementById('player-name').value.trim();
            if (!playerName) {
                alert('请输入您的名字');
                return;
            }
            
            if (socket && socket.connected) {
                document.getElementById('multiplayer-menu').style.display = 'none';
                document.getElementById('join-game-menu').style.display = 'flex';
            } else {
                alert('无法连接到服务器，请检查网络连接');
                ensureBackButtonWorks(); // 确保返回按钮可用
            }
        });
    }

    // 加入游戏
    const joinBtn = document.getElementById('join-btn');
    if (joinBtn) {
        joinBtn.addEventListener('click', () => {
            const gameId = document.getElementById('game-id').value.trim();
            if (!gameId) {
                alert('请输入房间ID');
                return;
            }
            
            if (socket && socket.connected) {
                socket.emit('joinGame', {
                    gameId: gameId,
                    playerName: playerName,
                    playerColor: getRandomPlayerColor()
                });
            } else {
                alert('无法连接到服务器，请检查网络连接');
                // 确保能够返回到上一个菜单
                document.getElementById('join-game-menu').style.display = 'none';
                document.getElementById('multiplayer-menu').style.display = 'flex';
            }
        });
    }

    // 返回多人菜单（从加入游戏界面）
    const joinBackBtn = document.getElementById('join-back-btn');
    if (joinBackBtn) {
        joinBackBtn.addEventListener('click', () => {
            document.getElementById('join-game-menu').style.display = 'none';
            document.getElementById('multiplayer-menu').style.display = 'flex';
        });
        
        // 添加触摸事件
        joinBackBtn.addEventListener('touchend', function(e) {
            e.preventDefault();
            document.getElementById('join-game-menu').style.display = 'none';
            document.getElementById('multiplayer-menu').style.display = 'flex';
        });
    }

    // 开始游戏
const startGameBtn = document.getElementById('start-game-btn');
if (startGameBtn) {
    startGameBtn.addEventListener('click', () => {
        if (connectedPlayers.length < 1) {
            alert('至少需要1名玩家才能开始游戏');
            return;
        }
        
        // 从设置UI元素中获取设置值
        const gameSettings = {
            gridSize: parseInt(document.getElementById('grid-size-setting').value),
            gameSpeed: document.getElementById('game-speed-setting').value,
            foodCount: parseInt(document.getElementById('food-count-setting').value),
            obstacleDensity: document.getElementById('obstacle-density-setting').value,
            powerUps: document.getElementById('power-ups-setting').value
        };
        
        const gameOptions = {
            gameMode: document.getElementById('game-mode-setting').value, // 获取游戏模式
            allowLateJoin: false,
            allowRespawn: true,
            gameSettings: gameSettings
        };
        
        console.log('发送startGame事件，选项:', gameOptions);
        socket.emit('startGame', gameOptions);
    });
}


    // 离开游戏
    const leaveGameBtn = document.getElementById('leave-game-btn');
    if (leaveGameBtn) {
        leaveGameBtn.addEventListener('click', () => {
            // 通知服务器
            if (socket && socket.connected) {
                socket.emit('leaveGame');
            }
            
            // 彻底清理游戏状态
            isMultiplayerGame = false;
            multiplayerGameId = null;
            
            // 停止任何游戏循环
            if (gameState.animationFrame) {
                cancelAnimationFrame(gameState.animationFrame);
                gameState.animationFrame = null;
            }
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 重置游戏状态
            resetMultiplayerGame();
            
            // 显示主菜单
            document.getElementById('game-lobby').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        });
    }

    // 发送聊天消息
    const sendChatBtn = document.getElementById('send-chat-btn');
    if (sendChatBtn) {
        sendChatBtn.addEventListener('click', sendChatMessage);
    }
    
    const chatInput = document.getElementById('chat-input');
    if (chatInput) {
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });
    }

    // 游戏结束后返回大厅
    const menuBtn = document.getElementById('menu-btn');
    if (menuBtn) {
        menuBtn.addEventListener('click', function() {
            if (isMultiplayerGame) {
                console.log('在多人游戏中点击了菜单按钮，返回大厅而非主菜单');
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('game-lobby').style.display = 'flex';
                return;
            }
            
            // 单人游戏返回主菜单
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        });
    }

    // 游戏大厅设置
    // 网格大小设置
    const gridSizeSetting = document.getElementById('grid-size-setting');
    const gridSizeValue = document.getElementById('grid-size-value');
    if (gridSizeSetting && gridSizeValue) {
        gridSizeSetting.addEventListener('input', () => {
            gridSizeValue.textContent = gridSizeSetting.value;
        });
    }

    // 食物数量设置
    const foodCountSetting = document.getElementById('food-count-setting');
    const foodCountValue = document.getElementById('food-count-value');
    if (foodCountSetting && foodCountValue) {
        foodCountSetting.addEventListener('input', () => {
            foodCountValue.textContent = foodCountSetting.value;
        });
    }
    
    // 游戏模式设置
    const gameModeSettingSelect = document.getElementById('game-mode-setting');
    if (gameModeSettingSelect) {
        gameModeSettingSelect.addEventListener('change', function() {
            const modeDescription = document.getElementById('game-mode-description');
            if (modeDescription) {
                switch(this.value) {
                    case 'classic':
                        modeDescription.textContent = '经典模式：基础游戏体验，平衡的难度和乐趣。';
                        break;
                    case 'challenge':
                        modeDescription.textContent = '夺冠模式：更高难度，更多障碍物，需要达到目标分数（500分）才能获胜。';
                        break;
                }
            }
        });
    }
    
    // 设置大厅内设置面板切换事件
    setupLobbySettingsToggle();
    
    console.log('多人游戏事件监听器设置完成');
}


// 添加新的辅助函数，专门设置游戏大厅中的设置面板切换功能
function setupLobbySettingsToggle() {
    console.log('设置游戏大厅设置面板切换功能');
    const settingsHeader = document.querySelector('.game-settings .settings-header');
    const settingsContent = document.querySelector('.game-settings .settings-content');
    const toggleIcon = document.querySelector('.game-settings .toggle-icon');
    
    if (settingsHeader && settingsContent && toggleIcon) {
        // 移除之前可能存在的事件监听器
        const newSettingsHeader = settingsHeader.cloneNode(true);
        settingsHeader.parentNode.replaceChild(newSettingsHeader, settingsHeader);
        
        // 添加点击事件处理器
        newSettingsHeader.addEventListener('click', function() {
            console.log('点击了设置面板标题');
            
            // 切换内容区域的显示状态
            settingsContent.classList.toggle('open');
            toggleIcon.classList.toggle('open');
            
            // 手动检查并控制所有设置项的显示状态
            const isOpen = settingsContent.classList.contains('open');
            const allSettingItems = document.querySelectorAll('.game-settings .setting-item');
            
            allSettingItems.forEach(item => {
                // 如果设置项不在settings-content内，需要单独处理
                if (!settingsContent.contains(item)) {
                    // 设置显示状态
                    item.style.display = isOpen ? 'flex' : 'none';
                }
            });
            
            console.log('设置面板状态:', isOpen ? '已展开' : '已折叠');
        });
        
        // 初始化设置项状态
        const isInitiallyOpen = settingsContent.classList.contains('open');
        document.querySelectorAll('.game-settings .setting-item').forEach(item => {
            if (!settingsContent.contains(item)) {
                item.style.display = isInitiallyOpen ? 'flex' : 'none';
            }
        });
        
        console.log('设置面板切换功能已设置');
    } else {
        console.error('设置面板元素不存在，无法绑定事件');
    }
}



// 更新设置面板可见性
function updateSettingsVisibility() {
    console.log('更新设置面板可见性，当前用户是否为房主:', isHost);
    const gameSettingsPanel = document.querySelector('.game-settings.host-only');
    
    if (gameSettingsPanel) {
        if (isHost) {
            gameSettingsPanel.style.display = 'block';
            console.log('房主：显示设置面板');
        } else {
            gameSettingsPanel.style.display = 'none';
            console.log('非房主：隐藏设置面板');
        }
    } else {
        console.error('未找到游戏设置面板元素');
    }
}



// 完全退出多人游戏（只在返回主菜单时调用）
function resetMultiplayerGame() {
    console.log('彻底重置多人游戏');
    
    // 在退出前先通知服务器
    if (socket && socket.connected && multiplayerGameId) {
        socket.emit('leaveGame');
    }
    
    // 重置游戏状态标志
    isMultiplayerGame = false;
    multiplayerGameId = null;
    
    // 彻底清空游戏状态
    multiplayerGameState = null;
    
    // 停止动画帧
    if (gameState.animationFrame) {
        cancelAnimationFrame(gameState.animationFrame);
        gameState.animationFrame = null;
    }
    
    // 清空画布以避免残留
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 隐藏所有多人游戏UI
    document.getElementById('multiplayer-status').style.display = 'none';
    document.getElementById('multiplayer-chat').style.display = 'none';
    document.getElementById('game-lobby').style.display = 'none';
    if (document.getElementById('multiplayer-controls')) {
        document.getElementById('multiplayer-controls').style.display = 'none';
    }
    
    // 移除可能存在的重生按钮
    hideRespawnOption();
    
    // 重置控制按钮状态
    resetControls();
    
    // 显示主菜单
    document.getElementById('main-menu').style.display = 'flex';
    
    console.log('多人游戏状态已完全重置');
}


// 发送聊天消息
function sendChatMessage() {
    const input = document.getElementById('chat-input');
    const message = input.value.trim();
    if (message) {
        socket.emit('sendMessage', message);
        input.value = '';
    }
    
    // 无论消息是否为空，都关闭聊天界面
    document.getElementById('multiplayer-chat').classList.remove('show');
}


// 生成随机玩家颜色
function getRandomPlayerColor() {
const colors = [
'#FF5252', '#FF4081', '#E040FB', '#7C4DFF',
'#536DFE', '#448AFF', '#40C4FF', '#18FFFF',
'#64FFDA', '#69F0AE', '#B2FF59', '#EEFF41',
'#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'
];
return colors[Math.floor(Math.random() * colors.length)];
}

// 修改方向控制以支持多人游戏
function changeDirectionMultiplayer(newDirection) {
if (!isMultiplayerGame) {
// 单人游戏使用原有逻辑
changeDirection(newDirection);
return;
}
// 多人游戏发送方向变更到服务器
socket.emit('changeDirection', newDirection);
}

// 暂停按钮修改
const pauseBtn = document.getElementById('pause-btn');
const originalPauseBtnHandler = pauseBtn.onclick;
pauseBtn.onclick = function() {
if (!isMultiplayerGame) {
// 单人游戏使用原有暂停逻辑
togglePause();
} else {
// 多人游戏中可以打开聊天
const chatInput = document.getElementById('chat-input');
if (chatInput) {
chatInput.focus();
}
}
};

// 修改游戏结束处理以支持多人游戏
const originalEndGame = endGame;
endGame = function(reason) {
if (isMultiplayerGame) {
// 多人游戏中，死亡由服务器处理
return;
}
// 单人游戏使用原有逻辑
originalEndGame(reason);
};

// 修改重新开始按钮
const restartBtn = document.getElementById('restart-btn');
const originalRestartBtnHandler = restartBtn.onclick;
restartBtn.onclick = function() {
    // 检查是否在多人游戏模式
    if (isMultiplayerGame) {
        console.log('在多人游戏中点击了重新开始按钮，返回大厅');
        document.getElementById('game-over').style.display = 'none';
        
        // 重置游戏状态
        resetMultiplayerGameState();
        
        // 显示大厅
        document.getElementById('game-lobby').style.display = 'flex';
        
        // 如果是房主，确保开始游戏按钮可见
        if (isHost) {
            document.getElementById('start-game-btn').style.display = 'block';
        }
        
        return;
    }

    
    // 单人游戏使用原始处理函数
    if (originalRestartBtnHandler) {
        originalRestartBtnHandler();
    }
};

        
        
        
        // 单元格大小(根据画布大小和网格大小计算)
        let cellSize = 0;
        
        // 食物类型及效果
        const foodTypes = {
            red: {
                color: '#ff3333',
                borderColor: '#cc0000',
                name: '加速食物',
                effect: '增加速度',
                points: 15,
                action: () => {
                    gameState.speed = Math.max(50, gameState.speed - 20);
                    updateSpeedDisplay();
                }
            },
     yellow: {
    color: '#ffcc00',
    borderColor: '#cc9900',
    name: '翻倍食物',
    effect: '5秒内分数翻倍',
    points: 10, // 基础分数降低，因为有翻倍效果
    action: () => {
        // 激活分数翻倍
        activateScoreMultiplier(5000); // 5秒钟
    }
},

            green: {
                color: '#33cc33',
                borderColor: '#009900',
                name: '减速食物',
                effect: '降低速度',
                points: 10,
                action: () => {
                    gameState.speed = Math.min(300, gameState.speed + 30);
                    updateSpeedDisplay();
                }
            },
            blue: {
                color: '#3399ff',
                borderColor: '#0066cc',
                name: '穿墙食物',
                effect: '可穿墙5秒',
                points: 30,
                action: () => {
                    activatePowerUp('phase', 5000);
                }
            },
            purple: {
                color: '#9933ff',
                borderColor: '#6600cc',
                name: '无敌食物',
                effect: '暂时无敌',
                points: 40,
                action: () => {
                    activatePowerUp('invincible', 5000);
                }
            }
        };
        
        // 音效
const sounds = {
    eat: new Audio("data:audio/wav;base64,UklGRiQFAABXQVZFZm10IBAAAAABAAEARKwAAESsAAABAAgAZGF0YQAFAACAf3x8fYB8gH2Be4F8goCEf4Z6inuQgZWElnuadJpzmXWghKaGrHevea6LrZazn7BrqYGotqI9oueWxJNRlluYe5hylw+Y05y4n+yhxaXNqSCvGLV/uEvAucNFxufEO8DHva24aa/4qg+nq6LunHOXjJPhjy+NJ4oQiLOG94WpheWGW4gxilmMdI5ZkD+S7JPgleOX25mEm/Wch58qoYiiB6RcpSmmrqbUpmqm/aLDngCb85ZSk/yP+ozzidyICYm8iv+MVJB+lCWZDZ4Io2unRaq8rHGvz6+CrlisoafEpBCexJp1mNCUsJTJl9+cT6ENpN+mnKLXmkiW+I8Mi6KJvIZuh+uLiIzqitSIj4dRhpWD8IOhhq+IMYl7icyJ3ImeiSeQHZcfnX+ij6bmp02m5KP2oqCf6JlJlSiSTo8Vi1uIbIYKiF+JZYh9iaCLuYxIkMyVbJw2oh2o5apvqUGoxKaWpDOhYJ5jmuSVuZIZkR+SlZXemHWZapm9lxCVDJN7kXOPFI3oifmGmodQh2SGF4Zvid+NRJG3k0OUj5LhkbKROpLlk/eUrZY/mIGaSprZmBKW7ZQPkteQh4/cjmaOd49Lj4GQoJJFlQGWYZkCmxuc+JzXnDmc7ps6mqiY2JcclhiU3pImk7OTBpQzlOqUQZWGlSaVNJXElQqXAphXl5uWf5aplx+WG5X+lBeU+ZPmkyOVp5a0mM+Zp5rCmRqZaZnWmCiYjpf2mPeZ0JiKl+iWb5bglA=="),
    gameOver: new Audio("data:audio/wav;base64,UklGRigEAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQEAACBhYqFbF1fdHJpfHNrY1ttdGlYRDQ0KCxGXWVgU0hRS0xGUFRLR1RmcXFwa2VVRzoxOEdHUI+l1fT//+TDo4VoSCsPM0VRiLTK3v7pxbamlHddVD4pCC9nbXN0cVhAQEVfc3+Ni6Wvqp+ZkYF1VlJQVWl0b4uepqGZk42HhH+AdnNwaGBWUlBMSVFgbX2SqL3O3N/Z0srEt7CuqqWhmJeYlIh1blRMMCQhLz9SY3aGk6Kqs77EyMjGxMLBuK+rpJ2UjYV9dGlaSj0zKiYmLTQ8S1lneoCKkpmeoqWnqauvrKijnpmWkoyFfnhtYlhNQjgvJyMgHRwdICUqMDc+RUtRV1xgZGdpbG1tbW1saWdkYV5aVVFMR0M9ODMuKiYjIB4dHB0dHyIlKi0yNjpAQkdLTlJVWFpcXl9fYGBfX15dW1lXVFJPTElGQ0A9OjczLyspJyQiIB8eHR0dHh8gIiQlJyksLjE0Njk7PkBDRUdJSkxNTk9PT09OTk1MS0lIRkVDQT89Ozo4NjQyMC8tKyopKCcmJSUkJCQjJCQkJSYnKCkrLC4vMTM1Nzk7PD4/QUJDREVGR0hISUlJSUhIR0dGRURDQkFAPj07Ojk3NjU0MzIxMC8uLSwrKyoqKSkpKSkpKSkqKisrLC0uLzAxMjM0NTY3ODk6Ozw9PT4/P0BAQEFBQUFBQUFBQUBAPz8+Pj08Ozs6OTg3NzY1NDMzMjEwMC8vLi4tLS0sLCwsLCwsLC0tLS4uLi8wMDEyMjM0NDU2Njc4ODk5Ojo7Ozw8PT09Pj4+Pj4+Pj4+Pj49PT08PDs7Ojk5ODc3NjY1NTQzMzIyMTEwMDAvLy8vLi4uLi4uLi4uLi4uLi8vLzAwMDAxMTIyMzM0NDQ1NTY2Njc3Nzg4ODk5OTo6Ojo6Ojo6Ojo6OTk5ODg4NzY2NjU1NDQ0MzMyMjIxMTEwMDAwLy8vLy8vLy8vLy8vLy8vLy8vMDAwMDAxMTEyMjIzMzM0NDQ1NTU1NjY2Njc3Nzc3ODg4ODg4ODg4ODc3Nzc3NjY2NTU1NDQ0MzMzMjIyMTExMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEyMjIyMzMzMzQ0NDQ0NTU1NTU1NjY2NjY2NjY2NjY2NjY2NTU1NTU1NDQ0NDMzMzMyMjIyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEyMjIyMjIzMzMzMzMzNDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDMzMzMzMzIyMjIyMjExMTExMTExMTExMTEx"),
    win: new Audio("data:audio/wav;base64,UklGRrQIAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YYwIAACAgICAgICAgICAgICAgICAgICAgICBAoIFgweCCIIKgQyBDYAOgA9/EH8Pfg5+DX0MfAt7CnsJegmAEZAbyCTwNRVDJE8bWAxhAWr6cfd433bXf82JxJfAnr+rwbjKydLc3/Dm9e//9hb8Ggof/yILJQQnzSbJJoQnSigKKbgpbSoiK+grqi1mMCEzQDfHO4pAmEXESmFP1FMIWPBb1V+uYqtloGh/a0VuB3DOcol1IXh+egB9IX9pgXyDeoWyh/SJQ4zEk3+cyadErUK3ZMIyz1reR+vu/W0QeyFlMq03xDtZP3hDnEa5SNdJ4kngSMtH80ZqRvhG00dWR8JFEkIFPtU5+jWiMo0vxSxTKssnICWzIpolOCioK0EuoTDYMrw0bjbqN1s5yTpfPAA+sT95QWhDY0VTR0dJP0skTQVP4lDIUrlUmVZ1WEtaJFzgXZNfQWHmYndkAGaVZxRpjGoCbGxtwm4nb4NvwW/sb/5vA3ARcEhwnHDycFVxsnIfcot0+nZyeep7i35mgV6ES4c1iieNI5AhkxqWGJkXnBafFqIWpRamFqYWpRajFqEVnxWcFJgUlNeSKIMWb0BZNzo2Qi8bKSck6h9oG+sW3RJMD/YL9QgRBkADngDp/XX7/fho9gHz+fBA7q7rOukx50blVeOV4e/fXN7P3FTbANq62IPXWNYv1R7UIdMx0k/RdtKm1H7YvNyv4LLkfOj+6/nu3/Gb9EL37vmy/GD/HgLBBEgH0QlUDNIOixFSFBIX0RmRHE0f8iGTJCsn2yk8LAkz9D2nSJ5REFYQXR9j9Wi4bVRxx3Qyd4p55XsOfR9+a4OpiruPwpPLl4Kbs56yoaOkiKdKqvmsda8dsrO0Q7fMuUK8773nv53B7cTxy1vQyNFF01rbu+WU8If7Xgb/D7MYQyBwJgssOTDxMk41yzapOF06KDwLPtU/lEFVQxFF4UZrSABKjEsZTZ9OE1BpUbRSBFRQVZZW2VcZWVNac1uQXKtdw17XYOZiIGWbYvpeNVeRTlxFlzt+MZgnTB7XFM0Kbf9o85nn1d7M0azIHsByuBGyQ614pyGnrKfCqKupsaqvq4SsUK0drtSuka+HsIKxerKCs4W0h7WRtpi3pbistbixdKo8ouKZW5EeiW2A3XXxbaRlMl0WVeVM/kR9PeY1niagHcsPUQF18l7jj9TVxSO5KK2Eor+YrZE7jPqJ/4Q8gA=="),
    teleport: new Audio("data:audio/wav;base64,UklGRqQIAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YYAIAACBhYqFbF1fdHJpfHNrY1ttdGlYRFRMTlFJVENKPEU3Pzk7MkE8Nk5OQ1ZeS2Ntb2dje3mJhJGRmaWltKitrMjJ5fL7/+/q4dTGrYuMg2lwaGBPUFNJRk44MD03MixGR0dVWGJsc32Mi6Wvq6OYl4t/d3twaGh3gH1rdWJZT05ENDoqLiQeJRwhGx4aHCg1O0dFUVZlfYyXqLfL3uzv9vH+/f/+/vv++/bu6d7OtaKSg4d4X0xGOTAcExIPDAYKAgsSGx4qKjhCSFRdaHV5kKakssDb2+f2//jl6efb39zMyLazqqGVj4iCeXRuaGFdU01KPz04MzEsLy0sLy8xNzo6Pzo+Oj07ODo5NjY1MzMzMDIwMC4uLi0tLCsrKyoqKSgoJyYlJCMiISAfHh0cGhkYFhQSEA4MCggHBQQDAgEAAAEBAQMEBQcICgsNDhASExQWFxgaGxwdHh8gISIjJCQlJiYnKCgpKisrLC0tLi8vMDEyMzQ1NTY3ODk6Ojs8PT0+Pz9AQUFCQ0RFRkdISUpLS0xNTk9QUVFSU1RVVlZXWFlaW1tcXV1eX19gYWFiY2NkZWVmZ2doaGlqamtrbGxtbm5vcHBxcXJyc3N0dHV1dnZ3d3h4eXl6ent7fHx9fX5+f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7///8=") // 传送门音效
};

    // 时间相关
let powerUpTimeout = null;    // 能力道具计时器
let foodInfoTimeout = null;   // 食物信息计时器
let scoreMultiplierTimeout = null; // 分数翻倍计时器

    // ============== 游戏初始化函数 ==============
    function initGame() {
    // 根据游戏容器调整画布大小
    resizeCanvas();
    
    // 初始化蛇的位置
    gameState.snake = [];
    for (let i = 6; i >= 0; i--) {
        gameState.snake.push({x: i, y: Math.floor(settings.gridSize / 2)});
    }
    
    // 初始化插值位置(用于平滑动画)
    resetSnakeInterpolation();
    
    // 重置游戏状态
    gameState.obstacles = [];
    gameState.trail = [];
    gameState.particles = [];
    gameState.direction = 'right';
    gameState.nextDirection = 'right';
    gameState.speed = settings.baseSpeed / settings.speedMultiplier;
    gameState.score = 0;
    gameState.combo = 0;
    gameState.isGameOver = false;
    gameState.powerUpActive = false;
    gameState.powerUpType = null;
    gameState.scoreMultiplierActive = false;
    gameState.scoreMultiplierTimeLeft = 0;
    
    // 清除计时器
    if (powerUpTimeout) {
        clearTimeout(powerUpTimeout);
        powerUpTimeout = null;
    }
    
    if (scoreMultiplierTimeout) {
        clearTimeout(scoreMultiplierTimeout);
        scoreMultiplierTimeout = null;
    }
    
    // 生成第一个食物
    generateFood();
    
    // 根据游戏模式初始化障碍物
    if (gameState.gameMode === 'challenge') {
        // 挑战模式下初始添加5-8个障碍物
        const obstacleCount = 5 + Math.floor(Math.random() * 4);
        for (let i = 0; i < obstacleCount; i++) {
            addObstacle();
        }
    } else if (gameState.gameMode === 'classic') {
        // 经典模式下初始添加2-3个障碍物
        const obstacleCount = 2 + Math.floor(Math.random() * 2);
        for (let i = 0; i < obstacleCount; i++) {
            addObstacle();
        }
    }
    // 禅模式不添加障碍物
    
    // 更新显示
    updateScoreDisplay();
    updateSpeedDisplay();
    document.getElementById('mode-display').textContent = '模式: ' + getModeText();
    
    // 移除3D旋转效果
    canvas.classList.remove('rotate-effect');
}

    
    function resetSnakeInterpolation() {
        gameState.snakeInterpolated = gameState.snake.map(segment => ({
            displayX: segment.x,
            displayY: segment.y
        }));
    }
    
    // 调整画布大小 - 修复网格渲染问题
function resizeCanvas() {
    const container = document.getElementById('game-container');
    // 获取容器大小
    const containerSize = Math.min(container.clientWidth, container.clientHeight);
    
    // 精确计算每个单元格大小，确保整数
    cellSize = Math.floor(containerSize / settings.gridSize);
    
    // 重新计算画布大小，确保完全匹配网格
    const canvasSize = cellSize * settings.gridSize;
    
    // 设置画布大小
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    
    // 调整画布在容器中居中
    canvas.style.marginLeft = `${(containerSize - canvasSize) / 2}px`;
    canvas.style.marginTop = `${(containerSize - canvasSize) / 2}px`;
    
    console.log(`调整画布大小: 容器=${containerSize}px, 单元格=${cellSize}px, 画布=${canvasSize}px, 网格=${settings.gridSize}x${settings.gridSize}`);
}

    
    // ============== 游戏核心逻辑 ==============
    // 游戏循环
    function gameLoop(timestamp) {
    if (!gameState.lastFrameTime) gameState.lastFrameTime = timestamp;
    
    const deltaTime = timestamp - gameState.lastFrameTime;
    gameState.accumulatedTime += deltaTime;
    
    if (!gameState.isPaused && gameState.isPlaying) {
        // 处理逻辑更新(基于时间步长)
        const updateSteps = Math.floor(gameState.accumulatedTime / gameState.speed);
        
        if (updateSteps > 0) {
            // 限制单帧最大更新次数，防止卡顿后大量更新
            const maxUpdates = Math.min(updateSteps, 3);
            
            for (let i = 0; i < maxUpdates; i++) {
                updateGame();
                gameState.accumulatedTime -= gameState.speed;
            }
            
            // 如果累积了太多更新，直接丢弃以追赶当前时间
            if (updateSteps > maxUpdates) {
                gameState.accumulatedTime = 0;
            }
        }
        
        // 更新平滑动画 - 使用线性插值因子
        const alpha = gameState.accumulatedTime / gameState.speed;
        updateAnimations(alpha);
        
        // 绘制游戏画面
        draw();
    }
    
    gameState.lastFrameTime = timestamp;
    
    // 仅在游戏正在进行时继续动画循环
    if (gameState.isPlaying) {
        gameState.animationFrame = requestAnimationFrame(gameLoop);
    }
}

// 添加绘制传送门函数
function drawPortals() {
  if (!multiplayerGameState || !multiplayerGameState.portals) return;
  
  multiplayerGameState.portals.forEach(portal => {
    // 画传送门主体
    const x = portal.x * cellSize;
    const y = portal.y * cellSize;
    const centerX = x + cellSize / 2;
    const centerY = y + cellSize / 2;
    const radius = cellSize * 0.4;
    
    // 添加发光效果
    ctx.shadowColor = portal.color;
    ctx.shadowBlur = 15;
    
    // 创建渐变
    const gradient = ctx.createRadialGradient(
      centerX, centerY, radius * 0.2,
      centerX, centerY, radius
    );
    
    if (portal.id === 0) {
      // 蓝色传送门
      gradient.addColorStop(0, '#64B5F6');
      gradient.addColorStop(0.7, '#2196F3');
      gradient.addColorStop(1, '#0D47A1');
    } else {
      // 粉色传送门
      gradient.addColorStop(0, '#F48FB1');
      gradient.addColorStop(0.7, '#E91E63');
      gradient.addColorStop(1, '#880E4F');
    }
    
    // 绘制传送门圆形
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
    
    // 绘制传送门内部图案
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.beginPath();
    
    // 创建旋转效果 - 随时间旋转的螺旋
    const rotationAngle = (Date.now() / 500) % (Math.PI * 2);
    
    // 绘制螺旋图案
    for (let i = 0; i < 3; i++) {
      const angle = rotationAngle + (i * Math.PI * 2 / 3);
      const spiralX = centerX + Math.cos(angle) * radius * 0.5;
      const spiralY = centerY + Math.sin(angle) * radius * 0.5;
      
      ctx.arc(spiralX, spiralY, radius * 0.15, 0, Math.PI * 2);
    }
    
    ctx.fill();
    
    // 重置阴影
    ctx.shadowBlur = 0;
  });
}
    
    // 游戏状态更新
    function updateGame() {
        if (gameState.isGameOver) return;
        
        // 更新方向
        gameState.direction = gameState.nextDirection;
        
        // 计算新的头部位置
        const head = {...gameState.snake[0]};
        
        switch (gameState.direction) {
            case 'up': head.y--; break;
            case 'down': head.y++; break;
            case 'left': head.x--; break;
            case 'right': head.x++; break;
        }
        
        // 碰撞检测
        let collisionDetected = false;
        
        // 检查边界碰撞(除非有穿墙能力)
        if (!gameState.powerUpActive || gameState.powerUpType !== 'phase') {
            if (head.x < 0 || head.x >= settings.gridSize || head.y < 0 || head.y >= settings.gridSize) {
                collisionDetected = true;
            }
        } else {
            // 穿墙处理
            if (head.x < 0) head.x = settings.gridSize - 1;
            if (head.x >= settings.gridSize) head.x = 0;
            if (head.y < 0) head.y = settings.gridSize - 1;
            if (head.y >= settings.gridSize) head.y = 0;
        }
        
        // 检查自身碰撞(除非有无敌能力)
        if (!collisionDetected && (!gameState.powerUpActive || gameState.powerUpType !== 'invincible')) {
            for (let i = 0; i < gameState.snake.length; i++) {
                if (gameState.snake[i].x === head.x && gameState.snake[i].y === head.y) {
                    collisionDetected = true;
                    break;
                }
            }
        }
        
        // 检查障碍物碰撞(除非有无敌能力)
        if (!collisionDetected && (!gameState.powerUpActive || gameState.powerUpType !== 'invincible')) {
            for (let i = 0; i < gameState.obstacles.length; i++) {
                if (gameState.obstacles[i].x === head.x && gameState.obstacles[i].y === head.y) {
                    collisionDetected = true;
                    break;
                }
            }
        }
        
        // 如果检测到碰撞
        if (collisionDetected) {
            endGame('collision');
            return;
        }
        
        // 移动蛇
        gameState.snake.unshift(head);
        
        // 记录轨迹
        if (settings.particlesEnabled) {
            gameState.trail.push({...head, alpha: 1});
            if (gameState.trail.length > 10) gameState.trail.shift();
        }
        
        // 检查是否吃到食物
if (gameState.food && head.x === gameState.food.x && head.y === gameState.food.y) {
    // 播放音效
    if (settings.soundEnabled) {
        sounds.eat.currentTime = 0;
        sounds.eat.play();
    }
    
    // 记录当前食物类型（在应用action之前）
    const currentFoodType = gameState.food.type;
    
    // 应用食物效果
    const foodInfo = foodTypes[currentFoodType];
    foodInfo.action();
    
    // 更新分数
    const comboMultiplier = gameState.combo > 0 ? gameState.combo : 1;
    let points = foodInfo.points * comboMultiplier;
    
    // 处理分数翻倍效果
    // 注意：当前食物如果是黄色，则不享受翻倍效果（黄色激活翻倍，但不自己享受）
    if (gameState.scoreMultiplierActive && currentFoodType !== 'yellow') {
        points *= 2;
        // 创建额外的分数翻倍提示
        if (settings.particlesEnabled) {
            const bonusPopup = document.createElement('div');
            bonusPopup.className = 'score-popup';
            bonusPopup.textContent = `双倍!`;
            bonusPopup.style.left = `${(gameState.food.x + 0.5) * cellSize}px`;
            bonusPopup.style.top = `${(gameState.food.y + 0.5) * cellSize - 40}px`;
            bonusPopup.style.color = '#ffcc00';
            document.getElementById('game-container').appendChild(bonusPopup);
            
            // 删除元素
            setTimeout(() => {
                bonusPopup.remove();
            }, 800);
        }
    }
    
    gameState.score += points;
    gameState.combo++;
    updateScoreDisplay();
    
    // 创建分数弹出效果
    if (settings.particlesEnabled) {
        createScorePopup(gameState.food.x, gameState.food.y, points);
        
        // 连击提示
        if (gameState.combo > 1) {
            createComboPopup(gameState.food.x, gameState.food.y);
        }
        
        // 创建粒子效果
        particleSystem.createExplosion(gameState.food.x, gameState.food.y, foodInfo.color, 20);
    }
    
    // 在挑战模式中检查胜利条件
    if (gameState.gameMode === 'challenge' && gameState.score >= settings.challengeTarget) {
        endGame('victory');
        return;
    }
    
    // 生成新食物
    generateFood();
    
    // 根据游戏模式添加障碍物
    if (gameState.gameMode === 'challenge' && Math.random() < 0.5) {
        // 挑战模式有50%几率添加障碍物
        addObstacle();
    } else if (gameState.gameMode === 'classic' && Math.random() < 0.2) {
        // 经典模式有20%几率添加障碍物
        addObstacle();
    }
    // 禅模式不添加障碍物
} else {
    // 如果没有吃到食物，移除蛇尾
    gameState.snake.pop();
    gameState.combo = 0; // 重置连击
}

}
    
    // ============== 改进的粒子特效系统 ==============
const particleSystem = {
    particles: [],
    maxParticles: 300, // 最大粒子数量限制
    
    // 创建食物吃到时的爆炸效果
    createExplosion(x, y, color, count = 15) {
        if (!settings.particlesEnabled) return;
        
        // 解析颜色为RGB
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        
        // 限制最大粒子数量
        if (this.particles.length > this.maxParticles - count) {
            // 移除最旧的粒子
            this.particles.splice(0, count);
        }
        
        for (let i = 0; i < count; i++) {
            // 随机方向和速度
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.1 + Math.random() * 0.2;
            
            this.particles.push({
                x: x + 0.5,
                y: y + 0.5,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: 0.5 + Math.random() * 0.5,
                alpha: 1,
                color: {r, g, b},
                life: 1, // 生命值从1递减至0
                decay: 0.02 + Math.random() * 0.02, // 随机衰减速率
                gravity: 0.001 * (Math.random() + 0.5), // 添加一点重力
                spin: (Math.random() - 0.5) * 0.1, // 旋转效果
                type: 'normal'
            });
        }
    },
    
    // 创建蛇移动的尾迹效果
    createTrail(x, y, color, direction) {
        if (!settings.particlesEnabled) return;
        if (Math.random() > 0.3) return; // 只有30%的移动会产生尾迹
        
        // 解析颜色为RGB
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        
        // 根据方向设置尾迹产生的偏移位置
        let offsetX = 0, offsetY = 0;
        
        switch (direction) {
            case 'up': offsetY = 0.8; break;
            case 'down': offsetY = 0.2; break;
            case 'left': offsetX = 0.8; break;
            case 'right': offsetX = 0.2; break;
        }
        
        // 限制最大粒子数量
        if (this.particles.length > this.maxParticles - 1) {
            this.particles.shift();
        }
        
        this.particles.push({
            x: x + offsetX,
            y: y + offsetY,
            vx: (Math.random() - 0.5) * 0.05,
            vy: (Math.random() - 0.5) * 0.05,
            radius: 0.1 + Math.random() * 0.2,
            alpha: 0.7,
            color: {r, g, b},
            life: 1,
            decay: 0.03 + Math.random() * 0.02,
            gravity: 0,
            type: 'trail'
        });
    },
    
    // 创建能力激活时的环绕效果
    createPowerUpEffect(snake, type) {
        if (!settings.particlesEnabled) return;
        
        // 获取头部位置
        const head = snake[0];
        
        // 设置颜色
        let r, g, b;
        if (type === 'phase') {
            r = 0; g = 229; b = 255; // 蓝色
        } else {
            r = 224; g = 64; b = 251; // 紫色
        }
        
        // 产生环绕粒子
        for (let i = 0; i < 5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 0.5 + Math.random() * 0.3;
            
            // 限制最大粒子数量
            if (this.particles.length > this.maxParticles - 1) {
                this.particles.shift();
            }
            
            this.particles.push({
                x: head.x + 0.5 + Math.cos(angle) * distance,
                y: head.y + 0.5 + Math.sin(angle) * distance,
                vx: Math.cos(angle) * 0.05,
                vy: Math.sin(angle) * 0.05,
                radius: 0.15 + Math.random() * 0.15,
                alpha: 0.9,
                color: {r, g, b},
                life: 1,
                decay: 0.02,
                gravity: -0.001, // 轻微向上飘
                orbitRadius: distance,
                orbitSpeed: 0.1 + Math.random() * 0.1,
                orbitAngle: angle,
                type: 'orbit',
                centerX: head.x + 0.5,
                centerY: head.y + 0.5
            });
        }
    },
    
    // 更新所有粒子
    update(delta) {
        if (!settings.particlesEnabled) return;
        
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            
            // 更新生命值
            p.life -= p.decay;
            
            // 移除死亡粒子
            if (p.life <= 0) {
                this.particles.splice(i, 1);
                continue;
            }
            
            // 根据粒子类型更新
            if (p.type === 'orbit') {
                // 更新轨道粒子
                p.orbitAngle += p.orbitSpeed;
                p.centerX = gameState.snake[0].x + 0.5;
                p.centerY = gameState.snake[0].y + 0.5;
                p.x = p.centerX + Math.cos(p.orbitAngle) * p.orbitRadius;
                p.y = p.centerY + Math.sin(p.orbitAngle) * p.orbitRadius;
            } else {
                // 更新普通粒子
                p.x += p.vx;
                p.y += p.vy;
                p.vy += p.gravity || 0;
                
                // 应用自转效果
                if (p.spin) {
                    p.vx = p.vx * Math.cos(p.spin) - p.vy * Math.sin(p.spin);
                    p.vy = p.vx * Math.sin(p.spin) + p.vy * Math.cos(p.spin);
                }
            }
            
            // 更新透明度
            p.alpha = p.life > 0.8 ? 1 : p.life * 1.25;
        }
    },
    
    // 绘制所有粒子
    draw(ctx, cellSize) {
        if (!settings.particlesEnabled || this.particles.length === 0) return;
        
        for (const p of this.particles) {
            // 设置颜色和透明度
            ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha})`;
            
            // 绘制粒子
            ctx.beginPath();
            ctx.arc(
                p.x * cellSize,
                p.y * cellSize,
                p.radius * cellSize / 3,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }
    },
    
    // 清除所有粒子
    clear() {
        this.particles = [];
    }
};

    
    // 更新动画状态
function updateAnimations(progress) {
    // 计算每帧的时间差
    const deltaTime = gameState.lastFrameTime ? Date.now() - gameState.lastFrameTime : 16;
    
    // 更新蛇的平滑移动 - 增加插值系数使移动更丝滑
    for (let i = 0; i < gameState.snakeInterpolated.length; i++) {
        if (i < gameState.snake.length) {
            const segment = gameState.snakeInterpolated[i];
            if (segment) {
                // 修改平滑系数从0.3到0.5，使移动更流畅
                segment.displayX += (gameState.snake[i].x - segment.displayX) * 0.5;
                segment.displayY += (gameState.snake[i].y - segment.displayY) * 0.5;
            }
        }
    }
    
    // 确保插值数组大小与蛇身一致
    while (gameState.snakeInterpolated.length < gameState.snake.length) {
        const last = gameState.snake[gameState.snakeInterpolated.length];
        gameState.snakeInterpolated.push({
            displayX: last.x,
            displayY: last.y
        });
    }
    
    // 更新粒子效果
    if (settings.particlesEnabled) {
        // 更新轨迹透明度
        gameState.trail.forEach(point => {
            if (point.alpha) point.alpha *= 0.95;
        });
        
        // 移除透明度太低的轨迹点
        gameState.trail = gameState.trail.filter(point => point.alpha > 0.1);
        
        // 更新粒子位置和透明度
        gameState.particles.forEach(particle => {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.radius *= 0.96;
            particle.alpha *= 0.96;
        });
        
        // 优化：限制粒子数量，防止过多粒子影响性能
        if (gameState.particles.length > 100) {
            gameState.particles.length = 100;
        }
        
        // 移除过小或过透明的粒子
        gameState.particles = gameState.particles.filter(
            particle => particle.alpha > 0.1 && particle.radius > 0.1
        );
    }
    
    // 更新粒子系统
    particleSystem.update(progress);
    
    // 如果玩家有能力激活，创建环绕效果
    if (gameState.powerUpActive && settings.particlesEnabled) {
        if (Math.random() > 0.7) { // 30%概率生成粒子，减少过多生成
            particleSystem.createPowerUpEffect(gameState.snake, gameState.powerUpType);
        }
    }
    
    // 为蛇的移动创建尾迹（只对头部）
    if (gameState.snake.length > 0 && settings.particlesEnabled) {
        const head = gameState.snake[0];
        const color = gameState.powerUpActive ? 
            (gameState.powerUpType === 'phase' ? '#00E5FF' : '#E040FB') : 
            '#00E676';
        particleSystem.createTrail(head.x, head.y, color, gameState.direction);
    }
   
// 更新分数翻倍剩余时间
if (gameState.scoreMultiplierActive && gameState.scoreMultiplierTimeLeft > 0) {
    gameState.scoreMultiplierTimeLeft -= deltaTime;
    // 更新显示（如果在单人游戏中）
    if (!isMultiplayerGame) {
        updateScoreMultiplierDisplay();
    }
    
    if (gameState.scoreMultiplierTimeLeft <= 0) {
        gameState.scoreMultiplierActive = false;
        
        // 隐藏指示器
        document.getElementById('power-up-indicator').className = '';
        updateScoreMultiplierDisplay(); // 移除显示
    }
}

// 更新食物动画
if (gameState.food) {
    gameState.food.pulsePhase = ((gameState.food.pulsePhase || 0) + 0.05) % (Math.PI * 2);
}
}

// 检测设备类型
function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
           window.innerWidth <= 768;
}

// 根据设备类型显示相应的控制设置
function showControlSettings() {
    const isMobile = isMobileDevice();
    document.getElementById('mobile-controls-group').style.display = isMobile ? 'block' : 'none';
    document.getElementById('keyboard-controls-group').style.display = isMobile ? 'none' : 'block';
}

// 初始化控制设置
function initControlSettings() {
    showControlSettings();
    
    // 加载存储的控制设置到UI - 修改默认选中状态
    document.getElementById('control-buttons').checked = settings.controlType === 'buttons';
    document.getElementById('control-joystick').checked = settings.controlType === 'joystick';
    document.getElementById('control-size-slider').value = settings.controlSize * 100;
    document.getElementById('control-size-value').textContent = `${Math.round(settings.controlSize * 100)}%`;
    document.getElementById('control-position').value = settings.controlPosition;
    
    // 更新键盘绑定显示
    updateKeyBindingsDisplay();
    
    // 设置键盘绑定输入框事件
    setupKeyBindingInputs();
    
    // 立即应用控制设置
    applyControlSettings();
    
    console.log('控制设置已初始化，类型:', settings.controlType, '大小:', settings.controlSize, '位置:', settings.controlPosition);
}


// 更新键盘绑定显示
function updateKeyBindingsDisplay() {
    for (const direction in settings.keyBindings) {
        const input = document.getElementById(`key-${direction}`);
        if (input) {
            input.value = formatKeyBindings(settings.keyBindings[direction]);
        }
    }
}

// 格式化按键绑定显示
function formatKeyBindings(keys) {
    return keys.map(key => {
        if (key === ' ') return 'Space';
        if (key === 'ArrowUp') return '↑';
        if (key === 'ArrowDown') return '↓';
        if (key === 'ArrowLeft') return '←';
        if (key === 'ArrowRight') return '→';
        return key;
    }).join(', ');
}

// 设置键盘绑定输入框事件
function setupKeyBindingInputs() {
    const keyInputs = document.querySelectorAll('.key-binding input');
    keyInputs.forEach(input => {
        input.addEventListener('click', function() {
            this.value = '按下任意键...';
            this.classList.add('listening');
        });
        
        input.addEventListener('keydown', function(e) {
            e.preventDefault();
            if (this.classList.contains('listening')) {
                const direction = this.dataset.direction;
                const key = e.key;
                
                // 更新键绑定
                settings.keyBindings[direction] = [key];
                this.value = formatKeyBindings([key]);
                this.classList.remove('listening');
            }
        });
    });
    
    // 重置按钮事件
    const resetButtons = document.querySelectorAll('.reset-key');
    resetButtons.forEach(button => {
        button.addEventListener('click', function() {
            const direction = this.dataset.direction;
            const defaultBindings = getDefaultKeyBindings()[direction];
            settings.keyBindings[direction] = defaultBindings;
            
            const input = document.getElementById(`key-${direction}`);
            input.value = formatKeyBindings(defaultBindings);
            input.classList.remove('listening');
        });
    });
}

// 获取默认键盘绑定
function getDefaultKeyBindings() {
    return {
        up: ['ArrowUp', 'w', 'W'],
        down: ['ArrowDown', 's', 'S'],
        left: ['ArrowLeft', 'a', 'A'],
        right: ['ArrowRight', 'd', 'D'],
        pause: [' ', 'p', 'P']
    };
}

// 应用控制设置
function applyControlSettings() {
    const isMobile = isMobileDevice();
    console.log('应用控制设置，当前控制类型:', settings.controlType);
    
    // 应用移动设备控制设置
    if (isMobile) {
        // 获取控制元素
        const controlButtons = document.getElementById('controls');
        const joystickContainer = document.getElementById('joystick-container');
        
        if (settings.controlType === 'joystick') {
            // 使用摇杆控制
            console.log('启用摇杆控制，大小设置为:', settings.controlSize, '位置设置为:', settings.controlPosition);
            controlButtons.style.display = 'none';
            joystickContainer.style.display = 'block';
            
            // 应用摇杆大小
            const size = 150 * settings.controlSize;
            joystickContainer.style.width = `${size}px`;
            joystickContainer.style.height = `${size}px`;
            
            // 直接设置摇杆位置而不是使用类，避免CSS特异性问题
            // 首先重置所有位置相关样式
            joystickContainer.style.left = '';
            joystickContainer.style.right = '';
            joystickContainer.style.transform = '';
            
            // 然后根据设置应用相应的位置样式
            if (settings.controlPosition === 'left') {
                joystickContainer.style.left = '20px';
                joystickContainer.style.transform = 'translateX(0)';
            } else if (settings.controlPosition === 'right') {
                joystickContainer.style.left = 'auto';
                joystickContainer.style.right = '20px';
                joystickContainer.style.transform = 'translateX(0)';
            } else {
                joystickContainer.style.left = '50%';
                joystickContainer.style.transform = 'translateX(-50%)';
            }
            
            // 重置摇杆位置
            const joystickStick = document.getElementById('joystick-stick');
            if (joystickStick) {
                joystickStick.style.left = '50%';
                joystickStick.style.top = '50%';
                joystickStick.style.transform = 'translate(-50%, -50%)';
            }
            
            // 设置摇杆
            setTimeout(setupJoystick, 100); // 延时确保DOM已更新
        } else {
            // 使用按钮控制
            console.log('启用按钮控制，大小设置为:', settings.controlSize);
            controlButtons.style.display = 'grid';
            joystickContainer.style.display = 'none';
            
            // 应用按钮大小
            const size = 180 * settings.controlSize;
            controlButtons.style.width = `${size}px`;
            controlButtons.style.height = `${size}px`;
            
            // 应用按钮位置
            if (settings.controlPosition === 'left') {
                controlButtons.style.marginLeft = '20px';
                controlButtons.style.marginRight = 'auto';
            } else if (settings.controlPosition === 'right') {
                controlButtons.style.marginLeft = 'auto';
                controlButtons.style.marginRight = '20px';
            } else {
                controlButtons.style.marginLeft = 'auto';
                controlButtons.style.marginRight = 'auto';
            }
        }
    } else {
        // 桌面设备只使用键盘控制
        document.getElementById('controls').style.display = 'none';
        document.getElementById('joystick-container').style.display = 'none';
    }
}


// 设置虚拟摇杆 - 改进流畅度版本
function setupJoystick() {
    const joystickBase = document.getElementById('joystick-base');
    const joystickStick = document.getElementById('joystick-stick');
    
    let isDragging = false;
    let currentDirection = null;
    let timer = null;
    
    // 获取基础位置
    const baseRect = joystickBase.getBoundingClientRect();
    const centerX = baseRect.width / 2;
    const centerY = baseRect.height / 2;
    
    // 处理触摸/鼠标事件
    const handleStart = (e) => {
        e.preventDefault();
        isDragging = true;
        joystickStick.style.transition = 'none'; // 移除过渡效果以实现即时响应
        handleMove(e);
    };
    
    const handleMove = (e) => {
        if (!isDragging) return;
        
        const point = e.type.includes('touch') ? 
            e.touches[0] : e;
        
        const rect = joystickBase.getBoundingClientRect();
        const x = point.clientX - rect.left;
        const y = point.clientY - rect.top;
        
        // 计算与中心的距离
        const deltaX = x - centerX;
        const deltaY = y - centerY;
        const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), centerX);
        const angle = Math.atan2(deltaY, deltaX);
        
        // 移动摇杆 - 平滑跟随手指
        const stickX = centerX + Math.cos(angle) * distance;
        const stickY = centerY + Math.sin(angle) * distance;
        
        joystickStick.style.left = `${stickX}px`;
        joystickStick.style.top = `${stickY}px`;
        
        // 适中的死区 - 35%
        const deadZone = centerX * 0.35;
        
        // 确定方向，超过死区就可以触发
        let newDirection = null;
        if (distance > deadZone) {
            // 根据角度确定方向
            if (angle > -Math.PI/4 && angle < Math.PI/4) {
                newDirection = 'right';
                joystickStick.style.backgroundColor = 'rgba(255, 100, 100, 0.7)';
            }
            else if (angle >= Math.PI/4 && angle < 3*Math.PI/4) {
                newDirection = 'down';
                joystickStick.style.backgroundColor = 'rgba(100, 100, 255, 0.7)';
            }
            else if (angle >= 3*Math.PI/4 || angle < -3*Math.PI/4) {
                newDirection = 'left';
                joystickStick.style.backgroundColor = 'rgba(100, 255, 100, 0.7)';
            }
            else {
                newDirection = 'up';
                joystickStick.style.backgroundColor = 'rgba(255, 255, 100, 0.7)';
            }
            
            // 只有当方向真正改变时才更新
            if (newDirection !== currentDirection) {
                // 清除之前的定时发送
                if (timer) {
                    clearInterval(timer);
                    timer = null;
                }
                
                // 更新当前方向
                currentDirection = newDirection;
                
                // 立即发送新方向
                changeDirectionMultiplayer(currentDirection);
                
                // 设置较短间隔的定时发送，确保响应及时
                timer = setInterval(() => {
                    changeDirectionMultiplayer(currentDirection);
                }, 100);
            }
        } else {
            // 在死区内
            joystickStick.style.backgroundColor = 'rgba(0, 255, 150, 0.6)';
        }
    };
    
    const handleEnd = () => {
        isDragging = false;
        currentDirection = null;
        
        // 重置摇杆位置，添加过渡效果
        joystickStick.style.transition = 'all 0.2s ease';
        joystickStick.style.left = '50%';
        joystickStick.style.top = '50%';
        joystickStick.style.transform = 'translate(-50%, -50%)';
        joystickStick.style.backgroundColor = 'rgba(0, 255, 150, 0.6)';
        
        // 清除定时器
        if (timer) {
            clearInterval(timer);
            timer = null;
        }
    };
    
    // 先清除可能存在的旧事件处理器
    joystickBase.removeEventListener('mousedown', handleStart);
    document.removeEventListener('mousemove', handleMove);
    document.removeEventListener('mouseup', handleEnd);
    joystickBase.removeEventListener('touchstart', handleStart);
    document.removeEventListener('touchmove', handleMove);
    document.removeEventListener('touchend', handleEnd);
    document.removeEventListener('touchcancel', handleEnd);
    
    // 添加触摸和鼠标事件
    joystickBase.addEventListener('mousedown', handleStart);
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleEnd);
    
    joystickBase.addEventListener('touchstart', handleStart, { passive: false });
    document.addEventListener('touchmove', handleMove, { passive: false });
    document.addEventListener('touchend', handleEnd);
    document.addEventListener('touchcancel', handleEnd);
    
    console.log('虚拟摇杆已设置完成，提升了流畅度和响应性');
}




// 保存设置
function saveSettings() {
    // 获取控制设置
    settings.controlType = document.getElementById('control-buttons').checked ? 'buttons' : 'joystick';
    settings.controlSize = parseInt(document.getElementById('control-size-slider').value) / 100;
    settings.controlPosition = document.getElementById('control-position').value;
    
    // 其他设置
    settings.soundEnabled = document.getElementById('sound-checkbox').checked;
    settings.particlesEnabled = document.getElementById('particles-checkbox').checked;
    settings.gridEnabled = document.getElementById('grid-checkbox').checked;
    settings.speedMultiplier = parseInt(document.getElementById('speed-slider').value) / 10;
    
    // 输出设置以便调试
    console.log('保存设置:', {
        controlType: settings.controlType,
        controlSize: settings.controlSize,
        controlPosition: settings.controlPosition
    });
    
    // 保存到本地存储
    const settingsToSave = {
        soundEnabled: settings.soundEnabled,
        particlesEnabled: settings.particlesEnabled,
        gridEnabled: settings.gridEnabled,
        speedMultiplier: settings.speedMultiplier,
        controlType: settings.controlType,
        controlSize: settings.controlSize,
        controlPosition: settings.controlPosition,
        keyBindings: settings.keyBindings
    };
    
    localStorage.setItem('snakeSettings', JSON.stringify(settingsToSave));
    
    // 立即应用控制设置
    applyControlSettings();
}


// 修改loadSettings函数来加载控制设置
function loadSettings() {
    const savedSettings = localStorage.getItem('snakeSettings');
    if (savedSettings) {
        const parsed = JSON.parse(savedSettings);
        
        // 更新设置
        settings.soundEnabled = parsed.soundEnabled !== undefined ? parsed.soundEnabled : true;
        settings.particlesEnabled = parsed.particlesEnabled !== undefined ? parsed.particlesEnabled : true;
        settings.gridEnabled = parsed.gridEnabled !== undefined ? parsed.gridEnabled : true;
        settings.speedMultiplier = parsed.speedMultiplier || 1.0;
        
        // 加载控制设置
        settings.controlType = parsed.controlType || 'buttons';  // 默认为按钮控制
        settings.controlSize = parsed.controlSize !== undefined ? parsed.controlSize : 1.0;  // 默认为100%
        settings.controlPosition = parsed.controlPosition || 'center';  // 默认为居中
        
        if (parsed.keyBindings) settings.keyBindings = parsed.keyBindings;
        
        // 更新UI
        document.getElementById('sound-checkbox').checked = settings.soundEnabled;
        document.getElementById('particles-checkbox').checked = settings.particlesEnabled;
        document.getElementById('grid-checkbox').checked = settings.gridEnabled;
        document.getElementById('speed-slider').value = settings.speedMultiplier * 10;
        document.getElementById('speed-value').textContent = settings.speedMultiplier * 10;
        
        console.log('已加载设置，控制类型:', settings.controlType, '大小:', settings.controlSize, '位置:', settings.controlPosition);
    }
    
    // 加载高分
    const highScore = localStorage.getItem('snakeHighScore');
    if (highScore) {
        gameState.highScore = parseInt(highScore);
        document.getElementById('high-score').textContent = gameState.highScore;
    }
    
    // 初始化控制设置并应用
    initControlSettings();
}

// 修改键盘事件处理
function setupKeyboardControls() {
    document.addEventListener('keydown', (e) => {
        if (!gameState.isPlaying) return;
        
        // 检查按键是否匹配任何方向
        for (const direction in settings.keyBindings) {
            if (settings.keyBindings[direction].includes(e.key)) {
                if (direction === 'pause') {
                    if (!isMultiplayerGame) {
                        togglePause();
                    }
                } else {
                    changeDirectionMultiplayer(direction);
                }
                break;
            }
        }
    });
}

// 设置控制事件监听
function setupControlEvents() {
    // 控制大小滑块实时更新
    document.getElementById('control-size-slider').addEventListener('input', function() {
        document.getElementById('control-size-value').textContent = `${this.value}%`;
        
        // 实时更新大小
        settings.controlSize = parseInt(this.value) / 100;
        applyControlSettings();
    });
    
    // 控制类型切换事件
    document.getElementById('control-buttons').addEventListener('change', function() {
        if (this.checked) {
            console.log('按钮控制被选中');
            settings.controlType = 'buttons';
            applyControlSettings();
        }
    });
    
    document.getElementById('control-joystick').addEventListener('change', function() {
        if (this.checked) {
            console.log('摇杆控制被选中');
            settings.controlType = 'joystick';
            applyControlSettings();
        }
    });
    
    // 控制位置切换事件
    document.getElementById('control-position').addEventListener('change', function() {
        console.log('位置改变为:', this.value);
        settings.controlPosition = this.value;
        applyControlSettings();
    });
}

    
    // ============== 绘制函数 ==============
    function draw() {
        // 清空画布
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 绘制背景网格
        if (settings.gridEnabled) {
            drawGrid();
        }
        
        // 绘制轨迹和粒子
        if (settings.particlesEnabled) {
            particleSystem.draw(ctx, cellSize);
        }
        
        // 绘制障碍物
        drawObstacles();
        
        // 绘制食物
        drawFood();
        
        // 绘制蛇
        drawSnake();
        
        // 绘制能力特效
        if (gameState.powerUpActive) {
            drawPowerUpEffect();
        }
    }
    
    // 绘制网格 - 确保准确匹配网格大小
function drawGrid() {
    ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
    ctx.lineWidth = 0.5;
    
    // 绘制垂直和水平线
    for (let i = 0; i <= settings.gridSize; i++) {
        // 垂直线
        ctx.beginPath();
        ctx.moveTo(i * cellSize, 0);
        ctx.lineTo(i * cellSize, canvas.height);
        ctx.stroke();
        
        // 水平线
        ctx.beginPath();
        ctx.moveTo(0, i * cellSize);
        ctx.lineTo(canvas.width, i * cellSize);
        ctx.stroke();
    }
    
    // 绘制边界以突出显示游戏区域
    ctx.strokeStyle = 'rgba(0, 255, 150, 0.3)';
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
}

    
    // 绘制移动轨迹
    function drawTrail() {
        gameState.trail.forEach(point => {
            if (!point.alpha) return;
            
            ctx.fillStyle = `rgba(0, 255, 150, ${point.alpha * 0.3})`;
            ctx.fillRect(
                point.x * cellSize,
                point.y * cellSize,
                cellSize,
                cellSize
            );
        });
    }
    
    // 绘制粒子效果
    function drawParticles() {
        gameState.particles.forEach(particle => {
            ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.alpha})`;
            ctx.beginPath();
            ctx.arc(
                particle.x * cellSize,
                particle.y * cellSize,
                particle.radius * cellSize / 3,
                0,
                Math.PI * 2
            );
            ctx.fill();
        });
    }
    
    // 绘制障碍物
    function drawObstacles() {
    gameState.obstacles.forEach(obstacle => {
        const padding = cellSize * 0.1;
        const x = obstacle.x * cellSize + padding;
        const y = obstacle.y * cellSize + padding;
        const size = cellSize - padding * 2;
        
        // 添加发光效果
        ctx.shadowColor = '#ff0066';
        ctx.shadowBlur = 10;
        
        // 绘制障碍物主体
        ctx.fillStyle = '#ad1457';
        ctx.fillRect(x, y, size, size);
        
        // 绘制障碍物图案 (警告标志)
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath();
        
        // 三角形警告标志
        ctx.moveTo(x + size/2, y + size/4);
        ctx.lineTo(x + size/4, y + size*3/4);
        ctx.lineTo(x + size*3/4, y + size*3/4);
        ctx.closePath();
        ctx.fill();
        
        // 内部感叹号
        ctx.fillStyle = '#ad1457';
        ctx.fillRect(x + size/2 - size/10, y + size/2 - size/10, size/5, size/5);
        ctx.fillRect(x + size/2 - size/10, y + size*2/3 - size/10, size/5, size/5);
        
        // 重置阴影
        ctx.shadowBlur = 0;
    });
}

    
    // 绘制食物
    function drawFood() {
        if (!gameState.food) return;
        
        const food = gameState.food;
        const foodInfo = foodTypes[food.type];
        
        // 计算脉动效果
        const scale = 1 + Math.sin(food.pulsePhase || 0) * 0.1;
        const centerX = (food.x + 0.5) * cellSize;
        const centerY = (food.y + 0.5) * cellSize;
        const radius = cellSize * 0.4 * scale;
        
        // 绘制食物
        ctx.save();
        
        // 闪光效果
        ctx.shadowColor = foodInfo.color;
        ctx.shadowBlur = 10;
        
        // 主体
        ctx.fillStyle = foodInfo.color;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // 边框
        ctx.strokeStyle = foodInfo.borderColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // 内部装饰
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.arc(centerX - radius * 0.3, centerY - radius * 0.3, radius * 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
// 绘制蛇
function drawSnake() {
    // 确保有足够的插值节点
    while (gameState.snakeInterpolated.length < gameState.snake.length) {
        const lastIdx = gameState.snakeInterpolated.length;
        const lastPos = gameState.snake[lastIdx];
        gameState.snakeInterpolated.push({
            displayX: lastPos.x,
            displayY: lastPos.y
        });
    }
    
    // 绘制蛇身体
    gameState.snakeInterpolated.forEach((segment, index) => {
        if (index >= gameState.snake.length) return;
        
        const isHead = index === 0;
        
        // 计算颜色
        let color;
        if (isHead) {
            color = gameState.powerUpActive ? 
                (gameState.powerUpType === 'phase' ? '#00E5FF' : '#E040FB') : 
                '#00E676';
        } else {
            // 身体颜色渐变
            const hue = gameState.powerUpActive ? 
                (gameState.powerUpType === 'phase' ? 180 : 280) : 
                140 - (index / gameState.snake.length * 40);
            const saturation = 80 - (index / gameState.snake.length * 30);
            const lightness = 60 - (index / gameState.snake.length * 20);
            color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        
        // 绘制身体段
        const x = segment.displayX * cellSize;
        const y = segment.displayY * cellSize;
        const size = cellSize * 0.9;
        const radius = isHead ? cellSize * 0.45 : cellSize * 0.35;
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(
            x + cellSize / 2,
            y + cellSize / 2,
            radius,
            0,
            Math.PI * 2
        );
        ctx.fill();
        
        // 如果是头部，添加眼睛
        if (isHead) {
            drawSnakeEyes(segment);
        }
    });
}
    
    // 绘制蛇的眼睛
    function drawSnakeEyes(head) {
        const eyeSize = cellSize * 0.15;
        const eyeDistance = cellSize * 0.18;
        
        // 根据方向调整眼睛位置
        let leftEyePos, rightEyePos;
        const centerX = (head.displayX + 0.5) * cellSize;
        const centerY = (head.displayY + 0.5) * cellSize;
        
        switch (gameState.direction) {
            case 'up':
                leftEyePos = {x: centerX - eyeDistance, y: centerY - eyeDistance};
                rightEyePos = {x: centerX + eyeDistance, y: centerY - eyeDistance};
                break;
            case 'down':
                leftEyePos = {x: centerX - eyeDistance, y: centerY + eyeDistance};
                rightEyePos = {x: centerX + eyeDistance, y: centerY + eyeDistance};
                break;
            case 'left':
                leftEyePos = {x: centerX - eyeDistance, y: centerY - eyeDistance};
                rightEyePos = {x: centerX - eyeDistance, y: centerY + eyeDistance};
                break;
            case 'right':
                leftEyePos = {x: centerX + eyeDistance, y: centerY - eyeDistance};
                rightEyePos = {x: centerX + eyeDistance, y: centerY + eyeDistance};
                break;
        }
        
        // 绘制眼睛
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(leftEyePos.x, leftEyePos.y, eyeSize, 0, Math.PI * 2);
        ctx.arc(rightEyePos.x, rightEyePos.y, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        // 绘制瞳孔
        const pupilOffset = eyeSize * 0.4;
        const pupilSize = eyeSize * 0.6;
        
        // 计算瞳孔位置偏移(根据方向)
        let pupilOffsetX = 0, pupilOffsetY = 0;
        switch (gameState.direction) {
            case 'up': pupilOffsetY = -pupilOffset; break;
            case 'down': pupilOffsetY = pupilOffset; break;
            case 'left': pupilOffsetX = -pupilOffset; break;
            case 'right': pupilOffsetX = pupilOffset; break;
        }
        
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(
            leftEyePos.x + pupilOffsetX, 
            leftEyePos.y + pupilOffsetY, 
            pupilSize, 
            0, 
            Math.PI * 2
        );
        ctx.arc(
            rightEyePos.x + pupilOffsetX, 
            rightEyePos.y + pupilOffsetY, 
            pupilSize, 
            0, 
            Math.PI * 2
        );
        ctx.fill();
    }
    
    // 绘制能力特效
    function drawPowerUpEffect() {
        // 添加全屏覆盖效果
        ctx.fillStyle = gameState.powerUpType === 'phase' ? 
            'rgba(0, 229, 255, 0.1)' : 
            'rgba(224, 64, 251, 0.1)';
        
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 添加边框闪烁效果
        const borderColor = gameState.powerUpType === 'phase' ? 
            'rgba(0, 229, 255, 0.5)' : 
            'rgba(224, 64, 251, 0.5)';
        
        const borderWidth = 4 + Math.sin(Date.now() / 100) * 2;
        
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = borderWidth;
        ctx.strokeRect(
            borderWidth / 2, 
            borderWidth / 2, 
            canvas.width - borderWidth, 
            canvas.height - borderWidth
        );
    }
    
    // ============== 游戏逻辑辅助函数 ==============
    // 生成食物
    function generateFood() {
        // 可用食物类型
        const types = Object.keys(foodTypes);
        
        // 根据游戏进度和难度调整食物类型出现概率
        let typeIndex;
        const rand = Math.random();
        const snakeLength = gameState.snake.length;
        
        if (snakeLength < 10 || rand < 0.5) {
            // 基础食物(红/黄/绿)
            typeIndex = Math.floor(Math.random() * 3);
        } else if (snakeLength < 20 || rand < 0.8) {
            // 蓝色食物(穿墙)
            typeIndex = 3;
        } else {
            // 紫色食物(无敌)
            typeIndex = 4;
        }
        
        const type = types[typeIndex];
        
        // 找到一个不在蛇身体和障碍物上的位置
        let x, y, validPosition = false;
        let attempts = 0;
        const maxAttempts = 100;
        
        while (!validPosition && attempts < maxAttempts) {
            x = Math.floor(Math.random() * settings.gridSize);
            y = Math.floor(Math.random() * settings.gridSize);
            validPosition = true;
            attempts++;
            
            // 检查是否与蛇身体重叠
            for (const segment of gameState.snake) {
                if (segment.x === x && segment.y === y) {
                    validPosition = false;
                    break;
                }
            }
            
            // 检查是否与障碍物重叠
            if (validPosition) {
                for (const obstacle of gameState.obstacles) {
                    if (obstacle.x === x && obstacle.y === y) {
                        validPosition = false;
                        break;
                    }
                }
            }
        }
        
        // 如果找不到有效位置，使用后备方案
        if (!validPosition) {
            // 从网格边缘选择一个位置
            const edge = Math.floor(Math.random() * 4);
            switch (edge) {
                case 0: // 上边缘
                    x = Math.floor(Math.random() * settings.gridSize);
                    y = 0;
                    break;
                case 1: // 右边缘
                    x = settings.gridSize - 1;
                    y = Math.floor(Math.random() * settings.gridSize);
                    break;
                case 2: // 下边缘
                    x = Math.floor(Math.random() * settings.gridSize);
                    y = settings.gridSize - 1;
                    break;
                case 3: // 左边缘
                    x = 0;
                    y = Math.floor(Math.random() * settings.gridSize);
                    break;
            }
        }
        
        // 创建食物
        gameState.food = {
            x,
            y,
            type,
            pulsePhase: 0
        };
        
        // 显示食物信息
        showFoodInfo(type);
    }
    
    // 激活分数翻倍效果
function activateScoreMultiplier(duration) {
    // 清除之前的计时器
    if (scoreMultiplierTimeout) {
        clearTimeout(scoreMultiplierTimeout);
    }
    
    gameState.scoreMultiplierActive = true;
    gameState.scoreMultiplierTimeLeft = duration;
    
    // 显示指示器
    const powerUpIndicator = document.getElementById('power-up-indicator');
    powerUpIndicator.textContent = '分数翻倍激活!';
    powerUpIndicator.className = 'show';
    powerUpIndicator.style.color = '#ffcc00';
    
    // 更新状态显示
    updateScoreMultiplierDisplay();
    
    // 创建更新计时器，每秒更新一次倒计时显示
    const updateInterval = setInterval(() => {
        if (gameState.scoreMultiplierTimeLeft > 0) {
            gameState.scoreMultiplierTimeLeft -= 1000;
            updateScoreMultiplierDisplay();
        } else {
            clearInterval(updateInterval);
        }
    }, 1000);
    
    // 设置计时器结束翻倍效果
    scoreMultiplierTimeout = setTimeout(() => {
        gameState.scoreMultiplierActive = false;
        gameState.scoreMultiplierTimeLeft = 0;
        powerUpIndicator.className = '';
        clearInterval(updateInterval);
        updateScoreMultiplierDisplay(); // 移除显示
    }, duration);
}


    // 添加障碍物
    function addObstacle() {
    // 根据游戏模式决定最大障碍物数量
    let maxObstacles = 10; // 默认
    if (gameState.gameMode === 'challenge') {
        maxObstacles = 20; // 挑战模式更多障碍物
    } else if (gameState.gameMode === 'classic') {
        maxObstacles = 15; // 经典模式适中
    }
    
    if (gameState.obstacles.length >= maxObstacles) return; // 限制障碍物数量
    
    // 找一个不在蛇身体和食物上的位置
    let x, y, validPosition = false;
    let attempts = 0;
    const maxAttempts = 50;
    
    while (!validPosition && attempts < maxAttempts) {
        x = Math.floor(Math.random() * settings.gridSize);
        y = Math.floor(Math.random() * settings.gridSize);
        validPosition = true;
        attempts++;
        
        // 检查是否与蛇身体重叠
        for (const segment of gameState.snake) {
            if (segment.x === x && segment.y === y) {
                validPosition = false;
                break;
            }
        }
        
        // 检查是否与食物重叠
        if (validPosition && gameState.food && gameState.food.x === x && gameState.food.y === y) {
            validPosition = false;
        }
        
        // 检查是否与其他障碍物重叠
        if (validPosition) {
            for (const obstacle of gameState.obstacles) {
                if (obstacle.x === x && obstacle.y === y) {
                    validPosition = false;
                    break;
                }
            }
        }
        
        // 确保新障碍物不会太靠近蛇头
        if (validPosition) {
            const head = gameState.snake[0];
            const distance = Math.abs(head.x - x) + Math.abs(head.y - y);
            // 增加安全距离，避免突然出现在蛇头前
            if (distance < 6) {
                validPosition = false;
            }
        }
    }
    
    if (validPosition) {
        gameState.obstacles.push({x, y});
    }
}

    
    // 激活能力道具
    function activatePowerUp(type, duration) {
        // 清除之前的能力计时器
        if (powerUpTimeout) {
            clearTimeout(powerUpTimeout);
        }
        
        gameState.powerUpActive = true;
        gameState.powerUpType = type;
        
        // 更新能力道具指示器
        const powerUpIndicator = document.getElementById('power-up-indicator');
        powerUpIndicator.textContent = type === 'phase' ? '穿墙能力激活!' : '无敌能力激活!';
        powerUpIndicator.className = 'show';
        
        // 设置能力持续时间
        powerUpTimeout = setTimeout(() => {
            gameState.powerUpActive = false;
            gameState.powerUpType = null;
            powerUpIndicator.className = '';
            
            // 检查是否在穿墙能力结束时卡在墙里
            if (type === 'phase') {
                const head = gameState.snake[0];
                if (head.x < 0 || head.x >= settings.gridSize || 
                    head.y < 0 || head.y >= settings.gridSize) {
                    endGame('collision');
                }
            }
        }, duration);
    }
    
    // 创建食物粒子效果
    function createFoodParticles(x, y, color) {
    // 解析颜色为RGB
    const r = parseInt(color.slice(1, 3), 16);
    const g = parseInt(color.slice(3, 5), 16);
    const b = parseInt(color.slice(5, 7), 16);
    
    // 减少粒子数量从20到15，防止过多的粒子影响性能
    const particleCount = 15;
    
    for (let i = 0; i < particleCount; i++) {
        gameState.particles.push({
            x: x + 0.5,
            y: y + 0.5,
            // 增加粒子速度使效果更明显
            vx: (Math.random() - 0.5) * 0.25,
            vy: (Math.random() - 0.5) * 0.25,
            radius: 0.5 + Math.random() * 0.5,
            alpha: 1,
            color: {r, g, b}
        });
    }
}

    
    // 创建分数弹出效果
    function createScorePopup(x, y, points) {
        const popup = document.createElement('div');
        popup.className = 'score-popup';
        popup.textContent = `+${points}`;
        popup.style.left = `${(x + 0.5) * cellSize}px`;
        popup.style.top = `${(y + 0.5) * cellSize}px`;
        popup.style.color = '#FFEB3B';
        document.getElementById('game-container').appendChild(popup);
        
        // 删除元素
        setTimeout(() => {
            popup.remove();
        }, 800);
    }
    
    // 创建连击弹出效果
    function createComboPopup(x, y) {
        const popup = document.createElement('div');
        popup.className = 'combo-popup';
        popup.textContent = `连击 x${gameState.combo}!`;
        popup.style.left = `${(x + 0.5) * cellSize}px`;
        popup.style.top = `${(y - 0.5) * cellSize}px`;
        
        // 根据连击数量改变颜色
        let color;
        if (gameState.combo > 5) color = '#FF9100';
        else if (gameState.combo > 3) color = '#FFEA00';
        else color = '#76FF03';
        
        popup.style.color = color;
        document.getElementById('game-container').appendChild(popup);
        
        // 删除元素
        setTimeout(() => {
            popup.remove();
        }, 1000);
    }
    
    // 显示食物信息
    function showFoodInfo(type) {
        const foodInfo = document.getElementById('food-info');
        if (foodInfoTimeout) {
            clearTimeout(foodInfoTimeout);
        }
        
        const info = foodTypes[type];
        foodInfo.textContent = `${info.name}: ${info.effect} (+${info.points}分)`;
        foodInfo.style.color = info.color;
        foodInfo.className = 'show';
        
        foodInfoTimeout = setTimeout(() => {
            foodInfo.className = '';
        }, 3000);
    }
    
    // 更新分数显示
    function updateScoreDisplay() {
        document.getElementById('score').textContent = gameState.score;
        document.getElementById('high-score').textContent = gameState.highScore;
    }
    // 更新分数倍率显示
function updateScoreMultiplierDisplay() {
    const speedDisplay = document.getElementById('speed-display');
    const statusDisplay = document.getElementById('status-display');
    
    // 移除可能存在的旧显示
    const existingMultiplier = document.getElementById('score-multiplier-display');
    if (existingMultiplier) {
        existingMultiplier.remove();
    }
    
    // 如果分数翻倍处于激活状态，添加指示器
    if (gameState.scoreMultiplierActive) {
        const multiplierDisplay = document.createElement('div');
        multiplierDisplay.id = 'score-multiplier-display';
        multiplierDisplay.textContent = `分数: 双倍 (${Math.ceil(gameState.scoreMultiplierTimeLeft/1000)}秒)`;
        multiplierDisplay.style.color = '#ffcc00';
        multiplierDisplay.style.fontWeight = 'bold';
        statusDisplay.appendChild(multiplierDisplay);
    }
}

    // 更新速度显示
    function updateSpeedDisplay() {
        let speedText = '正常';
        if (gameState.speed < settings.baseSpeed - 20) speedText = '快速';
        if (gameState.speed < settings.baseSpeed - 50) speedText = '极快';
        if (gameState.speed > settings.baseSpeed + 20) speedText = '慢速';
        document.getElementById('speed-display').textContent = `速度: ${speedText}`;
    }
    
    // 结束游戏
    function endGame(reason) {
        gameState.isPlaying = false;
        gameState.isGameOver = true;
        
        // 更新游戏记录
    updateGameRecord('score', { mode: gameState.gameMode, score: gameState.score });
        
        // 根据结束原因不同，显示不同的信息
        const gameOverTitle = document.getElementById('game-over-title');
        const finalScore = document.getElementById('final-score');
        const finalLength = document.getElementById('final-length');
        const gameOverMessage = document.getElementById('game-over-message');
        
        if (reason === 'victory') {
            gameOverTitle.textContent = '挑战成功！';
            
            if (settings.soundEnabled) {
                sounds.win.play();
            }
        } else {
            gameOverTitle.textContent = '游戏结束';
            
            if (settings.soundEnabled) {
                sounds.gameOver.play();
            }
        }
        
        finalScore.textContent = `最终分数: ${gameState.score}`;
        finalLength.textContent = `蛇的长度: ${gameState.snake.length}`;
        
        // 根据分数给出评价
        let message = '';
        if (gameState.score > 300) message = '太厉害了！你是蛇神！';
        else if (gameState.score > 200) message = '真棒！蛇技高超！';
        else if (gameState.score > 100) message = '不错！相当熟练！';
        else message = '再接再厉，你能做得更好！';
        
        gameOverMessage.textContent = message;
        
        // 更新高分记录
        if (gameState.score > gameState.highScore) {
            gameState.highScore = gameState.score;
            localStorage.setItem('snakeHighScore', gameState.highScore);
            document.getElementById('high-score').textContent = gameState.highScore;
        }
        
        // 显示游戏结束菜单
        document.getElementById('game-over').style.display = 'flex';
        
        // 清除能力道具计时器
        if (powerUpTimeout) {
            clearTimeout(powerUpTimeout);
            powerUpTimeout = null;
        }
        
        // 停止游戏循环
        cancelAnimationFrame(gameState.animationFrame);
        
        // 恢复3D旋转效果
        canvas.classList.add('rotate-effect');
    }
    
    // ============== 事件处理 ==============
    // 改变方向
    function changeDirection(newDirection) {
        // 防止反方向移动
        if ((gameState.direction === 'up' && newDirection === 'down') ||
            (gameState.direction === 'down' && newDirection === 'up') ||
            (gameState.direction === 'left' && newDirection === 'right') ||
            (gameState.direction === 'right' && newDirection === 'left')) {
            return;
        }
        
        gameState.nextDirection = newDirection;
    }
    
    // 启动游戏
    function startGame(mode) {
    // 设置游戏模式
    gameState.gameMode = mode;
    
    // 更新游戏记录
    updateGameRecord('mode', { mode: mode });
    updateGameRecord('singleplayer', {});
    
    // 确保不是多人游戏
    isMultiplayerGame = false;
    
    // 隐藏所有菜单
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('settings-menu').style.display = 'none';
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('pause-menu').style.display = 'none';
    
    // 隐藏多人游戏UI
    document.getElementById('multiplayer-status').style.display = 'none';
    document.getElementById('multiplayer-chat').style.display = 'none';
    document.getElementById('multiplayer-controls').style.display = 'none';
    
    // 确保单人游戏控制可见
    resetControls();
    // 确保状态显示可见
document.getElementById('status-display').style.display = 'flex';

    // 移除可能存在的重生按钮
    hideRespawnOption();
    
    // 初始化游戏
    initGame();
    
    // 确保多人游戏返回按钮功能正常
    ensureBackButtonWorks();
    
    // 标记游戏开始
    gameState.isPlaying = true;
    gameState.isPaused = false;
    gameState.lastFrameTime = 0;
    gameState.accumulatedTime = 0;
    particleSystem.clear();
    
    // 开始游戏循环
    if (gameState.animationFrame) {
        cancelAnimationFrame(gameState.animationFrame);
    }
    gameState.animationFrame = requestAnimationFrame(gameLoop);
}

    
    // 暂停游戏
    function togglePause() {
        if (gameState.isGameOver) return;
        
        gameState.isPaused = !gameState.isPaused;
        
        if (gameState.isPaused) {
            document.getElementById('pause-menu').style.display = 'flex';
        } else {
            document.getElementById('pause-menu').style.display = 'none';
            gameState.lastFrameTime = 0; // 重置帧时间，避免一次性大更新
        }
    }
    
// 获取模式文本
function getModeText(mode) {
    switch (mode) {
        case 'classic': return '经典';
        case 'challenge': return '夺冠';
        default: return '经典';
    }
}

function getModeText() {
    switch (gameState.gameMode) {
        case 'classic': return '经典';
        case 'challenge': return '夺冠';
        default: return '经典';
    }
}

    
    // ============== 初始化 ==============
    
    
    // 保存设置
    function saveSettings() {
        const settingsToSave = {
            soundEnabled: settings.soundEnabled,
            particlesEnabled: settings.particlesEnabled,
            gridEnabled: settings.gridEnabled,
            speedMultiplier: settings.speedMultiplier
        };
        
        localStorage.setItem('snakeSettings', JSON.stringify(settingsToSave));
    }
    
// 设置事件监听器
function setupEventListeners() {
    // 规则按钮事件
    const rulesBtn = document.getElementById('rules-btn');
if (rulesBtn) {
    rulesBtn.addEventListener('click', () => {
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('rules-menu').style.display = 'flex';
        
        // 添加这一行来设置模式信息按钮
        setTimeout(setupModeInfoButtons, 100); // 使用延时确保DOM已完全加载
    });
}


    const rulesBackBtn = document.getElementById('rules-back-btn');
    if (rulesBackBtn) {
        rulesBackBtn.addEventListener('click', () => {
            document.getElementById('rules-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        });
    }
    
    // 游戏模式按钮
    const classicBtn = document.getElementById('classic-btn');
    if (classicBtn) {
        classicBtn.addEventListener('click', () => startGame('classic'));
    }
    
    const challengeBtn = document.getElementById('challenge-btn');
    if (challengeBtn) {
        challengeBtn.addEventListener('click', () => startGame('challenge'));
    }
    
    // 多人游戏按钮 - 确保这段代码正确执行
    const multiplayerBtn = document.getElementById('multiplayer-btn');
    if (multiplayerBtn) {
        // 移除可能存在的旧事件监听器
        const newMultiplayerBtn = multiplayerBtn.cloneNode(true);
        if (multiplayerBtn.parentNode) {
            multiplayerBtn.parentNode.replaceChild(newMultiplayerBtn, multiplayerBtn);
        }
        
        // 添加新的事件监听器
        newMultiplayerBtn.addEventListener('click', () => {
            console.log('点击多人游戏按钮');
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('multiplayer-menu').style.display = 'flex';
        });
        console.log('多人游戏按钮事件监听器已设置');
    } else {
        console.error('找不到多人游戏按钮元素');
    }
    
    // 游戏结束菜单按钮
    const restartBtn = document.getElementById('restart-btn');
    if (restartBtn) {
        restartBtn.addEventListener('click', () => {
            if (isMultiplayerGame) {
                document.getElementById('game-over').style.display = 'none';
                resetMultiplayerGameState();
                document.getElementById('game-lobby').style.display = 'flex';
                if (isHost) {
                    document.getElementById('start-game-btn').style.display = 'block';
                }
            } else {
                startGame(gameState.gameMode);
            }
        });
    }
    
    const menuBtn = document.getElementById('menu-btn');
    if (menuBtn) {
        menuBtn.addEventListener('click', () => {
            if (isMultiplayerGame) {
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('game-lobby').style.display = 'flex';
            } else {
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('main-menu').style.display = 'flex';
            }
        });
    }
    
    // 暂停相关按钮
    const pauseBtn = document.getElementById('pause-btn');
    if (pauseBtn) {
        pauseBtn.addEventListener('click', () => {
            if (!isMultiplayerGame) {
                togglePause();
            } else {
                const pauseMenu = document.getElementById('pause-menu');
                const pauseTitle = pauseMenu.querySelector('h2');
                const resumeBtn = document.getElementById('resume-btn');
                const pauseMenuBtn = document.getElementById('pause-menu-btn');
                
                pauseTitle.textContent = '游戏信息';
                resumeBtn.textContent = '继续游戏';
                pauseMenuBtn.textContent = '返回主菜单';
                
                pauseMenu.style.display = 'flex';
                document.getElementById('multiplayer-chat').classList.add('show');
                gameState.isPaused = true;
            }
        });
    }
    
    const resumeBtn = document.getElementById('resume-btn');
    if (resumeBtn) {
        resumeBtn.addEventListener('click', () => {
            if (isMultiplayerGame) {
                document.getElementById('pause-menu').style.display = 'none';
                document.getElementById('multiplayer-chat').classList.remove('show');
                gameState.isPaused = false;
            } else {
                togglePause();
            }
        });
    }
    
    const pauseMenuBtn = document.getElementById('pause-menu-btn');
    if (pauseMenuBtn) {
        pauseMenuBtn.addEventListener('click', () => {
            if (gameState.animationFrame) {
                cancelAnimationFrame(gameState.animationFrame);
                gameState.animationFrame = null;
            }
            
            gameState.isPlaying = false;
            gameState.isPaused = false;
            
            document.getElementById('pause-menu').style.display = 'none';
            
            if (isMultiplayerGame) {
                resetMultiplayerGame();
            } else {
                document.getElementById('main-menu').style.display = 'flex';
                canvas.classList.add('rotate-effect');
            }
        });
    }
    
    // 设置菜单按钮
    const settingsBtn = document.getElementById('settings-btn');
    if (settingsBtn) {
        settingsBtn.addEventListener('click', () => {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('settings-menu').style.display = 'flex';
        });
    }
    
    const saveSettingsBtn = document.getElementById('save-settings-btn');
    if (saveSettingsBtn) {
        saveSettingsBtn.addEventListener('click', () => {
            settings.soundEnabled = document.getElementById('sound-checkbox').checked;
            settings.particlesEnabled = document.getElementById('particles-checkbox').checked;
            settings.gridEnabled = document.getElementById('grid-checkbox').checked;
            settings.speedMultiplier = parseInt(document.getElementById('speed-slider').value) / 10;
            
            saveSettings();
            
            document.getElementById('settings-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        });
    }
    
    const settingsMenuBtn = document.getElementById('settings-menu-btn');
    if (settingsMenuBtn) {
        settingsMenuBtn.addEventListener('click', () => {
            document.getElementById('settings-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        });
    }
    
    // 速度滑块更新
    const speedSlider = document.getElementById('speed-slider');
    if (speedSlider) {
        speedSlider.addEventListener('input', function() {
            document.getElementById('speed-value').textContent = this.value;
        });
    }
    
    // 方向控制按钮
    const upBtn = document.getElementById('up-btn');
    const downBtn = document.getElementById('down-btn');
    const leftBtn = document.getElementById('left-btn');
    const rightBtn = document.getElementById('right-btn');
    
    if (upBtn) {
        upBtn.addEventListener('touchstart', () => changeDirectionMultiplayer('up'));
        upBtn.addEventListener('click', () => changeDirectionMultiplayer('up'));
    }
    
    if (downBtn) {
        downBtn.addEventListener('touchstart', () => changeDirectionMultiplayer('down'));
        downBtn.addEventListener('click', () => changeDirectionMultiplayer('down'));
    }
    
    if (leftBtn) {
        leftBtn.addEventListener('touchstart', () => changeDirectionMultiplayer('left'));
        leftBtn.addEventListener('click', () => changeDirectionMultiplayer('left'));
    }
    
    if (rightBtn) {
        rightBtn.addEventListener('touchstart', () => changeDirectionMultiplayer('right'));
        rightBtn.addEventListener('click', () => changeDirectionMultiplayer('right'));
    }
    
    // 键盘控制
    document.addEventListener('keydown', (e) => {
        if (!gameState.isPlaying) return;
        
        switch (e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                changeDirectionMultiplayer('up');
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                changeDirectionMultiplayer('down');
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                changeDirectionMultiplayer('left');
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                changeDirectionMultiplayer('right');
                break;
            case ' ':
            case 'p':
            case 'P':
                if (!isMultiplayerGame) {
                    togglePause();
                }
                break;
        }
    });
    
    // 窗口大小调整
    window.addEventListener('resize', resizeCanvas);
}

    
    let isInitialized = false;

function initialize() {
    if (isInitialized) {
        console.log('游戏已经初始化，跳过重复初始化');
        return;
    }
    
    isInitialized = true;
    console.log('初始化游戏...');
    
    // 初始化游戏记录
    initGameRecords();
    
    // 调整画布大小
    resizeCanvas();
    
    // 加载设置
    loadSettings();
    
    // 设置事件监听器
    setupEventListeners();
    
    // 设置控制事件监听器
    setupControlEvents();
    
    // 设置暂停按钮和暂停菜单
    setupPauseButton();
    setupPauseMenuButton();
    
    // 初始化游戏状态
    initGame();
    
    // 初始化多人游戏功能
    console.log('初始化多人游戏...');
    initializeMultiplayer();
    
    // 直接为HTML中已存在的多人游戏按钮添加事件监听
    const multiplayerBtn = document.getElementById('multiplayer-btn');
    if (multiplayerBtn) {
        multiplayerBtn.addEventListener('click', () => {
            console.log('点击多人游戏按钮');
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('multiplayer-menu').style.display = 'flex';
            
            // 预填上次使用的名称
            if (gameRecords.playerName) {
                document.getElementById('player-name').value = gameRecords.playerName;
            }
        });
        console.log('多人游戏按钮事件已设置');
    } else {
        console.error('找不到多人游戏按钮');
    }
    
    // 设置多人游戏事件监听
    setupMultiplayerEvents();
    
    // 设置方向控制
    setupDirectionControls();
    
    // 绘制初始画面
    draw();
    
    // 应用控制设置
    applyControlSettings();
    
    console.log('游戏初始化完成');
}


// 添加方向控制设置函数
function setupDirectionControls() {
    // 设置方向按钮
    const directionButtons = {
        'up': document.getElementById('up-btn'),
        'down': document.getElementById('down-btn'),
        'left': document.getElementById('left-btn'),
        'right': document.getElementById('right-btn')
    };

    // 为按钮设置事件监听
    for (const direction in directionButtons) {
        const btn = directionButtons[direction];
        if (btn) {
            // 移除原有事件监听器
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            // 添加新的事件监听器
            newBtn.addEventListener('touchstart', () => changeDirectionMultiplayer(direction));
            newBtn.addEventListener('click', () => changeDirectionMultiplayer(direction));
        }
    }

    // 设置键盘控制
    document.addEventListener('keydown', (e) => {
        if (!gameState.isPlaying) return;
        
        switch (e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                changeDirectionMultiplayer('up');
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                changeDirectionMultiplayer('down');
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                changeDirectionMultiplayer('left');
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                changeDirectionMultiplayer('right');
                break;
            case ' ':
            case 'p':
            case 'P':
                if (!isMultiplayerGame) {
                    togglePause();
                }
                break;
        }
    });
}

    

// 修改 DOMContentLoaded 事件处理函数，避免重复绑定事件
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM加载完成，初始化游戏...');
    
    // 确保移除任何现有的模式描述元素
    const existingDescription = document.getElementById('game-mode-description');
    if (existingDescription) {
        existingDescription.remove();
    }
    
    // 添加多人游戏控制按钮容器
    if (!document.getElementById('multiplayer-controls')) {
        const multiplayerControls = document.createElement('div');
        multiplayerControls.id = 'multiplayer-controls';
        document.body.appendChild(multiplayerControls);
    }
    
    // 添加虚拟摇杆容器并设置初始样式
    if (!document.getElementById('joystick-container')) {
        const joystickContainer = document.createElement('div');
        joystickContainer.id = 'joystick-container';
        joystickContainer.style.position = 'absolute';
        joystickContainer.style.bottom = '20px';
        joystickContainer.style.left = '50%';
        joystickContainer.style.transform = 'translateX(-50%)';
        joystickContainer.style.width = '150px';
        joystickContainer.style.height = '150px';
        joystickContainer.style.zIndex = '15';
        joystickContainer.style.display = 'none';
        
        const joystickBase = document.createElement('div');
        joystickBase.id = 'joystick-base';
        
        const joystickStick = document.createElement('div');
        joystickStick.id = 'joystick-stick';
        joystickStick.style.left = '50%';
        joystickStick.style.top = '50%';
        joystickStick.style.transform = 'translate(-50%, -50%)';
        
        joystickBase.appendChild(joystickStick);
        joystickContainer.appendChild(joystickBase);
        document.body.appendChild(joystickContainer);
    }
    
    // 初始化游戏
    initialize();
    
    // 确保控制设置最后被应用，并强制使用摇杆控制
    setTimeout(function() {
        // 确保设置为摇杆控制
        settings.controlType = 'joystick';
        
        // 更新UI以匹配设置
        document.getElementById('control-buttons').checked = false;
        document.getElementById('control-joystick').checked = true;
        
        // 应用控制设置
        applyControlSettings();
        console.log('已应用摇杆控制设置');
    }, 500);
});

</script>
</body>
 </html>



