<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ™ºèƒ½HTMLç¼–è¾‘å™¨ - ç§»åŠ¨ç‰ˆ</title>
    
    <!-- CodeMirror CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/lib/codemirror.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/theme/material-darker.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/addon/hint/show-hint.min.css">

<!-- JSZip -->
<script src="https://fastly.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        :root {
            --primary-color: #2196F3;
            --secondary-color: #FF4081;
            --background-color: #121212;
            --surface-color: #1E1E1E;
            --text-color: #E0E0E0;
            --border-color: #333;
            --success-color: #4CAF50;
            --error-color: #F44336;
            --warning-color: #FF9800;
            --header-height: 56px;
            --bottom-nav-height: 56px;
        }
        
        body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--background-color);
    color: var(--text-color);
    overflow: hidden;
    -webkit-font-smoothing: antialiased;
    -webkit-user-select: text;
    user-select: text;
}
        
        /* å¤´éƒ¨æ  */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 100;
        }
        
        .menu-btn {
            width: 40px;
            height: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.3s;
        }
        
        .menu-btn:active {
            background: rgba(255,255,255,0.1);
        }
        
        .menu-btn span {
            width: 24px;
            height: 2px;
            background: var(--text-color);
            transition: all 0.3s;
        }
        
        .menu-btn.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        
        .menu-btn.active span:nth-child(2) {
            opacity: 0;
        }
        
        .menu-btn.active span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }
        
        .app-title {
            flex: 1;
            font-size: 18px;
            font-weight: 500;
            margin-left: 16px;
        }
        
        .header-actions {
            display: flex;
            gap: 8px;
        }
        
        .icon-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: none;
            color: var(--text-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            transition: background 0.3s;
        }
        
        .icon-btn:active {
            background: rgba(255,255,255,0.1);
        }
        
        /* ä¾§è¾¹æ  */
        .sidebar {
            position: fixed;
            top: 0;
            left: -280px;
            width: 280px;
            height: 100%;
            background: var(--surface-color);
            transition: left 0.3s ease;
            z-index: 200;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }
        
        .sidebar.active {
            left: 0;
        }
        
        .sidebar-header {
            padding: 20px;
            background: var(--primary-color);
            color: white;
        }
        
        .sidebar-header h2 {
            font-size: 20px;
            font-weight: 500;
        }
        
        .sidebar-menu {
            padding: 8px 0;
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            color: var(--text-color);
            text-decoration: none;
            transition: background 0.3s;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 16px;
        }
        
        .menu-item:active {
            background: rgba(255,255,255,0.1);
        }
        
        .menu-item i {
            margin-right: 16px;
            font-size: 20px;
            width: 24px;
            text-align: center;
        }
        
        .menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 8px 0;
        }
        
        /* é®ç½©å±‚ */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            z-index: 150;
        }
        
        .overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        /* ä¸»å†…å®¹åŒº */
        .main-content {
            position: fixed;
            top: var(--header-height);
            left: 0;
            right: 0;
            bottom: var(--bottom-nav-height);
            overflow: hidden;
        }
        
        /* æ ‡ç­¾é¡µå®¹å™¨ */
        .tab-container {
            height: 100%;
            position: relative;
        }
        
        .tab-panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .tab-panel.active {
            opacity: 1;
            visibility: visible;
        }
        
        /* ç¼–è¾‘å™¨æ ·å¼ */
.CodeMirror {
    height: 100%;
    font-size: 14px;
    line-height: 1.5;
    -webkit-touch-callout: text;
    -webkit-user-select: text;
    user-select: text;
    /* ç¡®ä¿ç¼–è¾‘å™¨å§‹ç»ˆå¯è§ */
    min-height: 100%;
    transition: font-size 0.1s ease;
}

.CodeMirror-scroll {
    /* æ”¯æŒè§¦æ‘¸æ»šåŠ¨å’Œç¼©æ”¾ */
    -webkit-overflow-scrolling: touch;
    touch-action: pan-x pan-y pinch-zoom;
    /* é˜²æ­¢é€‰æ‹©æ—¶çš„é—ªçƒ */
    -webkit-tap-highlight-color: transparent;
}

/* ç¼–è¾‘å™¨ç¼©æ”¾æ§åˆ¶ */
.editor-zoom-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
    display: flex;
    gap: 8px;
    background: rgba(0,0,0,0.6);
    padding: 4px;
    border-radius: 4px;
}

.zoom-btn {
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(255,255,255,0.1);
    color: white;
    border-radius: 4px;
    font-size: 18px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.zoom-btn:active {
    background: rgba(255,255,255,0.3);
    transform: scale(0.95);
}

.zoom-level {
    color: white;
    font-size: 12px;
    min-width: 40px;
    text-align: center;
    line-height: 32px;
    font-weight: bold;
}
        
        /* é¢„è§ˆå®¹å™¨ */
        .preview-container {
            height: 100%;
            background: white;
            position: relative;
        }
        
        .preview-frame {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        /* æ§åˆ¶å°å®¹å™¨ */
        .console-container {
            height: 100%;
            background: var(--surface-color);
            display: flex;
            flex-direction: column;
        }
        
        .console-header {
            padding: 12px 16px;
            background: rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .console-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
        }
        
        .console-entry {
            margin: 4px 0;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .console-entry.error {
            background: rgba(244, 67, 54, 0.1);
            color: #FF5252;
        }
        
        .console-entry.warn {
            background: rgba(255, 152, 0, 0.1);
            color: #FFB74D;
        }
        
        .console-entry.info {
            background: rgba(33, 150, 243, 0.1);
            color: #64B5F6;
        }
        
        /* åº•éƒ¨å¯¼èˆª */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: var(--bottom-nav-height);
            background: var(--surface-color);
            display: flex;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.3);
            z-index: 100;
        }
        
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            background: none;
            color: #666;
        }
        
        .nav-item.active {
            color: var(--primary-color);
        }
        
        .nav-item i {
            font-size: 24px;
            margin-bottom: 4px;
        }
        
        .nav-item span {
            font-size: 12px;
        }
        
        /* æµ®åŠ¨æ“ä½œæŒ‰é’® */
        .fab {
            position: fixed;
            bottom: calc(var(--bottom-nav-height) + 16px);
            right: 16px;
            width: 56px;
            height: 56px;
            background: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.3s;
            z-index: 90;
        }
        
        .fab:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        /* å¯¹è¯æ¡†åŸºç¡€æ ·å¼ */
        .dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: var(--surface-color);
            border-radius: 8px;
            padding: 0;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            z-index: 300;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        
        .dialog.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .dialog-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .dialog-title {
            font-size: 20px;
            font-weight: 500;
        }
        
        .dialog-content {
            padding: 20px;
            max-height: calc(80vh - 140px);
            overflow-y: auto;
        }
        
        .dialog-actions {
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }
        
        /* æŒ‰é’®æ ·å¼ */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: var(--primary-color);
            color: white;
        }
        
        .btn-primary:active {
            background: #1976D2;
        }
        
        .btn-text {
            background: transparent;
            color: var(--primary-color);
        }
        
        .btn-text:active {
            background: rgba(33, 150, 243, 0.1);
        }
        
        /* å†å²è®°å½•æ ·å¼ */
.history-item {
    padding: 16px;
    margin: 8px 0;
    background: var(--background-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    border: 1px solid var(--border-color);
}

.history-item:hover {
    background: rgba(33, 150, 243, 0.1);
    border-color: var(--primary-color);
}

.history-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.history-method {
    font-family: 'Monaco', 'Consolas', monospace;
    color: #4FC3F7;
    font-size: 16px;
    font-weight: 500;
}

.history-actions {
    display: flex;
    gap: 8px;
}

.history-btn {
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-color);
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s;
}

.history-btn:hover {
    background: var(--primary-color);
    color: white;
}

.history-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #666;
}

.history-count {
    background: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
}

.history-details h4 {
    color: var(--primary-color);
    margin: 16px 0 8px 0;
    font-size: 14px;
}

.history-details h4:first-child {
    margin-top: 0;
}

.history-details p {
    margin: 4px 0;
    font-size: 14px;
}

/* æ–¹æ³•æ›¿æ¢å¯¹è¯æ¡† */
.method-input {
    width: 100%;
    min-height: 200px;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 16px;
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 14px;
    border-radius: 8px;
    resize: vertical;
    line-height: 1.5;
}

.method-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
}

.detected-method {
    margin-top: 20px;
    padding: 16px;
    background: var(--background-color);
    border-radius: 8px;
    border: 1px solid var(--success-color);
}

.method-info {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.method-name {
    font-family: 'Monaco', 'Consolas', monospace;
    color: #4FC3F7;
    font-size: 18px;
    font-weight: 600;
}

.method-status {
    color: var(--success-color);
    font-size: 14px;
    font-weight: 500;
}

        /* è®¾ç½®é¡¹æ ·å¼ */
        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .setting-item:last-child {
            border-bottom: none;
        }
        
        .setting-label {
            font-size: 16px;
        }
        
        /* å¼€å…³æ ·å¼ */
        .switch {
            position: relative;
            width: 48px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .switch-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #666;
            transition: 0.3s;
            border-radius: 24px;
        }
        
        .switch-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        
        input:checked + .switch-slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .switch-slider:before {
            transform: translateX(24px);
        }
        
        /* å†å²è®°å½•æ ·å¼ */
        .history-list {
            max-height: 400px;
            overflow-y: auto;
        }
                
        .history-item:active {
            background: rgba(33, 150, 243, 0.1);
        }
        
        .history-time {
            color: #666;
            font-size: 12px;
        }
        
        /* Toast æç¤º */
        .toast {
            position: fixed;
            bottom: calc(var(--bottom-nav-height) + 80px);
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 400;
            max-width: 80%;
            text-align: center;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        .toast.error {
            background: var(--error-color);
        }
        
        .toast.success {
            background: var(--success-color);
        }
        
        /* åŠ è½½åŠ¨ç”» */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* å“åº”å¼è°ƒæ•´ */
        @media (min-width: 768px) {
            .main-content {
                display: flex;
            }
            
            .tab-container {
                display: flex;
            }
            
            .tab-panel {
                position: relative;
                flex: 1;
                opacity: 1;
                visibility: visible;
            }
            
            .bottom-nav {
                display: none;
            }
            
            .fab {
                bottom: 16px;
            }
            
            /* æ¡Œé¢ç«¯æ˜¾ç¤ºåˆ†å‰²çº¿ */
            .tab-panel:not(:last-child)::after {
                content: '';
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: 1px;
                background: var(--border-color);
            }
        }
        

/* å·¥å…·æç¤ºæ ·å¼ */
.icon-btn[title]:hover::after {
    content: attr(title);
    position: absolute;
    bottom: -30px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1000;
}

/* å“åº”å¼ä¼˜åŒ– */
@media (max-width: 768px) {
    .header-actions {
        gap: 4px;
    }
    
    .icon-btn {
        width: 36px;
        height: 36px;
        font-size: 18px;
    }
}

/* æœç´¢æ›¿æ¢æµ®çª—æ ·å¼ */
.search-replace-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--surface-color);
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 400px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    z-index: 300;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s;
}

.search-replace-panel.active {
    opacity: 1;
    visibility: visible;
}

.search-replace-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.search-replace-title {
    font-size: 18px;
    font-weight: 500;
}

.search-input-group {
    margin-bottom: 16px;
}

.search-input-group label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    color: var(--text-color);
}

.search-input {
    width: 100%;
    padding: 10px;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    color: var(--text-color);
    font-size: 14px;
}

.search-options {
    display: flex;
    gap: 16px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.search-option {
    display: flex;
    align-items: center;
    gap: 8px;
}

.search-option input[type="checkbox"] {
    width: 16px;
    height: 16px;
}

.search-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.search-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
}

.search-btn-primary {
    background: var(--primary-color);
    color: white;
}

.search-btn-secondary {
    background: var(--secondary-color);
    color: white;
}

.search-btn-text {
    background: transparent;
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
}

.search-results {
    margin-top: 16px;
    padding: 12px;
    background: var(--background-color);
    border-radius: 4px;
    font-size: 14px;
    color: var(--text-color);
}

/* é€‰æ‹©é«˜äº®æ ·å¼ */
.CodeMirror-selected {
    background: rgba(33, 150, 243, 0.3) !important;
}

.CodeMirror-focused .CodeMirror-selected {
    background: rgba(33, 150, 243, 0.4) !important;
}

/* å…‰æ ‡æ ·å¼ */
.CodeMirror-cursor {
    border-left: 2px solid #2196F3;
    animation: blink 1s infinite;
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
}

/* è§¦æ‘¸é€‰æ‹©ä¼˜åŒ– */
.CodeMirror-scroll {
    -webkit-user-select: text;
    user-select: text;
    -webkit-touch-callout: default;
}

/* é€‰æ‹©æ‰‹æŸ„æ ·å¼ï¼ˆç§»åŠ¨ç«¯ï¼‰ */
.CodeMirror-selection-handle {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #2196F3;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    z-index: 100;
}

/* å¸®åŠ©å†…å®¹æ ·å¼ */
.help-content {
    max-height: 60vh;
    overflow-y: auto;
}

.help-content h4 {
    color: var(--primary-color);
    margin: 20px 0 12px 0;
    font-size: 16px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 8px;
}

.help-content h4:first-child {
    margin-top: 0;
}

.help-content ul {
    margin: 0 0 16px 0;
    padding-left: 20px;
}

.help-content li {
    margin: 8px 0;
    line-height: 1.5;
}

.help-content strong {
    color: var(--text-color);
    font-weight: 600;
}

/* å¯¼å…¥ç›¸å…³æ ·å¼ */
.import-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--surface-color);
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    z-index: 300;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s;
}

.import-dialog.active {
    opacity: 1;
    visibility: visible;
}

.import-options {
    display: flex;
    flex-direction: column;
    gap: 16px;
    margin: 20px 0;
}

.import-option {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: var(--background-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    border: 2px solid transparent;
}

.import-option:hover {
    background: rgba(33, 150, 243, 0.1);
    border-color: var(--primary-color);
}

.import-option input[type="radio"] {
    width: 18px;
    height: 18px;
}

.import-option-info {
    flex: 1;
}

.import-option-title {
    font-weight: 500;
    margin-bottom: 4px;
}

.import-option-desc {
    font-size: 12px;
    color: #666;
}

.file-info {
    background: var(--background-color);
    padding: 16px;
    border-radius: 8px;
    margin: 16px 0;
    border-left: 4px solid var(--primary-color);
}

.file-info h4 {
    margin: 0 0 8px 0;
    color: var(--primary-color);
}

.file-info p {
    margin: 4px 0;
    font-size: 14px;
}

/* æ–‡ä»¶ç®¡ç†å™¨æ ·å¼ */
.file-manager-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: var(--surface-color);
    border-radius: 8px;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s;
    z-index: 300;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    display: flex;
    flex-direction: column;
}

.file-manager-panel.active {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
}

.file-manager-header {
    padding: 20px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.file-manager-header h3 {
    font-size: 20px;
    font-weight: 500;
    margin: 0;
}

.file-manager-actions {
    display: flex;
    gap: 8px;
}

.file-tabs {
    display: flex;
    gap: 2px;
    padding: 8px 20px;
    background: var(--background-color);
    overflow-x: auto;
    white-space: nowrap;
    -webkit-overflow-scrolling: touch;
}

.file-tab {
    padding: 8px 16px;
    background: var(--surface-color);
    border-radius: 4px 4px 0 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s;
    font-size: 14px;
    border: 1px solid var(--border-color);
    border-bottom: none;
}

.file-tab:hover {
    background: rgba(255,255,255,0.1);
}

.file-tab.active {
    background: var(--primary-color);
    color: white;
}

.tab-close {
    width: 16px;
    height: 16px;
    border: none;
    background: none;
    color: inherit;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    font-size: 12px;
    transition: background 0.3s;
}

.tab-close:hover {
    background: rgba(255,255,255,0.2);
}

.file-list {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
}

.file-category {
    margin-bottom: 24px;
}

.file-category h4 {
    font-size: 14px;
    color: var(--primary-color);
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.file-items {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.file-item {
    padding: 12px;
    background: var(--background-color);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    transition: all 0.3s;
    border: 1px solid transparent;
}

.file-item:hover {
    background: rgba(33, 150, 243, 0.1);
    border-color: var(--primary-color);
}

.file-item.active {
    background: rgba(33, 150, 243, 0.2);
    border-color: var(--primary-color);
}

.file-name {
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 14px;
}

.file-size {
    font-size: 12px;
    color: #666;
}

.file-delete {
    width: 24px;
    height: 24px;
    border: none;
    background: rgba(244, 67, 54, 0.1);
    color: var(--error-color);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    transition: all 0.3s;
}

.file-delete:hover {
    background: var(--error-color);
    color: white;
}

/* å¯¼å‡ºé€‰é¡¹æ ·å¼ */
.export-options {
    display: flex;
    flex-direction: column;
    gap: 16px;
    margin-top: 20px;
}

.export-option-btn {
    padding: 20px;
    background: var(--background-color);
    border: 2px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    text-align: left;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.export-option-btn:hover {
    background: rgba(33, 150, 243, 0.1);
    border-color: var(--primary-color);
}

.export-option-btn i {
    font-size: 24px;
}

.export-option-btn span {
    font-size: 16px;
    font-weight: 500;
}

.export-option-btn small {
    font-size: 12px;
    color: #666;
}

/* æ›¿æ¢ç¡®è®¤å¯¹è¯æ¡†æ ·å¼ */
.replacement-confirm-list {
    max-height: 40vh;
    overflow-y: auto;
    margin: 0;
    padding: 0;
    list-style: none;
}

.replacement-confirm-item {
    background: var(--background-color);
    padding: 12px;
    margin-bottom: 8px;
    border-radius: 4px;
    border-left: 3px solid var(--warning-color);
    font-size: 14px;
}

.replacement-confirm-item strong {
    color: var(--primary-color);
    font-family: 'Monaco', 'Consolas', monospace;
}

.replaced-text-highlight {
    background-color: rgba(76, 175, 80, 0.4);
    transition: background-color 0.5s ease-out;
    border-radius: 3px;
}

/* æ§åˆ¶å°è¿‡æ»¤æŒ‰é’®æ ·å¼ */
.console-filters {
    display: flex;
    gap: 8px;
}

.filter-btn {
    padding: 6px 12px;
    border: 1px solid var(--border-color);
    background: transparent;
    color: var(--text-color);
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.3s;
}

.filter-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: var(--primary-color);
}

.filter-btn.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

/* æ§åˆ¶å°æ—¥å¿—è®¡æ•°å¾½ç«  */
.console-entry-count {
    display: inline-block;
    min-width: 20px;
    height: 20px;
    padding: 0 6px;
    margin-left: 8px;
    background: var(--primary-color);
    color: white;
    border-radius: 10px;
    font-size: 12px;
    text-align: center;
    line-height: 20px;
    font-weight: bold;
}

/* ç”¨äºéšè—ä¸åŒ¹é…çš„æ—¥å¿—æ¡ç›® */
.console-entry.hidden {
    display: none;
}

        
        /* å›¾æ ‡ï¼ˆä½¿ç”¨æ–‡å­—ä»£æ›¿å›¾æ ‡åº“ï¼‰ */
        .icon-menu::before { content: 'â˜°'; }
        .icon-save::before { content: 'ğŸ’¾'; }
        .icon-code::before { content: '</>' }
        .icon-preview::before { content: 'ğŸ‘'; }
        .icon-console::before { content: 'ğŸ“‹'; }
        .icon-run::before { content: 'â–¶'; }
        .icon-format::before { content: 'âŠ'; }
        .icon-replace::before { content: 'âš¡'; }
        .icon-settings::before { content: 'âš™'; }
        .icon-history::before { content: 'ğŸ•'; }
        .icon-export::before { content: 'ğŸ“¤'; }
        .icon-clear::before { content: 'ğŸ—‘'; }
        .icon-close::before { content: 'âœ•'; }
        .icon-search::before { content: 'ğŸ”'; }
        .icon-help::before { content: 'â“'; }
        .icon-import::before { content: 'ğŸ“'; }
        .icon-select-all::before { content: 'ğŸ“‹'; }
        .icon-copy::before { content: 'ğŸ“„'; }
        .icon-cut::before { content: 'âœ‚ï¸'; }
        .icon-paste::before { content: 'ğŸ“‹'; }
        .icon-delete::before { content: 'ğŸ—‘ï¸'; }
        .icon-files::before { content: 'ğŸ“‚'; }
    </style>
</head>
<body>
    <!-- å¤´éƒ¨æ  -->
    <header class="header">
        <button class="menu-btn" id="menuBtn" onclick="toggleSidebar()">
            <span></span>
            <span></span>
            <span></span>
        </button>
        <div class="app-title">HTMLç¼–è¾‘å™¨</div>
        <div class="header-actions">
    <button class="icon-btn icon-help" onclick="showHelp()" title="ä½¿ç”¨è¯´æ˜"></button>
    <button class="icon-btn icon-save" onclick="saveCode()" title="ä¿å­˜ä»£ç "></button>
</div>
    </header>
    
    <!-- ä¾§è¾¹æ  -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2>åŠŸèƒ½èœå•</h2>
        </div>
                <nav class="sidebar-menu">
            <button class="menu-item" onclick="runCode(); closeSidebar();">
                <i class="icon-run"></i>
                è¿è¡Œä»£ç 
            </button>
            <button class="menu-item" onclick="formatCode()">
                <i class="icon-format"></i>
                æ ¼å¼åŒ–ä»£ç 
            </button>
            <button class="menu-item" onclick="showSearchReplace()">
                <i class="icon-search"></i>
                æœç´¢ä¸æ›¿æ¢
            </button>
            <button class="menu-item" onclick="showMethodReplace()">
                <i class="icon-replace"></i>
                æ™ºèƒ½æ–¹æ³•æ›¿æ¢
            </button>
            <button class="menu-item" onclick="showSettings()">
                <i class="icon-settings"></i>
                ç¼–è¾‘å™¨è®¾ç½®
            </button>
            <button class="menu-item" onclick="showHistory()">
                <i class="icon-history"></i>
                æ›¿æ¢å†å²
            </button>
            <div class="menu-divider"></div>
            <button class="menu-item" onclick="selectAllText(); closeSidebar();">
                <i class="icon-select-all"></i>
                å…¨é€‰æ–‡æœ¬
            </button>
            <button class="menu-item" onclick="copySelectedText(); closeSidebar();">
                <i class="icon-copy"></i>
                å¤åˆ¶é€‰ä¸­
            </button>
            <button class="menu-item" onclick="cutSelectedText(); closeSidebar();">
                <i class="icon-cut"></i>
                å‰ªåˆ‡é€‰ä¸­
            </button>
            <button class="menu-item" onclick="pasteText(); closeSidebar();">
                <i class="icon-paste"></i>
                ç²˜è´´å†…å®¹
            </button>
            <button class="menu-item" onclick="deleteSelectedText(); closeSidebar();">
                <i class="icon-delete"></i>
                åˆ é™¤é€‰ä¸­
            </button>
            <button class="menu-item" onclick="showFileManager()">
                <i class="icon-files"></i>
                æ–‡ä»¶ç®¡ç†å™¨
            </button>
            <button class="menu-item" onclick="importFile()">
                <i class="icon-import"></i>
                å¯¼å…¥æ–‡æ¡£
            </button>
            <button class="menu-item" onclick="exportCode()">
                <i class="icon-export"></i>
                å¯¼å‡ºä¸ºhtm
            </button>
            <button class="menu-item" onclick="clearEditor()">
                <i class="icon-clear"></i>
                æ¸…ç©ºç¼–è¾‘å™¨
            </button>
        </nav>
    </aside>
    
    <!-- æ–‡ä»¶è¾“å…¥ -->
<input type="file" id="fileInput" accept=".html,.htm,.js,.css,.txt,.json,.xml,.md,text/javascript,application/javascript,text/html,text/css,text/plain" multiple style="display: none;" onchange="handleFileImport(event)">
    
    <!-- é®ç½©å±‚ -->
    <div class="overlay" id="overlay"></div>
    
    <!-- ä¸»å†…å®¹åŒº -->
    <main class="main-content">
        <div class="tab-container">
            <!-- ç¼–è¾‘å™¨æ ‡ç­¾é¡µ -->
<div class="tab-panel active" id="editorTab">
    <div class="editor-zoom-controls">
        <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
        <span class="zoom-level" id="zoomLevel">100%</span>
        <button class="zoom-btn" onclick="zoomIn()">+</button>
    </div>
    <textarea id="codeEditor"></textarea>
</div>
</div>
            </div>
            
            <!-- é¢„è§ˆæ ‡ç­¾é¡µ -->
            <div class="tab-panel" id="previewTab">
                <div class="preview-container">
                    <iframe class="preview-frame" id="previewFrame" sandbox="allow-same-origin"></iframe>
                </div>
            </div>
            
            <!-- æ§åˆ¶å°æ ‡ç­¾é¡µ -->
            <div class="tab-panel" id="consoleTab">
                <div class="console-container">
                <div class="console-header">
                        <div class="console-filters">
                            <button class="filter-btn active" onclick="filterConsole('all')">å…¨éƒ¨</button>
                            <button class="filter-btn" onclick="filterConsole('error')">é”™è¯¯</button>
                            <button class="filter-btn" onclick="filterConsole('warn')">è­¦å‘Š</button>
                            <button class="filter-btn" onclick="filterConsole('info')">ä¿¡æ¯</button>
                        </div>
                        <button class="icon-btn icon-clear" onclick="clearConsole()" title="æ¸…ç©ºæ§åˆ¶å°"></button>
                    </div>
                    <div class="console-content" id="consoleContent"></div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- åº•éƒ¨å¯¼èˆª -->
<nav class="bottom-nav">
    <button class="nav-item active" onclick="switchTab('editor', this)">
        <i class="icon-code"></i>
        <span>ç¼–è¾‘</span>
    </button>
    <button class="nav-item" onclick="handlePreviewClick(this)">
        <i class="icon-preview"></i>
        <span>é¢„è§ˆ</span>
    </button>
    <button class="nav-item" onclick="switchTab('console', this)">
        <i class="icon-console"></i>
        <span>æ§åˆ¶å°</span>
    </button>
</nav>

<!-- æœç´¢æ›¿æ¢æµ®çª— -->
<div class="search-replace-panel" id="searchReplacePanel">
    <div class="search-replace-header">
        <h3 class="search-replace-title">æœç´¢ä¸æ›¿æ¢</h3>
        <button class="icon-btn icon-close" onclick="closeSearchReplace()"></button>
    </div>
    
    <div class="search-input-group">
        <label for="searchInput">æŸ¥æ‰¾å†…å®¹ï¼š</label>
        <input type="text" id="searchInput" class="search-input" placeholder="è¾“å…¥è¦æŸ¥æ‰¾çš„å†…å®¹">
    </div>
    
    <div class="search-input-group">
        <label for="replaceInput">æ›¿æ¢ä¸ºï¼š</label>
        <input type="text" id="replaceInput" class="search-input" placeholder="è¾“å…¥æ›¿æ¢å†…å®¹">
    </div>
    
    <div class="search-options">
        <div class="search-option">
            <input type="checkbox" id="caseSensitive">
            <label for="caseSensitive">åŒºåˆ†å¤§å°å†™</label>
        </div>
        <div class="search-option">
            <input type="checkbox" id="wholeWord">
            <label for="wholeWord">å…¨è¯åŒ¹é…</label>
        </div>
        <div class="search-option">
            <input type="checkbox" id="useRegex">
            <label for="useRegex">æ­£åˆ™è¡¨è¾¾å¼</label>
        </div>
    </div>
    
    <div class="search-actions">
        <button class="search-btn search-btn-primary" onclick="findNext()">æŸ¥æ‰¾ä¸‹ä¸€ä¸ª</button>
        <button class="search-btn search-btn-primary" onclick="findPrevious()">æŸ¥æ‰¾ä¸Šä¸€ä¸ª</button>
        <button class="search-btn search-btn-secondary" onclick="replaceNext()">æ›¿æ¢</button>
        <button class="search-btn search-btn-secondary" onclick="replaceAll()">å…¨éƒ¨æ›¿æ¢</button>
        <button class="search-btn search-btn-text" onclick="closeSearchReplace()">å…³é—­</button>
    </div>
    
    <div class="search-results" id="searchResults" style="display: none;"></div>
</div>
    
    <!-- æµ®åŠ¨æ“ä½œæŒ‰é’® -->
<button class="fab icon-run" onclick="runCode()" title="è¿è¡Œä»£ç "></button>
    
        <!-- æ–¹æ³•æ›¿æ¢å¯¹è¯æ¡† -->
    <div class="dialog" id="methodReplaceDialog">
        <div class="dialog-header">
            <h3 class="dialog-title">æ™ºèƒ½æ›¿æ¢</h3>
            <button class="icon-btn icon-close" onclick="closeDialog('methodReplaceDialog')"></button>
        </div>
        <div class="dialog-content">
            <div>
                <label style="display: block; margin-bottom: 8px;">ç²˜è´´ä¸€ä¸ªæˆ–å¤šä¸ªå¾…æ›´æ–°çš„ JSå‡½æ•° / CSSè§„åˆ™ / HTMLå—ï¼š</label>
                <textarea class="method-input" id="methodInput" placeholder=".my-class {&#10;    color: blue;&#10;}&#10;&#10;function myFunction() {&#10;    // æ–°çš„å®ç°&#10;}"></textarea>
            </div>
            <div id="detectedMethod" class="detected-method" style="display: none; border: none; padding: 0;">
                <!-- æ£€æµ‹åˆ°çš„ä»£ç å—å°†åŠ¨æ€æ·»åŠ åˆ°è¿™é‡Œ -->
            </div>
        </div>
        <div class="dialog-actions">
            <button class="btn btn-text" onclick="closeDialog('methodReplaceDialog')">å–æ¶ˆ</button>
            <button class="btn btn-primary" onclick="analyzeMethod()">åˆ†æ</button>
            <button class="btn btn-primary" id="replaceBtn" onclick="executeReplace()" style="display: none;">æ›¿æ¢</button>
        </div>
    </div>
    
    <!-- è®¾ç½®å¯¹è¯æ¡† -->
    <div class="dialog" id="settingsDialog">
        <div class="dialog-header">
            <h3 class="dialog-title">ç¼–è¾‘å™¨è®¾ç½®</h3>
            <button class="icon-btn icon-close" onclick="closeDialog('settingsDialog')"></button>
        </div>
        <div class="dialog-content">
            <div class="setting-item">
                <span class="setting-label">è‡ªåŠ¨æ¢è¡Œ</span>
                <label class="switch">
                    <input type="checkbox" id="wordWrapToggle" onchange="toggleWordWrap()">
                    <span class="switch-slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">æ˜¾ç¤ºè¡Œå·</span>
                <label class="switch">
                    <input type="checkbox" id="lineNumbersToggle" checked onchange="toggleLineNumbers()">
                    <span class="switch-slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">è‡ªåŠ¨å®Œæˆ</span>
                <label class="switch">
                    <input type="checkbox" id="autocompleteToggle" checked onchange="toggleAutocomplete()">
                    <span class="switch-slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">ä¸»é¢˜</span>
                <select id="themeSelect" onchange="changeTheme()" style="background: var(--background-color); color: var(--text-color); border: 1px solid var(--border-color); padding: 8px; border-radius: 4px;">
                    <option value="material-darker">Material Dark</option>
                    <option value="monokai">Monokai</option>
                    <option value="dracula">Dracula</option>
                    <option value="eclipse">Eclipse Light</option>
                </select>
            </div>
        </div>
        <div class="dialog-actions">
            <button class="btn btn-primary" onclick="closeDialog('settingsDialog')">ç¡®å®š</button>
        </div>
    </div>
    
    <!-- å†å²è®°å½•å¯¹è¯æ¡† -->
    <div class="dialog" id="historyDialog">
        <div class="dialog-header">
            <h3 class="dialog-title">æ›¿æ¢å†å²</h3>
            <button class="icon-btn icon-close" onclick="closeDialog('historyDialog')"></button>
        </div>
        <div class="dialog-content">
            <div class="history-list" id="historyList"></div>
        </div>
    </div>
    
    <!-- ä½¿ç”¨è¯´æ˜å¯¹è¯æ¡† -->
<div class="dialog" id="helpDialog">
    <div class="dialog-header">
        <h3 class="dialog-title">ä½¿ç”¨è¯´æ˜</h3>
        <button class="icon-btn icon-close" onclick="closeDialog('helpDialog')"></button>
    </div>
    <div class="dialog-content">
        <div class="help-content">
            <h4>ğŸ¯ ä¸»è¦åŠŸèƒ½</h4>
            <ul>
                <li><strong>ä»£ç ç¼–è¾‘ï¼š</strong>æ”¯æŒHTMLã€CSSã€JavaScriptè¯­æ³•é«˜äº®å’Œè‡ªåŠ¨å®Œæˆ</li>
                <li><strong>å®æ—¶é¢„è§ˆï¼š</strong>åœ¨é¢„è§ˆæ ‡ç­¾é¡µæŸ¥çœ‹ä»£ç æ•ˆæœ</li>
                <li><strong>æ–°çª—å£é¢„è§ˆï¼š</strong>é•¿æŒ‰é¢„è§ˆæŒ‰é’®æˆ–å·¦æ»‘ç¼–è¾‘å™¨å¯åœ¨æ–°çª—å£æ‰“å¼€</li>
                <li><strong>æ§åˆ¶å°è¾“å‡ºï¼š</strong>æŸ¥çœ‹JavaScriptè¿è¡Œç»“æœå’Œé”™è¯¯ä¿¡æ¯</li>
                <li><strong>ä»£ç æ ¼å¼åŒ–ï¼š</strong>è‡ªåŠ¨æ•´ç†HTMLã€CSSã€JavaScriptä»£ç æ ¼å¼</li>
            </ul>
            
            <h4>ğŸ”§ ç¼–è¾‘åŠŸèƒ½</h4>
            <ul>
                <li><strong>æ–‡æœ¬é€‰æ‹©ï¼š</strong>é•¿æŒ‰æ–‡æœ¬è¿›å…¥é€‰æ‹©æ¨¡å¼ï¼Œæ”¯æŒå¤åˆ¶ã€å‰ªåˆ‡ã€ç²˜è´´</li>
                <li><strong>ç¼©æ”¾æ§åˆ¶ï¼š</strong>ä½¿ç”¨å³ä¸Šè§’+/-æŒ‰é’®æˆ–åŒæŒ‡ç¼©æ”¾è°ƒæ•´å­—ä½“å¤§å°</li>
                <li><strong>æœç´¢æ›¿æ¢ï¼š</strong>æ”¯æŒæ­£åˆ™è¡¨è¾¾å¼ã€åŒºåˆ†å¤§å°å†™ã€å…¨è¯åŒ¹é…</li>
                <li><strong>æ™ºèƒ½æ–¹æ³•æ›¿æ¢ï¼š</strong>æ”¯æŒå¿«é€Ÿæ›¿æ¢JavaScriptå‡½æ•°ã€CSSå’Œhtmlå…ƒç´ çš„å®šä¹‰</li>
                <li><strong>è‡ªåŠ¨ä¿å­˜ï¼š</strong>ç¼–è¾‘å†…å®¹è‡ªåŠ¨ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨</li>
            </ul>
            
            <h4>âš™ï¸ é«˜çº§åŠŸèƒ½</h4>
            <ul>
                <li><strong>ä¸»é¢˜åˆ‡æ¢ï¼š</strong>æ”¯æŒå¤šç§ç¼–è¾‘å™¨ä¸»é¢˜ï¼ˆMaterial Darkã€Monokaiç­‰ï¼‰</li>
                <li><strong>ç¼–è¾‘å™¨è®¾ç½®ï¼š</strong>è‡ªåŠ¨æ¢è¡Œã€è¡Œå·æ˜¾ç¤ºã€è‡ªåŠ¨å®Œæˆå¼€å…³</li>
                <li><strong>æ›¿æ¢å†å²ï¼š</strong>æŸ¥çœ‹å’Œæ¢å¤ä¹‹å‰çš„æ–¹æ³•æ›¿æ¢æ“ä½œ</li>
                <li><strong>ä»£ç å¯¼å‡ºï¼š</strong>å°†ç¼–è¾‘çš„HTMLæ–‡ä»¶å¯¼å‡ºåˆ°æœ¬åœ°</li>
                <li><strong>å…¨é€‰/æ¸…ç©ºï¼š</strong>å¿«é€Ÿé€‰æ‹©å…¨éƒ¨å†…å®¹æˆ–æ¸…ç©ºç¼–è¾‘å™¨</li>
            </ul>
            
            <h4>ğŸ“± è§¦æ‘¸æ‰‹åŠ¿</h4>
            <ul>
                <li><strong>åŒæŒ‡ç¼©æ”¾ï¼š</strong>åœ¨ç¼–è¾‘å™¨ä¸­åŒæŒ‡ç¼©æ”¾è°ƒæ•´å­—ä½“å¤§å°</li>
                <li><strong>å·¦æ»‘ï¼š</strong>åœ¨ç¼–è¾‘å™¨ä¸­å·¦æ»‘å¯å¿«é€Ÿæ–°çª—å£é¢„è§ˆ</li>
                <li><strong>é•¿æŒ‰é¢„è§ˆï¼š</strong>é•¿æŒ‰åº•éƒ¨é¢„è§ˆæŒ‰é’®å°†ä¼šåœ¨æ–°çª—å£è¿è¡Œæ‰“å¼€ä»£ç </li>
                <li><strong>é•¿æŒ‰æ–‡æœ¬ï¼š</strong>é•¿æŒ‰å¹¶æ»‘åŠ¨ç¼–è¾‘å™¨æ–‡æœ¬è¿›å…¥é€‰æ‹©æ¨¡å¼</li>
            </ul>
            
            <h4>âŒ¨ï¸ é”®ç›˜å¿«æ·é”®</h4>
            <ul>
                <li><strong>Ctrl/Cmd + Enterï¼š</strong>è¿è¡Œä»£ç </li>
                <li><strong>Ctrl/Cmd + Sï¼š</strong>ä¿å­˜ä»£ç </li>
                <li><strong>Ctrl/Cmd + Shift + Pï¼š</strong>æ–°çª—å£é¢„è§ˆ</li>
                <li><strong>Ctrl/Cmd + Aï¼š</strong>å…¨é€‰æ–‡æœ¬</li>
            </ul>
            
            <h4>ğŸ’¡ ä½¿ç”¨æŠ€å·§</h4>
            <ul>            
                <li>ä½¿ç”¨â€œé¢„è§ˆâ€å¿«é€Ÿè°ƒæ•´æ ·å¼ï¼Œä½¿ç”¨â€œè¿è¡Œâ€æµ‹è¯•å®Œæ•´åŠŸèƒ½ã€‚</li>
                <li>ç¼–è¾‘å™¨æ”¯æŒè‡ªåŠ¨æ‹¬å·åŒ¹é…å’Œæ ‡ç­¾é—­åˆ</li>
                <li>æ§åˆ¶å°ä¼šæ˜¾ç¤ºJavaScriptè¿è¡Œæ—¶çš„è¾“å‡ºå’Œé”™è¯¯</li>
                <li>æœç´¢æ¡†æ”¯æŒEnteræŸ¥æ‰¾ä¸‹ä¸€ä¸ªï¼ŒShift+EnteræŸ¥æ‰¾ä¸Šä¸€ä¸ª</li>
                <li>æ–¹æ³•æ›¿æ¢åŠŸèƒ½å¯ä»¥å¿«é€Ÿæ›´æ–°JavaScriptå‡½æ•°å®ç°</li>
                <li>æ‰€æœ‰è®¾ç½®å’Œä»£ç éƒ½ä¼šè‡ªåŠ¨ä¿å­˜åˆ°æµè§ˆå™¨æœ¬åœ°å­˜å‚¨</li>
            </ul>
        </div>
    </div>
    <div class="dialog-actions">
        <button class="btn btn-primary" onclick="closeDialog('helpDialog')">çŸ¥é“äº†</button>
    </div>
</div>
    
    <!-- Toast æç¤º -->
    <div class="toast" id="toast"></div>
    
    <!-- CodeMirror JS -->
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/lib/codemirror.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/mode/xml/xml.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/mode/javascript/javascript.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/mode/css/css.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/mode/htmlmixed/htmlmixed.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/addon/edit/closebrackets.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/addon/edit/closetag.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/addon/hint/show-hint.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/addon/hint/html-hint.min.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let editor;
let projectFiles = new Map(); // å­˜å‚¨é¡¹ç›®æ–‡ä»¶ key: filename, value: {content, type, lastModified}
let currentFileName = 'index.html'; // å½“å‰ç¼–è¾‘çš„æ–‡ä»¶å
let projectStructure = {
    html: [],
    css: [],
    js: [],
    other: []
}; // é¡¹ç›®ç»“æ„
        let currentTab = 'editor';
        let detectedMethod = null;
        let replaceHistory = [];
        let touchStartX = 0;
        let touchStartY = 0;
let currentZoom = 1.0;
const ZOOM_STEP = 0.1;
const MIN_ZOOM = 0.5;
const MAX_ZOOM = 2.0;      
        // æœç´¢æ›¿æ¢ç›¸å…³å˜é‡
let searchState = {
    query: '',
    replaceText: '',
    caseSensitive: false,
    wholeWord: false,
    useRegex: false,
    currentMatch: -1,
    matches: []
};
let _pendingReplacements = [];
let messageCounts = {};
        
        // é»˜è®¤HTMLæ¨¡æ¿
        const DEFAULT_TEMPLATE = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¤ºä¾‹é¡µé¢</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #2196F3;
            padding-bottom: 10px;
        }
        .button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 0;
            transition: background 0.3s;
        }
        .button:hover {
            background: #1976D2;
        }
        .output {
            margin-top: 20px;
            padding: 16px;
            background: #f0f0f0;
            border-radius: 4px;
            font-family: monospace;
            min-height: 50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>æ¬¢è¿ä½¿ç”¨ç§»åŠ¨ç‰ˆHTMLç¼–è¾‘å™¨</h1>
        <p>è¿™æ˜¯ä¸€ä¸ªä¸“ä¸ºç§»åŠ¨è®¾å¤‡ä¼˜åŒ–çš„HTMLä»£ç ç¼–è¾‘å·¥å…·ã€‚</p>
        
        <button class="button" onclick="showMessage()">ç‚¹å‡»æµ‹è¯•</button>
        
        <div class="output" id="output">
            è¾“å‡ºå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ...
        </div>
    </div>
    
    <script>
        function showMessage() {
            const messages = [
                'ä½ å¥½ï¼Œä¸–ç•Œï¼',
                'ç§»åŠ¨ç¼–ç¨‹ï¼Œéšæ—¶éšåœ°',
                'äº«å—ç¼–ç çš„ä¹è¶£'
            ];
            const randomMsg = messages[Math.floor(Math.random() * messages.length)];
            const output = document.getElementById('output');
            output.innerHTML = \`
                <strong>æ¶ˆæ¯ï¼š</strong>\${randomMsg}<br>
                <small>æ—¶é—´ï¼š\${new Date().toLocaleString()}</small>
            \`;
            
            console.log('æŒ‰é’®è¢«ç‚¹å‡»äº†ï¼', randomMsg);
        }
        
        // ç¤ºä¾‹æ–¹æ³•ï¼šå¯ä»¥è¢«æ›¿æ¢
        function dataProcessor() {
            console.log('å¤„ç†æ•°æ®ä¸­...');
            return {
                status: 'success',
                timestamp: Date.now()
            };
        }
        
        // åˆå§‹åŒ–
        window.addEventListener('load', function() {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼');
            console.info('ç§»åŠ¨ç‰ˆç¼–è¾‘å™¨ v2.0');
        });
    </${'script'}>
</body>
</html>`;
        
        // åˆå§‹åŒ–ç¼–è¾‘å™¨
function initEditor() {
    editor = CodeMirror.fromTextArea(document.getElementById('codeEditor'), {
        mode: 'htmlmixed',
        theme: 'material-darker',
        lineNumbers: true,
        autoCloseBrackets: true,
        autoCloseTags: true,
        matchBrackets: true,
        indentUnit: 2,
        tabSize: 2,
        lineWrapping: true,
        scrollbarStyle: 'native',
        // ç§»åŠ¨ç«¯ä¼˜åŒ–é…ç½®
        inputStyle: 'contenteditable',
        // å¯ç”¨æ–‡æœ¬é€‰æ‹©å’Œç¼–è¾‘
        readOnly: false,
        // æ”¯æŒè§¦æ‘¸é€‰æ‹©
        dragDrop: true,
        // é…ç½®é¼ æ ‡/è§¦æ‘¸è¡Œä¸º
        configureMouse: function(cm, repeat, event) {
            return {
                unit: 'char',
                extend: event.shiftKey,
                addNew: event.ctrlKey || event.metaKey,
                moveOnDrag: true
            };
        },
        extraKeys: {
            "Ctrl-Space": "autocomplete",
            "Cmd-S": saveCode,
            "Ctrl-S": saveCode,
            "Ctrl-A": "selectAll",
            "Cmd-A": "selectAll",
            "Delete": function(cm) {
                if (cm.somethingSelected()) {
                    cm.replaceSelection("");
                } else {
                    cm.execCommand("delCharAfter");
                }
            },
            "Backspace": function(cm) {
                if (cm.somethingSelected()) {
                    cm.replaceSelection("");
                } else {
                    cm.execCommand("delCharBefore");
                }
            }
        }
    });
    
    loadProject();
    
    // å¯ç”¨æ–‡æœ¬é€‰æ‹©æ ·å¼
    const editorElement = editor.getWrapperElement();
    editorElement.style.webkitUserSelect = 'text';
    editorElement.style.userSelect = 'text';
    editorElement.style.webkitTouchCallout = 'default';
    
    // ç›‘å¬ç¼–è¾‘å™¨å®¹å™¨å¤§å°å˜åŒ–
    const resizeObserver = new ResizeObserver(() => {
        if (editor) {
            editor.refresh();
        }
    });
    
    const editorContainer = document.getElementById('editorTab');
    if (editorContainer) {
        resizeObserver.observe(editorContainer);
    }
    
    // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶åˆ·æ–°ç¼–è¾‘å™¨
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && currentTab === 'editor') {
            setTimeout(() => {
                if (editor) {
                    editor.refresh();
                }
            }, 100);
        }
    });
    
    editor.on('change', debounce(() => {
        // ä¿å­˜å½“å‰æ–‡ä»¶åˆ°é¡¹ç›®
        if (currentFileName) {
            projectFiles.set(currentFileName, {
                content: editor.getValue(),
                type: getFileType(currentFileName),
                lastModified: Date.now()
            });
            
            // ä¿å­˜æ•´ä¸ªé¡¹ç›®
            const projectData = {
                files: Array.from(projectFiles.entries()),
                currentFile: currentFileName
            };
            localStorage.setItem('htmlEditorProject', JSON.stringify(projectData));
        }
    }, 1000));
    
    // åˆå§‹åŒ–å…¶ä»–ç»„ä»¶
    loadSettings();
    loadHistory();
    initTouchGestures();
    
    // åˆå§‹åŒ–è§¦æ‘¸æ”¯æŒ
    initEnhancedEditorTouch();
}
        
        // åˆå§‹åŒ–ç¼–è¾‘å™¨è§¦æ‘¸æ”¯æŒ
function initEnhancedEditorTouch() {
    const editorElement = editor.getWrapperElement();
    const scrollElement = editor.getScrollerElement();
    
    let touchStartTime = 0;
    let touchStartPos = { x: 0, y: 0 };
    let longPressTimer = null;
    let isLongPress = false;
    let isSelecting = false;
    let selectionStart = null;
    
    // ç¡®ä¿ç¼–è¾‘å™¨æ”¯æŒæ–‡æœ¬é€‰æ‹©
    editorElement.style.webkitUserSelect = 'text';
    editorElement.style.userSelect = 'text';
    editorElement.style.webkitTouchCallout = 'default';
    
    // å¤„ç†è§¦æ‘¸å¼€å§‹
    editorElement.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchStartPos = {
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
        };
        
        isLongPress = false;
        isSelecting = false;
        
        // è·å–è§¦æ‘¸ä½ç½®å¯¹åº”çš„ç¼–è¾‘å™¨åæ ‡
        const pos = editor.coordsChar({
            left: touchStartPos.x,
            top: touchStartPos.y
        });
        
        // è®¾ç½®é•¿æŒ‰å®šæ—¶å™¨
        longPressTimer = setTimeout(() => {
            isLongPress = true;
            isSelecting = true;
            selectionStart = pos;
            
            // å¼€å§‹é€‰æ‹©æ¨¡å¼ - é€‰æ‹©å½“å‰å•è¯æˆ–å­—ç¬¦
            const line = editor.getLine(pos.line);
            if (line) {
                // å°è¯•é€‰æ‹©å•è¯
                const wordStart = findWordBoundary(line, pos.ch, -1);
                const wordEnd = findWordBoundary(line, pos.ch, 1);
                
                if (wordStart !== wordEnd) {
                    editor.setSelection(
                        { line: pos.line, ch: wordStart },
                        { line: pos.line, ch: wordEnd }
                    );
                } else {
                    // å¦‚æœæ²¡æœ‰å•è¯ï¼Œé€‰æ‹©å•ä¸ªå­—ç¬¦
                    editor.setSelection(pos, { line: pos.line, ch: pos.ch + 1 });
                }
            }
            
            // è§¦è§‰åé¦ˆ
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        }, 500);
        
    }, { passive: true });
    
    // å¤„ç†è§¦æ‘¸ç§»åŠ¨
    editorElement.addEventListener('touchmove', (e) => {
        const currentPos = {
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
        };
        
        const moveDistance = Math.abs(currentPos.x - touchStartPos.x) + 
                           Math.abs(currentPos.y - touchStartPos.y);
        
        // å¦‚æœç§»åŠ¨è·ç¦»è¿‡å¤§ï¼Œå–æ¶ˆé•¿æŒ‰
        if (moveDistance > 15 && !isSelecting) {
            clearTimeout(longPressTimer);
            isLongPress = false;
        }
        
        // å¦‚æœæ­£åœ¨é€‰æ‹©ï¼Œæ‰©å±•é€‰æ‹©èŒƒå›´
        if (isSelecting && selectionStart) {
            const currentEditorPos = editor.coordsChar({
                left: currentPos.x,
                top: currentPos.y
            });
            
            editor.setSelection(selectionStart, currentEditorPos);
        }
        
    }, { passive: true });
    
    // å¤„ç†è§¦æ‘¸ç»“æŸ
    editorElement.addEventListener('touchend', (e) => {
        clearTimeout(longPressTimer);
        
        const touchDuration = Date.now() - touchStartTime;
        
        // å¦‚æœä¸æ˜¯é•¿æŒ‰ä¸”ä¸æ˜¯é€‰æ‹©æ¨¡å¼ï¼Œæ‰§è¡Œæ­£å¸¸ç‚¹å‡»
        if (!isLongPress && !isSelecting && touchDuration < 500) {
            const pos = editor.coordsChar({
                left: touchStartPos.x,
                top: touchStartPos.y
            });
            editor.setCursor(pos);
            editor.focus();
        }
        
        // é‡ç½®çŠ¶æ€
        isLongPress = false;
        isSelecting = false;
        selectionStart = null;
        
    }, { passive: true });
    
    // å¤„ç†é”®ç›˜è¾“å…¥ - åˆ é™¤é€‰ä¸­å†…å®¹
    editor.on('keydown', (cm, event) => {
        if (cm.somethingSelected()) {
            // å¦‚æœæœ‰é€‰ä¸­å†…å®¹ï¼ŒæŒ‰ä»»æ„å­—ç¬¦é”®éƒ½ä¼šæ›¿æ¢é€‰ä¸­å†…å®¹
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
                cm.replaceSelection(event.key);
                event.preventDefault();
            }
            // Delete æˆ– Backspace åˆ é™¤é€‰ä¸­å†…å®¹
            else if (event.key === 'Delete' || event.key === 'Backspace') {
                cm.replaceSelection('');
                event.preventDefault();
            }
        }
    });
    
    // ä¸Šä¸‹æ–‡èœå•æ”¯æŒ
    editorElement.addEventListener('contextmenu', (e) => {
        // å¦‚æœæœ‰é€‰ä¸­å†…å®¹ï¼Œæ˜¾ç¤ºç³»ç»Ÿä¸Šä¸‹æ–‡èœå•
        if (editor.somethingSelected()) {
            // å…è®¸ç³»ç»Ÿä¸Šä¸‹æ–‡èœå•æ˜¾ç¤º
            return true;
        }
        e.preventDefault();
    });
}

// æŸ¥æ‰¾å•è¯è¾¹ç•Œ
function findWordBoundary(line, pos, direction) {
    const wordRegex = /\w/;
    let i = pos;
    
    if (direction > 0) {
        // å‘å³æŸ¥æ‰¾å•è¯ç»“æŸ
        while (i < line.length && wordRegex.test(line[i])) {
            i++;
        }
    } else {
        // å‘å·¦æŸ¥æ‰¾å•è¯å¼€å§‹
        while (i > 0 && wordRegex.test(line[i - 1])) {
            i--;
        }
    }
    
    return i;
}

// é€‰æ‹©å…¨éƒ¨æ–‡æœ¬
function selectAllText() {
    editor.setSelection(
        { line: 0, ch: 0 },
        { line: editor.lastLine(), ch: editor.getLine(editor.lastLine()).length }
    );
    editor.focus();
}

// å¤åˆ¶é€‰ä¸­å†…å®¹
function copySelectedText() {
    if (editor.somethingSelected()) {
        const selectedText = editor.getSelection();
        
        // å°è¯•ä½¿ç”¨ç°ä»£å‰ªè´´æ¿API
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(selectedText).then(() => {
                showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
            }).catch(() => {
                // é™çº§åˆ°ä¼ ç»Ÿæ–¹æ³•
                copyToClipboardFallback(selectedText);
            });
        } else {
            copyToClipboardFallback(selectedText);
        }
    } else {
        showToast('è¯·å…ˆé€‰æ‹©è¦å¤åˆ¶çš„å†…å®¹', 'warning');
    }
}

// å‰ªåˆ‡é€‰ä¸­å†…å®¹
function cutSelectedText() {
    if (editor.somethingSelected()) {
        const selectedText = editor.getSelection();
        
        // å¤åˆ¶åˆ°å‰ªè´´æ¿
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(selectedText).then(() => {
                editor.replaceSelection('');
                showToast('å·²å‰ªåˆ‡åˆ°å‰ªè´´æ¿', 'success');
            }).catch(() => {
                copyToClipboardFallback(selectedText);
                editor.replaceSelection('');
            });
        } else {
            copyToClipboardFallback(selectedText);
            editor.replaceSelection('');
        }
    } else {
        showToast('è¯·å…ˆé€‰æ‹©è¦å‰ªåˆ‡çš„å†…å®¹', 'warning');
    }
}

// ç²˜è´´å†…å®¹
function pasteText() {
    if (navigator.clipboard && navigator.clipboard.readText) {
        navigator.clipboard.readText().then(text => {
            if (editor.somethingSelected()) {
                editor.replaceSelection(text);
            } else {
                editor.replaceRange(text, editor.getCursor());
            }
            showToast('å·²ç²˜è´´å†…å®¹', 'success');
        }).catch(() => {
            showToast('æ— æ³•è®¿é—®å‰ªè´´æ¿', 'error');
        });
    } else {
        showToast('æµè§ˆå™¨ä¸æ”¯æŒå‰ªè´´æ¿æ“ä½œ', 'error');
    }
}

// é™çº§å‰ªè´´æ¿æ“ä½œ
function copyToClipboardFallback(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.opacity = '0';
    document.body.appendChild(textArea);
    textArea.select();
    
    try {
        document.execCommand('copy');
        showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
    } catch (err) {
        showToast('å¤åˆ¶å¤±è´¥', 'error');
    }
    
    document.body.removeChild(textArea);
}

// åˆ é™¤é€‰ä¸­å†…å®¹
function deleteSelectedText() {
    if (editor.somethingSelected()) {
        editor.replaceSelection('');
        showToast('å·²åˆ é™¤é€‰ä¸­å†…å®¹');
    }
}

// ç¼©æ”¾åŠŸèƒ½
function zoomIn() {
    if (currentZoom < MAX_ZOOM) {
        currentZoom = Math.min(MAX_ZOOM, currentZoom + ZOOM_STEP);
        applyZoom();
        
        // è§¦è§‰åé¦ˆï¼ˆå¦‚æœæ”¯æŒï¼‰
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
    }
}

function zoomOut() {
    if (currentZoom > MIN_ZOOM) {
        currentZoom = Math.max(MIN_ZOOM, currentZoom - ZOOM_STEP);
        applyZoom();
        
        // è§¦è§‰åé¦ˆï¼ˆå¦‚æœæ”¯æŒï¼‰
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
    }
}

function applyZoom() {
    const editorElement = editor.getWrapperElement();
    const fontSize = Math.round(14 * currentZoom);
    editorElement.style.fontSize = fontSize + 'px';
    
    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
    
    // å»¶è¿Ÿåˆ·æ–°ç¼–è¾‘å™¨ï¼Œç¡®ä¿æ ·å¼åº”ç”¨å®Œæˆ
    setTimeout(() => {
        editor.refresh();
    }, 10);
    
    // ä¿å­˜ç¼©æ”¾çº§åˆ«
    localStorage.setItem('editorZoom', currentZoom);
}

// æ¢å¤ç¼©æ”¾çº§åˆ«
function restoreZoom() {
    const savedZoom = localStorage.getItem('editorZoom');
    if (savedZoom) {
        currentZoom = parseFloat(savedZoom);
        applyZoom();
    }
}
        
        // é˜²æŠ–å‡½æ•°
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
            // åˆå§‹åŒ–è§¦æ‘¸æ‰‹åŠ¿
    function initTouchGestures() {
        const mainContent = document.querySelector('.main-content');
        const previewNavItem = document.querySelector('.nav-item:nth-child(2)');
        let initialDistance = 0;
        let isZooming = false;
        let lastZoomTime = 0;
        const ZOOM_THROTTLE = 50;
        const SWIPE_THRESHOLD = 50;
        
        // ç¼–è¾‘å™¨åŒºåŸŸçš„è§¦æ‘¸äº‹ä»¶ï¼Œç”¨äºç¼©æ”¾å’Œæ»‘åŠ¨
        mainContent.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                isZooming = true;
                initialDistance = getDistance(e.touches[0], e.touches[1]);
                e.preventDefault();
            } else {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        }, { passive: false });
        
        mainContent.addEventListener('touchmove', (e) => {
            if (isZooming && e.touches.length === 2) {
                e.preventDefault();
                
                const now = Date.now();
                if (now - lastZoomTime < ZOOM_THROTTLE) return;
                lastZoomTime = now;
                
                const currentDistance = getDistance(e.touches[0], e.touches[1]);
                const scale = currentDistance / initialDistance;
                
                if (scale > 1.05) { // æ”¾å¤§
                    zoomIn();
                    initialDistance = currentDistance;
                } else if (scale < 0.95) { // ç¼©å°
                    zoomOut();
                    initialDistance = currentDistance;
                }
            }
        }, { passive: false });
        
        mainContent.addEventListener('touchend', (e) => {
            if (isZooming) {
                isZooming = false;
                return;
            }
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            
            // æ°´å¹³æ»‘åŠ¨æ£€æµ‹
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > SWIPE_THRESHOLD) {
                if (diffX < 0 && currentTab === 'editor') {
                    // å·¦æ»‘ï¼šç¼–è¾‘å™¨ -> è¿è¡Œä»£ç 
                    runCode();
                } else if (diffX > 0 && currentTab === 'preview') {
                    // å³æ»‘ï¼šè¿è¡Œä»£ç  -> ç¼–è¾‘å™¨
                    switchTab('editor');
                }
            }
        }, { passive: true });
        
    }

    // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
    function getDistance(touch1, touch2) {
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // å¤„ç†é¢„è§ˆæŒ‰é’®ç‚¹å‡»
    function handlePreviewClick(clickedElement) {
        // åˆ‡æ¢åˆ°é¢„è§ˆæ ‡ç­¾é¡µ
        switchTab('preview', clickedElement);
    }
    
    
        // åˆ‡æ¢ä¾§è¾¹æ 
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('overlay');
            const menuBtn = document.getElementById('menuBtn');
            
            sidebar.classList.toggle('active');
            overlay.classList.toggle('active');
            menuBtn.classList.toggle('active');
        }
        
        // å…³é—­ä¾§è¾¹æ 
        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('overlay');
            const menuBtn = document.getElementById('menuBtn');
            
            sidebar.classList.remove('active');
            overlay.classList.remove('active');
            menuBtn.classList.remove('active');
        }
        
        // åˆ‡æ¢æ ‡ç­¾é¡µ
function switchTab(tab, clickedElement) {
    currentTab = tab;
    
    // æ›´æ–°æ ‡ç­¾é¡µæ˜¾ç¤º
    document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.remove('active');
    });
    document.getElementById(tab + 'Tab').classList.add('active');
    
    // æ›´æ–°åº•éƒ¨å¯¼èˆª
    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // active ç±»
    if (clickedElement) {
        const navItem = clickedElement.closest('.nav-item');
        if (navItem) {
            navItem.classList.add('active');
        }
    } else {
        // å¦‚æœæ²¡æœ‰ä¼ å…¥å…ƒç´ ï¼Œæ ¹æ® tab å‚æ•°æ‰¾åˆ°å¯¹åº”çš„å¯¼èˆªé¡¹
        const navItems = document.querySelectorAll('.nav-item');
        let targetIndex = 0;
        if (tab === 'preview') targetIndex = 1;
        if (tab === 'console') targetIndex = 2;
        
        if (navItems[targetIndex]) {
            navItems[targetIndex].classList.add('active');
        }
    }
    
    if (tab === 'editor') {
        // å»¶è¿Ÿåˆ·æ–°ç¼–è¾‘å™¨ï¼Œç¡®ä¿DOMå®Œå…¨æ¸²æŸ“
        setTimeout(() => {
            if (editor) {
                editor.refresh();
                editor.focus();
            }
        }, 100);
    }
    
    // å¦‚æœåˆ‡æ¢åˆ°é¢„è§ˆï¼Œæ›´æ–°é¢„è§ˆå†…å®¹
    if (tab === 'preview') {
        updatePreview();
    }
}
        
        // è¿è¡Œä»£ç  (åœ¨æ–°çª—å£ä¸­å®Œæ•´æ‰§è¡Œ)
        function runCode() {
            showToast('æ­£åœ¨æ–°çª—å£ä¸­è¿è¡Œé¡¹ç›®...');
            
            // ä¿å­˜å½“å‰æ–‡ä»¶ä»¥ç¡®ä¿è¿è¡Œçš„æ˜¯æœ€æ–°ä»£ç 
            if (currentFileName && editor) {
                projectFiles.set(currentFileName, {
                    content: editor.getValue(),
                    type: getFileType(currentFileName),
                    lastModified: Date.now()
                });
            }
            
            // æ„å»ºåŒ…å«æ‰€æœ‰CSSå’ŒJSçš„å®Œæ•´HTML
            const fullHTML = buildProjectHTML();
            
            // åˆ›å»ºæ–°çª—å£æ¥è¿è¡Œä»£ç 
            const newWindow = window.open('', '_blank', 'width=1024,height=768,scrollbars=yes,resizable=yes');
            if (newWindow) {
                newWindow.document.write(fullHTML);
                newWindow.document.close();
                newWindow.document.title = 'è¿è¡Œ - ' + (currentFileName || 'æ–°é¡¹ç›®');
                
                // æ³¨å…¥è„šæœ¬ä»¥æ•è·æ–°çª—å£çš„æ§åˆ¶å°è¾“å‡º
                const script = newWindow.document.createElement('script');
                script.textContent = `
                    const originalConsole = { log: console.log, error: console.error, warn: console.warn, info: console.info };
                    ['log', 'error', 'warn', 'info'].forEach(method => {
                        console[method] = function(...args) {
                            if (window.opener && !window.opener.closed) {
                                window.opener.postMessage({ type: 'console', method: method, args: args.map(arg => String(arg)) }, '*');
                            }
                            originalConsole[method].apply(console, args);
                        };
                    });
                    window.addEventListener('error', (e) => {
                        if (window.opener && !window.opener.closed) {
                            window.opener.postMessage({ type: 'console', method: 'error', args: [e.message + ' (Line ' + e.lineno + ')'] }, '*');
                        }
                    });
                `;
                // ç¡®ä¿headå­˜åœ¨åå†æ·»åŠ 
                if(newWindow.document.head) {
                   newWindow.document.head.appendChild(script);
                }
                
                showToast('é¡¹ç›®å·²åœ¨æ–°çª—å£ä¸­è¿è¡Œ', 'success');
            } else {
                showToast('æ— æ³•æ‰“å¼€æ–°çª—å£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®', 'error');
            }
        }

        // æ›´æ–°é¢„è§ˆ (åœ¨åº”ç”¨å†…è¿›è¡Œé™æ€é¢„è§ˆï¼Œä¸æ‰§è¡Œè„šæœ¬)
        function updatePreview() {
            // ä¿å­˜å½“å‰æ–‡ä»¶
            if (currentFileName && editor) {
                projectFiles.set(currentFileName, {
                    content: editor.getValue(),
                    type: getFileType(currentFileName),
                    lastModified: Date.now()
                });
            }
        
            // æ„å»ºåŒ…å«æ‰€æœ‰CSSå’ŒJSçš„å®Œæ•´HTML
            const fullHTML = buildProjectHTML();
            const frame = document.getElementById('previewFrame');
        
            // ä½¿ç”¨ srcdoc å°†ä»£ç åŠ è½½åˆ° sandboxed iframe ä¸­ã€‚
            frame.srcdoc = fullHTML;
            
            showToast('é™æ€é¢„è§ˆå·²æ›´æ–°', 'info');
        }

        // åœ¨æ–°çª—å£ä¸­é¢„è§ˆï¼ˆè¿è¡Œï¼‰
        function previewInNewWindow() {
 
            runCode();
        }

// æ„å»ºé¡¹ç›®HTML
function buildProjectHTML() {
    // æŸ¥æ‰¾ä¸»HTMLæ–‡ä»¶
    let mainHTML = '';
    let mainHTMLFile = null;
    
    // ä¼˜å…ˆæŸ¥æ‰¾index.html
    if (projectFiles.has('index.html')) {
        mainHTMLFile = 'index.html';
        mainHTML = projectFiles.get('index.html').content;
    } else {
        // å¦åˆ™ä½¿ç”¨ç¬¬ä¸€ä¸ªHTMLæ–‡ä»¶
        for (const [filename, fileData] of projectFiles) {
            if (getFileType(filename) === 'html') {
                mainHTMLFile = filename;
                mainHTML = fileData.content;
                break;
            }
        }
    }
    
    // å¦‚æœæ²¡æœ‰HTMLæ–‡ä»¶ï¼Œä½¿ç”¨å½“å‰ç¼–è¾‘å™¨å†…å®¹
    if (!mainHTML) {
        mainHTML = editor.getValue();
    }
    
    // æ”¶é›†æ‰€æœ‰CSSå’ŒJSæ–‡ä»¶
    const cssFiles = [];
    const jsFiles = [];
    
    projectFiles.forEach((fileData, filename) => {
        if (filename === mainHTMLFile) return; // è·³è¿‡ä¸»HTMLæ–‡ä»¶
        
        const type = getFileType(filename);
        if (type === 'css') {
            cssFiles.push({ name: filename, content: fileData.content });
        } else if (type === 'javascript') {
            jsFiles.push({ name: filename, content: fileData.content });
        }
    });
    
    // æ³¨å…¥CSSå’ŒJSåˆ°HTML
    return injectResourcesIntoHTML(mainHTML, cssFiles, jsFiles);
}

// æ³¨å…¥èµ„æºåˆ°HTML
function injectResourcesIntoHTML(html, cssFiles, jsFiles) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // æ³¨å…¥CSS
    cssFiles.forEach(file => {
        // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰å¯¹åº”çš„linkæ ‡ç­¾
        const existingLink = doc.querySelector(`link[href="${file.name}"]`);
        if (!existingLink) {
            const style = doc.createElement('style');
            style.setAttribute('data-filename', file.name);
            style.textContent = `\n/* ${file.name} */\n${file.content}\n`;
            
            // æ’å…¥åˆ°headæœ«å°¾
            const head = doc.head || doc.querySelector('head');
            if (head) {
                head.appendChild(style);
            }
        }
    });
    
    // æ³¨å…¥JS
    jsFiles.forEach(file => {
        // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰å¯¹åº”çš„scriptæ ‡ç­¾
        const existingScript = doc.querySelector(`script[src="${file.name}"]`);
        if (!existingScript) {
            const script = doc.createElement('script');
            script.setAttribute('data-filename', file.name);
            script.textContent = `\n// ${file.name}\n${file.content}\n`;
            
            // æ’å…¥åˆ°bodyæœ«å°¾
            const body = doc.body || doc.querySelector('body');
            if (body) {
                body.appendChild(script);
            }
        }
    });
    
    // åºåˆ—åŒ–å›HTMLå­—ç¬¦ä¸²
    return '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
}
        
        // ç›‘å¬æ§åˆ¶å°æ¶ˆæ¯
        window.addEventListener('message', (e) => {
            // ç¡®ä¿æ¶ˆæ¯æ˜¯æˆ‘ä»¬æœŸæœ›çš„æ ¼å¼
            if (e.data && e.data.type === 'console') {
                // å°†æ‰€æœ‰å‚æ•°è¿æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ¯ä¸ªå‚æ•°ä¿ç•™è‡ªå·±çš„æ ¼å¼
                addConsoleEntry(e.data.method, e.data.args.join('\n'));
            }
        });
        
                // æ§åˆ¶å°æ¡ç›®
        function addConsoleEntry(method, message) {
            const content = document.getElementById('consoleContent');
            const messageKey = `${method}::${message}`;
        
            // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦å·²å­˜åœ¨ï¼ˆç”¨äºèšåˆï¼‰
            if (messageCounts[messageKey]) {
                messageCounts[messageKey].count++;
                messageCounts[messageKey].element.querySelector('.console-entry-count').textContent = messageCounts[messageKey].count;
            } else {
                // åˆ›å»ºæ–°çš„æ—¥å¿—æ¡ç›®
                const entry = document.createElement('div');
                entry.className = `console-entry ${method}`;
                
                // ä½¿ç”¨ pre æ ‡ç­¾æ¥ä¿ç•™æ ¼å¼åŒ–çš„JSONæ¢è¡Œ
                entry.innerHTML = `
                    <pre style="margin:0; white-space: pre-wrap; word-break: break-all;">${message}</pre>
                    <span class="console-entry-count">1</span>
                `;
        
                // å­˜å‚¨å¼•ç”¨ä»¥å¤‡å°†æ¥æ›´æ–°
                messageCounts[messageKey] = {
                    count: 1,
                    element: entry
                };
        
                content.appendChild(entry);
            }
        
            content.scrollTop = content.scrollHeight;
        }
        
        // æ¸…ç©ºæ§åˆ¶å°
        function clearConsole() {
            document.getElementById('consoleContent').innerHTML = '';
            // é‡ç½®æ¶ˆæ¯è®¡æ•°å™¨
            messageCounts = {};
            showToast('æ§åˆ¶å°å·²æ¸…ç©º');
        }
        
        // æ ¼å¼åŒ–ä»£ç 
        function formatCode() {
    closeSidebar();
    
    try {
        const code = editor.getValue();
        const formatted = formatHTML(code);
        
        if (formatted !== code) {
            editor.setValue(formatted);
            showToast('ä»£ç å·²æ ¼å¼åŒ–', 'success');
        } else {
            showToast('ä»£ç æ ¼å¼å·²ç»å¾ˆè§„èŒƒäº†', 'info');
        }
    } catch (e) {
        console.error('æ ¼å¼åŒ–é”™è¯¯:', e);
        showToast('æ ¼å¼åŒ–å¤±è´¥: ' + e.message, 'error');
    }
}

// è¿‡æ»¤æ§åˆ¶å°å†…å®¹
function filterConsole(type) {
    const content = document.getElementById('consoleContent');
    const entries = content.querySelectorAll('.console-entry');
    const filterButtons = document.querySelectorAll('.filter-btn');

    // æ›´æ–°æŒ‰é’®çš„æ¿€æ´»çŠ¶æ€
    filterButtons.forEach(btn => {
        btn.classList.toggle('active', btn.textContent.toLowerCase() === type);
    });

    // æ ¹æ®ç±»å‹æ˜¾ç¤ºæˆ–éšè—æ¡ç›®
    entries.forEach(entry => {
        if (type === 'all') {
            entry.classList.remove('hidden');
        } else {
            entry.classList.toggle('hidden', !entry.classList.contains(type));
        }
    });
}

// HTMLæ ¼å¼åŒ–æ ¸å¿ƒå‡½æ•°
function formatHTML(html) {
    // ç§»é™¤å¤šä½™çš„ç©ºç™½å­—ç¬¦ï¼Œä½†ä¿ç•™å†…å®¹ä¸­çš„ç©ºæ ¼
    let formatted = html.replace(/>\s+</g, '><').trim();
    
    // åˆ†å‰²æˆæ ‡ç­¾å’Œå†…å®¹
    const tokens = tokenizeHTML(formatted);
    
    let result = '';
    let indentLevel = 0;
    const indentStr = '    '; // å››ä¸ªç©ºæ ¼ä½œä¸ºç¼©è¿›
    
    // è‡ªé—­åˆæ ‡ç­¾åˆ—è¡¨
    const selfClosingTags = ['br', 'hr', 'img', 'input', 'meta', 'link', 'area', 'base', 'col', 'embed', 'source', 'track', 'wbr'];
    
    // å†…è”å…ƒç´ åˆ—è¡¨
    const inlineTags = ['a', 'span', 'strong', 'em', 'b', 'i', 'u', 'small', 'code', 'kbd', 'var', 'samp', 'sub', 'sup', 'mark', 'del', 'ins'];
    
    // éœ€è¦ç´§å‡‘æ ¼å¼çš„æ ‡ç­¾
    const compactTags = ['title', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'li', 'td', 'th', 'option'];
    
    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        
        if (token.type === 'tag') {
            const tagName = extractTagName(token.content);
            const isClosing = token.content.startsWith('</');
            const isSelfClosing = selfClosingTags.includes(tagName.toLowerCase()) || token.content.endsWith('/>');
            const isInline = inlineTags.includes(tagName.toLowerCase());
            const isCompact = compactTags.includes(tagName.toLowerCase());
            
            if (isClosing) {
                // ç»“æŸæ ‡ç­¾ï¼Œå‡å°‘ç¼©è¿›
                indentLevel = Math.max(0, indentLevel - 1);
                
                // æ£€æŸ¥å‰ä¸€ä¸ªtokenæ˜¯å¦æ˜¯æ–‡æœ¬å†…å®¹
                const prevToken = i > 0 ? tokens[i - 1] : null;
                const isAfterText = prevToken && prevToken.type === 'text' && prevToken.content.trim();
                
                if (!isInline && !isAfterText) {
                    result += '\n' + indentStr.repeat(indentLevel);
                }
                result += token.content;
                
                // ç»“æŸæ ‡ç­¾åçš„æ¢è¡Œé€»è¾‘
                if (!isInline && !isCompact && i < tokens.length - 1) {
                    const nextToken = tokens[i + 1];
                    if (nextToken.type === 'tag' && !nextToken.content.startsWith('</')) {
                        result += '\n';
                    }
                }
            } else {
                // å¼€å§‹æ ‡ç­¾æˆ–è‡ªé—­åˆæ ‡ç­¾
                if (!isInline && result && !result.endsWith('\n') && !result.endsWith('>')) {
                    result += '\n';
                }
                
                if (!isInline && (!result.endsWith('\n') || result.trim())) {
                    if (result && !result.endsWith('\n')) {
                        result += '\n';
                    }
                    result += indentStr.repeat(indentLevel);
                }
                
                result += token.content;
                
                // ç‰¹æ®Šå¤„ç†scriptå’Œstyleæ ‡ç­¾
                if (tagName.toLowerCase() === 'script' || tagName.toLowerCase() === 'style') {
                    if (!isSelfClosing) {
                        indentLevel++;
                        
                        // æŸ¥æ‰¾å¯¹åº”çš„ç»“æŸæ ‡ç­¾ï¼Œæ ¼å¼åŒ–å…¶ä¸­çš„å†…å®¹
                        let j = i + 1;
                        let content = '';
                        let contentTokens = [];
                        
                        while (j < tokens.length) {
                            if (tokens[j].type === 'tag' && tokens[j].content === `</${tagName}>`) {
                                break;
                            }
                            contentTokens.push(tokens[j]);
                            content += tokens[j].content;
                            j++;
                        }
                        
                        if (content.trim()) {
                            result += '\n';
                            const formattedContent = formatScriptOrStyle(content, tagName.toLowerCase(), indentLevel);
                            result += formattedContent;
                            if (!formattedContent.endsWith('\n')) {
                                result += '\n';
                            }
                            result += indentStr.repeat(indentLevel - 1);
                        }
                        
                        i = j - 1; // è·³è¿‡å·²å¤„ç†çš„å†…å®¹
                    }
                } else if (!isSelfClosing) {
                    indentLevel++;
                    
                    // æ£€æŸ¥ä¸‹ä¸€ä¸ªtoken
                    if (i < tokens.length - 1) {
                        const nextToken = tokens[i + 1];
                        if (nextToken.type === 'text' && nextToken.content.trim()) {
                            // å¦‚æœæ˜¯ç´§å‡‘æ ‡ç­¾æˆ–çŸ­æ–‡æœ¬ï¼Œä¸æ·»åŠ æ¢è¡Œ
                            if (isCompact || (nextToken.content.length < 80 && !nextToken.content.includes('\n'))) {
                                // ä¿æŒåœ¨åŒä¸€è¡Œ
                            } else {
                                result += '\n';
                            }
                        } else if (nextToken.type === 'tag' && !isInline) {
                            result += '\n';
                        }
                    }
                }
            }
        } else if (token.type === 'text') {
            const trimmedContent = token.content.trim();
            if (trimmedContent) {
                // å¯¹äºé•¿æ–‡æœ¬æˆ–åŒ…å«æ¢è¡Œçš„æ–‡æœ¬ï¼Œè¿›è¡Œé€‚å½“æ ¼å¼åŒ–
                if (trimmedContent.length > 100 || trimmedContent.includes('\n')) {
                    const lines = trimmedContent.split('\n');
                    for (let k = 0; k < lines.length; k++) {
                        const line = lines[k].trim();
                        if (line) {
                            if (k > 0) {
                                result += '\n' + indentStr.repeat(indentLevel);
                            }
                            result += line;
                        }
                    }
                } else {
                    result += trimmedContent;
                }
            }
        } else if (token.type === 'comment') {
            if (result && !result.endsWith('\n')) {
                result += '\n';
            }
            result += indentStr.repeat(indentLevel) + token.content;
            if (i < tokens.length - 1) {
                result += '\n';
            }
        } else if (token.type === 'doctype') {
            result += token.content;
            if (i < tokens.length - 1) {
                result += '\n';
            }
        }
    }
    
    // æ¸…ç†å¤šä½™çš„ç©ºè¡Œ
    return result.replace(/\n\s*\n\s*\n/g, '\n\n').trim();
}

// HTMLæ ‡è®°åŒ–å‡½æ•°
function tokenizeHTML(html) {
    const tokens = [];
    let i = 0;
    
    while (i < html.length) {
        if (html[i] === '<') {
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ³¨é‡Š
            if (html.substring(i, i + 4) === '<!--') {
                // æŸ¥æ‰¾æ³¨é‡Šç»“æŸ
                let j = html.indexOf('-->', i + 4);
                if (j !== -1) {
                    const commentContent = html.substring(i, j + 3);
                    tokens.push({ type: 'comment', content: commentContent });
                    i = j + 3;
                    continue;
                } else {
                    // æ²¡æœ‰æ‰¾åˆ°æ³¨é‡Šç»“æŸï¼Œä½œä¸ºæ–‡æœ¬å¤„ç†
                    tokens.push({ type: 'text', content: html[i] });
                    i++;
                    continue;
                }
            }
            
            // æŸ¥æ‰¾æ ‡ç­¾ç»“æŸ
            let j = i + 1;
            let inQuote = false;
            let quoteChar = '';
            
            while (j < html.length) {
                if (!inQuote && (html[j] === '"' || html[j] === "'")) {
                    inQuote = true;
                    quoteChar = html[j];
                } else if (inQuote && html[j] === quoteChar && html[j-1] !== '\\') {
                    inQuote = false;
                    quoteChar = '';
                } else if (!inQuote && html[j] === '>') {
                    break;
                }
                j++;
            }
            
            if (j < html.length) {
                const tagContent = html.substring(i, j + 1);
                
                // åˆ¤æ–­æ ‡ç­¾ç±»å‹
                if (tagContent.toLowerCase().startsWith('<!doctype')) {
                    tokens.push({ type: 'doctype', content: tagContent });
                } else {
                    tokens.push({ type: 'tag', content: tagContent });
                }
                
                i = j + 1;
            } else {
                // æ²¡æœ‰æ‰¾åˆ°ç»“æŸçš„>ï¼Œä½œä¸ºæ–‡æœ¬å¤„ç†
                tokens.push({ type: 'text', content: html[i] });
                i++;
            }
        } else {
            // æ–‡æœ¬å†…å®¹
            let textStart = i;
            while (i < html.length && html[i] !== '<') {
                i++;
            }
            
            const textContent = html.substring(textStart, i);
            if (textContent) {
                tokens.push({ type: 'text', content: textContent });
            }
        }
    }
    
    return tokens;
}

// æå–æ ‡ç­¾åå‡½æ•°
function extractTagName(tagContent) {
    const match = tagContent.match(/<\/?([a-zA-Z][a-zA-Z0-9]*)/);
    return match ? match[1] : '';
}

// æ ¼å¼åŒ–è„šæœ¬å’Œæ ·å¼å†…å®¹
function formatScriptOrStyle(content, tagType, baseIndent) {
    const indentStr = '    ';
    const lines = content.split('\n');
    let result = '';
    let currentIndent = 0;
    let inMultiLineComment = false;
    let previousLineWasClosingBrace = false;
    let previousLineWasAtRule = false;
    let inAtRuleBlock = false;
    let atRuleDepth = 0;
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) {
            // å®Œå…¨è·³è¿‡ç©ºè¡Œ
            continue;
        }
        
        if (tagType === 'script') {
            // JavaScriptæ ¼å¼åŒ–
            
            // å¤„ç†å¤šè¡Œæ³¨é‡Š
            if (line.includes('/*') && !line.includes('*/')) {
                inMultiLineComment = true;
            } else if (line.includes('*/')) {
                inMultiLineComment = false;
            }
            
            // å¦‚æœæ˜¯æ³¨é‡Šè¡Œï¼Œä¿æŒåŸæ ·
            if (line.startsWith('//') || line.startsWith('/*') || line.startsWith('*') || inMultiLineComment) {
                result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
                continue;
            }
            
            // å¤„ç†å¤§æ‹¬å·
            if (line.includes('}') && !line.includes('{')) {
                currentIndent = Math.max(0, currentIndent - 1);
                result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
            } else if (line.includes('{') && !line.includes('}')) {
                result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
                currentIndent++;
            } else if (line.includes('{') && line.includes('}')) {
                // å•è¡Œå‡½æ•°æˆ–å¯¹è±¡
                result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
            } else {
                result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
            }
            
            // åœ¨å‡½æ•°ä¹‹é—´æ·»åŠ ç©ºè¡Œ
            if (line.includes('}') && !line.includes('{') && currentIndent === 0) {
                if (i < lines.length - 1 && lines[i + 1].trim()) {
                    result += '\n';
                }
            }
            
        } else if (tagType === 'style') {
            // CSSæ ¼å¼åŒ– - ç¼©è¿›ä½ç½®
            
            // å¦‚æœæ˜¯æ³¨é‡Šè¡Œï¼Œä¿æŒåŸæ ·
            if (line.startsWith('/*') || line.startsWith('*') || line.endsWith('*/')) {
                result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
                previousLineWasClosingBrace = false;
                previousLineWasAtRule = false;
                continue;
            }
            
            // æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦æ˜¯@è§„åˆ™æˆ–æ™®é€šé€‰æ‹©å™¨
            const isAtRule = line.startsWith('@');
            const isSelector = !isAtRule && (line.includes('{') || (!line.includes(':') && !line.includes('}')));
            
            // å¤„ç†å¤§æ‹¬å·
            if (line.includes('{')) {
                // å¦‚æœæ˜¯@è§„åˆ™æˆ–æ™®é€šé€‰æ‹©å™¨å¼€å§‹
                if (isAtRule || isSelector) {
                    // å¦‚æœä¸Šä¸€è¡Œæ˜¯ç»“æŸå¤§æ‹¬å·ï¼Œæ·»åŠ ç©ºè¡Œï¼Œå¹¶ç¡®ä¿ä»åŸºç¡€ç¼©è¿›å¼€å§‹
                    if (previousLineWasClosingBrace) {
                        result += '\n';
                        // é‡ç½®ç¼©è¿›åˆ°åŸºç¡€çº§åˆ«
                        currentIndent = 0;
                    }
                    
                    result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
                    currentIndent++;
                    
                    // å¦‚æœæ˜¯@è§„åˆ™ï¼Œæ ‡è®°è¿›å…¥@è§„åˆ™å—
                    if (isAtRule) {
                        inAtRuleBlock = true;
                        atRuleDepth = currentIndent;
                    }
                } else {
                    // å…¶ä»–æƒ…å†µï¼ˆå¦‚@è§„åˆ™å†…éƒ¨çš„ç™¾åˆ†æ¯”è§„åˆ™ï¼‰
                    result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
                    currentIndent++;
                }
                
                previousLineWasClosingBrace = false;
                previousLineWasAtRule = false;
            } else if (line.includes('}')) {
                // å¤„ç†ç»“æŸå¤§æ‹¬å·
                currentIndent = Math.max(0, currentIndent - 1);
                result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
                
                // å¦‚æœé€€å‡ºäº†@è§„åˆ™å—
                if (inAtRuleBlock && currentIndent < atRuleDepth) {
                    inAtRuleBlock = false;
                    atRuleDepth = 0;
                    // ç¡®ä¿ä¸‹ä¸€ä¸ªè§„åˆ™ä»åŸºç¡€ç¼©è¿›å¼€å§‹
                    currentIndent = 0;
                }
                
                previousLineWasClosingBrace = true;
                previousLineWasAtRule = false;
            } else {
                // CSSå±æ€§æˆ–@è§„åˆ™å£°æ˜
                result += indentStr.repeat(baseIndent + currentIndent) + line + '\n';
                previousLineWasClosingBrace = false;
                previousLineWasAtRule = isAtRule && !inAtRuleBlock;
            }
        }
    }
    
    return result.trimEnd();
}
        
        // ä¿å­˜ä»£ç 
function saveCode() {
    // ä¿å­˜å½“å‰æ–‡ä»¶åˆ°é¡¹ç›®
    if (currentFileName && editor) {
        projectFiles.set(currentFileName, {
            content: editor.getValue(),
            type: getFileType(currentFileName),
            lastModified: Date.now()
        });
    }
    
    // ä¿å­˜æ•´ä¸ªé¡¹ç›®åˆ°æœ¬åœ°å­˜å‚¨
    const projectData = {
        files: Array.from(projectFiles.entries()),
        currentFile: currentFileName,
        version: '2.0', // ç‰ˆæœ¬æ ‡è¯†
        savedAt: Date.now() // ä¿å­˜æ—¶é—´æˆ³
    };
    
    try {
        localStorage.setItem('htmlEditorProject', JSON.stringify(projectData));
        showToast(`é¡¹ç›®å·²ä¿å­˜ (${projectFiles.size} ä¸ªæ–‡ä»¶)`, 'success');
    } catch (error) {
        if (error.name === 'QuotaExceededError') {
            showToast('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·åˆ é™¤ä¸€äº›æ–‡ä»¶', 'error');
            showFileManager(); // æ‰“å¼€æ–‡ä»¶ç®¡ç†å™¨è®©ç”¨æˆ·åˆ é™¤æ–‡ä»¶
        } else {
            showToast('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
        }
    }
}
        
        // å¯¼å‡ºä»£ç 
function exportCode() {
    closeSidebar();
    
    try {
        const code = editor.getValue();
        
        // æ£€æŸ¥ä»£ç æ˜¯å¦ä¸ºç©º
        if (!code.trim()) {
            showToast('ç¼–è¾‘å™¨å†…å®¹ä¸ºç©ºï¼Œæ— æ³•å¯¼å‡º', 'warning');
            return;
        }
        
        // åˆ›å»ºBlobå¯¹è±¡
        const blob = new Blob([code], { 
            type: 'text/html;charset=utf-8' 
        });
        
        // ç”Ÿæˆæ–‡ä»¶å
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `html-export-${timestamp}.html`;
        
        // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
        if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            // IE/Edge æ”¯æŒ
            window.navigator.msSaveOrOpenBlob(blob, filename);
        } else {
            // ç°ä»£æµè§ˆå™¨
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            // è®¾ç½®ä¸‹è½½å±æ€§
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            
            // æ·»åŠ åˆ°DOMå¹¶è§¦å‘ç‚¹å‡»
            document.body.appendChild(a);
            a.click();
            
            // æ¸…ç†
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }
        
        showToast('æ–‡ä»¶å¯¼å‡ºæˆåŠŸï¼', 'success');
        
    } catch (error) {
        console.error('å¯¼å‡ºå¤±è´¥:', error);
        showToast('å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
    }
}
        
        // æ¸…ç©ºç¼–è¾‘å™¨
        function clearEditor() {
            closeSidebar();
            
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ä»£ç å—ï¼Ÿ')) {
                editor.setValue('');
                clearConsole();
                showToast('ç¼–è¾‘å™¨å·²æ¸…ç©º');
            }
        }
        
        // æ˜¾ç¤ºæ–¹æ³•æ›¿æ¢å¯¹è¯æ¡†
        function showMethodReplace() {
            closeSidebar();
            showDialog('methodReplaceDialog');
        }
        
        // åˆ†ææ–¹æ³•
        function analyzeMethod() {
            const input = document.getElementById('methodInput').value.trim();
            if (!input) {
                showToast('è¯·è¾“å…¥è¦åˆ†æçš„ä»£ç ', 'error');
                return;
            }

            detectedMethod = parseInputIntoBlocks(input);

            const listContainer = document.getElementById('detectedMethod');
            listContainer.innerHTML = '';

            if (detectedMethod.length > 0) {
                detectedMethod.forEach(block => {
                    const blockDiv = document.createElement('div');
                    blockDiv.className = 'method-info';
                    blockDiv.style.cssText = 'border: 1px solid #333; padding: 8px; margin-bottom: 8px; border-radius: 4px;';
                    blockDiv.innerHTML = `
                        <span class="method-name" style="color: #64B5F6;">[${block.type.toUpperCase()}] ${block.name}</span>
                        <span class="method-status">âœ“ å·²è¯†åˆ«</span>
                    `;
                    listContainer.appendChild(blockDiv);
                });

                listContainer.style.display = 'block';
                const replaceBtn = document.getElementById('replaceBtn');
                replaceBtn.style.display = 'inline-block';
                replaceBtn.textContent = `æ›¿æ¢ ${detectedMethod.length} é¡¹`;
                showToast(`æˆåŠŸè¯†åˆ« ${detectedMethod.length} ä¸ªä»£ç å—`, 'success');
            } else {
                listContainer.style.display = 'none';
                document.getElementById('replaceBtn').style.display = 'none';
                showToast('æœªèƒ½è¯†åˆ«ä»»ä½•æœ‰æ•ˆçš„ JS/CSS/HTML ä»£ç å—', 'error');
            }
        }

// éªŒè¯æ–¹æ³•ä»£ç å®Œæ•´æ€§
function validateMethodCode(code) {
    // æ£€æŸ¥å¤§æ‹¬å·åŒ¹é…
    let braceCount = 0;
    let inString = false;
    let stringChar = '';
    
    for (let i = 0; i < code.length; i++) {
        const char = code[i];
        const prevChar = i > 0 ? code[i - 1] : '';
        
        if (!inString && (char === '"' || char === "'" || char === '`')) {
            inString = true;
            stringChar = char;
        } else if (inString && char === stringChar && prevChar !== '\\') {
            inString = false;
            stringChar = '';
        } else if (!inString) {
            if (char === '{') braceCount++;
            else if (char === '}') braceCount--;
        }
    }
    
    return braceCount === 0;
}

// è·å–æ–¹æ³•ç±»å‹æ–‡æœ¬
function getMethodTypeText(type) {
    const typeMap = {
        'function': 'å‡½æ•°',
        'object-method': 'å¯¹è±¡æ–¹æ³•',
        'arrow-function': 'ç®­å¤´å‡½æ•°',
        'class-method': 'ç±»æ–¹æ³•',
        'async-function': 'å¼‚æ­¥å‡½æ•°',
        'generator-function': 'ç”Ÿæˆå™¨å‡½æ•°'
    };
    return typeMap[type] || 'æ–¹æ³•';
}
        
// æ‰§è¡Œæ›¿æ¢
        function executeReplace() {
            if (!detectedMethod || detectedMethod.length === 0) {
                showToast('æ²¡æœ‰å¯æ›¿æ¢çš„é¡¹', 'error');
                return;
            }

            let currentCode = editor.getValue();
            let originalCode = currentCode;
            let replacementsMade = 0;
            let operations = [];

            for (const block of detectedMethod) {
                const positions = findTargetPositions(currentCode, block);
                if (positions.length > 0) {
                    positions.forEach(pos => {
                        operations.push({
                            start: pos.start,
                            end: pos.end,
                            newCode: block.code,
                            name: block.name
                        });
                    });
                } else {
                    showToast(`åœ¨ç¼–è¾‘å™¨ä¸­æœªæ‰¾åˆ° ${block.type} "${block.name}"`, 'warning');
                }
            }

            if (operations.length === 0) {
                showToast('æœªæ‰¾åˆ°ä»»ä½•å¯æ›¿æ¢çš„ä»£ç ', 'info');
                return;
            }

            operations.sort((a, b) => b.start - a.start);

            operations.forEach(op => {
                currentCode = currentCode.substring(0, op.start) + op.newCode + currentCode.substring(op.end);
                replacementsMade++;
            });

            if (replacementsMade > 0) {
                editor.setValue(currentCode);
                closeDialog('methodReplaceDialog');
                showToast(`æˆåŠŸæ›¿æ¢äº† ${replacementsMade} å¤„`, 'success');

                const names = detectedMethod.map(b => b.name).join(', ');
                addHistory({
                    name: `æ‰¹é‡æ›¿æ¢: ${names.substring(0, 50)}...`,
                    type: 'batch',
                    time: new Date(),
                    oldCode: originalCode,
                    newCode: currentCode,
                    replacedCount: replacementsMade
                });
            } else {
                showToast('æ²¡æœ‰è¿›è¡Œä»»ä½•æ›¿æ¢', 'info');
            }
        }
        
                function findBlockEnd(code, start, openChar, closeChar) {
            let depth = 1;
            let pos = start + 1;

            while (depth > 0 && pos < code.length) {
                const char = code[pos];
                const prevChar = code[pos - 1] || '';
                const nextChar = code[pos + 1] || '';

                if (char === '/' && nextChar === '*') {
                    const commentEnd = code.indexOf('*/', pos + 2);
                    pos = (commentEnd === -1) ? code.length : commentEnd + 1;
                } else if (char === '/' && nextChar === '/') {
                    const commentEnd = code.indexOf('\n', pos + 2);
                    pos = (commentEnd === -1) ? code.length : commentEnd;
                } else if (char === "'" || char === '"' || char === '`') {
                    let strEnd = pos + 1;
                    while (strEnd < code.length) {
                        if (code[strEnd] === '\\') {
                            strEnd++;
                        } else if (code[strEnd] === char) {
                            break;
                        }
                        strEnd++;
                    }
                    pos = strEnd;
                } else if (openChar === '<' && char === '<' && !/\s/.test(nextChar) && nextChar !== '/') {
                     depth++;
                } else if (openChar === '<' && char ==='/' && prevChar === '<') {
                     depth--;
                } else if (char === openChar) {
                    depth++;
                } else if (char === closeChar) {
                    depth--;
                }
                pos++;
            }
            return depth === 0 ? pos : -1;
        }

        function parseInputIntoBlocks(text) {
    const allMatches = [];
    // JSå…³é”®å­—ï¼Œç”¨äºæ’é™¤if(){}, for(){}ç­‰æ§åˆ¶æµè¯­å¥
    const jsKeywords = new Set(['if', 'for', 'while', 'switch', 'catch', 'do', 'else']);

    const patterns = [
        // 1. æ ‡å‡†å‡½æ•°: function funcName(...) {
        {
            regex: /function\s*\*?\s*([\w$]+)\s*\([^)]*\)\s*\{/g,
            type: 'javascript-function',
            nameIndex: 1
        },
        // 2. ç®­å¤´å‡½æ•°: const funcName = (...) => {
        {
            regex: /(?:const|let|var)\s+([\w$]+)\s*=\s*(?:async\s*)?\([^)]*\)\s*=>\s*\{/g,
            type: 'javascript-arrow',
            nameIndex: 1
        },
        // 3. å¯¹è±¡/ç±»æ–¹æ³•ç®€å†™: funcName(...) {  (å…³é”®å­—æ’é™¤)
        {
            regex: /\b([\w$]+)\s*\([^)]*\)\s*\{/g,
            type: 'javascript-shorthand',
            nameIndex: 1
        },
        // 4. CSSè§„åˆ™
        {
            regex: /((?:[^{}]|\/(?!\*))+?)\s*\{/g,
            type: 'css',
            nameIndex: 1
        },
        // 5. HTML å—
        {
            regex: /<([a-zA-Z0-9]+)(?:[^>"]|"[^"]*")*>/g,
            type: 'html',
            nameIndex: 1
        }
    ];

    for (const pattern of patterns) {
        for (const match of text.matchAll(pattern.regex)) {
            // å¦‚æœæ˜¯æ–¹æ³•ç®€å†™ï¼Œè¿›è¡Œå…³é”®å­—è¿‡æ»¤
            if (pattern.type === 'javascript-shorthand') {
                if (jsKeywords.has(match[pattern.nameIndex])) {
                    continue; // è·³è¿‡ if, for ç­‰å…³é”®å­—
                }
            }
            
            // å¯¹CSSè¿›è¡ŒäºŒæ¬¡æ ¡éªŒï¼Œæ’é™¤JSå‡½æ•°ç­‰
            if (pattern.type === 'css') {
                const selector = match[pattern.nameIndex].trim();
                 if (selector.includes('=>') || selector.includes('function') || selector.endsWith(':')) {
                    continue; // å¦‚æœåŒ…å«å‡½æ•°ç‰¹å¾ï¼Œåˆ™è·³è¿‡
                }
            }

            const openChar = pattern.type === 'html' ? '<' : '{';
            const closeChar = pattern.type === 'html' ? '>' : '}';
            const blockStartIndex = pattern.type === 'html' ? match.index : match.index + match[0].length - 1;

            const end = findBlockEnd(text, blockStartIndex, openChar, closeChar);
            if (end !== -1) {
                const blockCode = text.substring(match.index, end);
                allMatches.push({
                    type: pattern.type,
                    code: blockCode,
                    name: match[pattern.nameIndex].trim(),
                    index: match.index,
                    length: blockCode.length
                });
            }
        }
    }

    allMatches.sort((a, b) => a.index - b.index);
    const topLevelBlocks = [];
    let lastEndIndex = -1;

    for (const match of allMatches) {
        if (match.index >= lastEndIndex) {
            // å¯¹äºHTMLï¼Œè¿›è¡Œç‰¹æ®Šå‘½åå¤„ç†
            if (match.type === 'html') {
                const idMatch = match.code.match(/id\s*=\s*["']([^"']+)["']/);
                const classMatch = match.code.match(/class\s*=\s*["']([^"']+)["']/);
                if (idMatch) {
                    match.name = `#${idMatch[1]}`;
                } else if (classMatch) {
                    const tagName = match.code.match(/<([a-zA-Z0-9]+)/)[1];
                    match.name = `&lt;${tagName}.${classMatch[1].split(' ')[0]}&gt;`;
                } else {
                     match.name = `&lt;${match.name}&gt;`;
                }
            }
            topLevelBlocks.push(match);
            lastEndIndex = match.index + match.length;
        }
    }
    return topLevelBlocks;
}
        
        function findTargetPositions(code, block) {
    const positions = [];
    let searchIndex = 0;
    const escapedName = block.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    let identifierRegex;

    // æ ¹æ®ä¸åŒçš„å—ç±»å‹ï¼Œä½¿ç”¨ä¸åŒçš„ã€æ›´ç²¾ç¡®çš„æ­£åˆ™è¡¨è¾¾å¼æ¥å®šä½
    switch (block.type) {
        case 'javascript-function':
            identifierRegex = new RegExp(`function\\s+\\*?\\s*${escapedName}\\b`);
            break;
        case 'javascript-arrow':
            identifierRegex = new RegExp(`(const|let|var)\\s+${escapedName}\\b`);
            break;
        case 'javascript-shorthand':
            // ç¡®ä¿åŒ¹é…çš„æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å•è¯ï¼ˆæ–¹æ³•åï¼‰ï¼Œå‰é¢ä¸èƒ½æ˜¯functionç­‰å…³é”®å­—
            identifierRegex = new RegExp(`\\b${escapedName}\\s*\\([^)]*\\)\\s*\\{`);
            break;
        case 'css':
            identifierRegex = new RegExp(`(^|\\s|\\}|;|,)${escapedName}\\s*\\{`);
            break;
        case 'html':
            const idMatch = block.name.match(/#(\S+)/);
            if (idMatch) {
                const tagNameMatch = block.code.match(/<([a-zA-Z0-9]+)/);
                const tagName = tagNameMatch ? tagNameMatch[1] : '\\w+';
                identifierRegex = new RegExp(`<${tagName}[^>]*id\\s*=\\s*["']${idMatch[1]}["'][^>]*>`);
            } else {
                return []; // ä¸ºå®‰å…¨èµ·è§ï¼ŒéIDçš„HTMLæ›¿æ¢éœ€è¦æ›´å¤æ‚çš„é€»è¾‘ï¼Œæš‚ä¸å¤„ç†
            }
            break;
        default:
            return [];
    }

    while (searchIndex < code.length) {
        const match = code.substring(searchIndex).match(identifierRegex);
        if (!match) break;

        let blockStart;
        let openChar;
        let closeChar;

        if (block.type === 'html') {
            blockStart = searchIndex + match.index;
            openChar = '<';
            closeChar = '>';
        } else {
            blockStart = searchIndex + match.index + (block.type === 'css' ? match[1].length : 0);
            openChar = '{';
            closeChar = '}';
        }

        const braceOrTagStart = (block.type === 'html') ? blockStart : code.indexOf('{', blockStart);
        if (braceOrTagStart === -1) break;

        const blockEnd = findBlockEnd(code, braceOrTagStart, openChar, closeChar);

        if (blockEnd !== -1) {
            // ç‰¹åˆ«é’ˆå¯¹JSæ–¹æ³•ç®€å†™è¿›è¡Œè¿‡æ»¤ï¼Œæ’é™¤if/forç­‰æƒ…å†µ
            if (block.type === 'javascript-shorthand') {
                const jsKeywords = new Set(['if', 'for', 'while', 'switch', 'catch', 'do', 'else']);
                const potentialKeywordMatch = code.substring(0, blockStart).match(/(\w+)$/);
                if (potentialKeywordMatch && jsKeywords.has(potentialKeywordMatch[1])) {
                    searchIndex = blockEnd;
                    continue;
                }
            }
            
            positions.push({ start: blockStart, end: blockEnd });
            searchIndex = blockEnd;
        } else {
            searchIndex = braceOrTagStart + 1;
        }
    }
    return positions;
}

function executeReplace() {
    if (!detectedMethod || detectedMethod.length === 0) {
        showToast('æ²¡æœ‰å¯æ›¿æ¢çš„é¡¹', 'error');
        return;
    }

    let currentCode = editor.getValue();
    let operations = [];

    for (const block of detectedMethod) {
        const positions = findTargetPositions(currentCode, block);
        if (positions.length > 0) {
            positions.forEach(pos => {
                // è·å–è¡Œå·
                const startPos = editor.posFromIndex(pos.start);
                operations.push({
                    start: pos.start,
                    end: pos.end,
                    newCode: block.code,
                    name: block.name,
                    type: block.type,
                    line: startPos.line + 1 // lineæ˜¯0-based, è½¬ä¸º1-based
                });
            });
        } else {
            showToast(`åœ¨ç¼–è¾‘å™¨ä¸­æœªæ‰¾åˆ° ${block.type} "${block.name}"`, 'warning');
        }
    }

    if (operations.length === 0) {
        showToast('æœªæ‰¾åˆ°ä»»ä½•å¯æ›¿æ¢çš„ä»£ç ', 'info');
        return;
    }

    // æš‚å­˜æ“ä½œå¹¶æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
    _pendingReplacements = operations;
    showReplacementConfirmation(_pendingReplacements);
}

        function showReplacementConfirmation(operations) {
        // å…ˆç§»é™¤å¯èƒ½å­˜åœ¨çš„æ—§å¯¹è¯æ¡†ï¼Œä½†ä¸è°ƒç”¨ä¼šæ¸…é™¤æ•°æ®çš„ closeReplacementConfirmation()
        const existingDialog = document.getElementById('replacementConfirmDialog');
        if (existingDialog) {
            existingDialog.remove();
        }

        const dialog = document.createElement('div');
        dialog.className = 'dialog active';
        dialog.id = 'replacementConfirmDialog';

        const listItems = operations.map(op => `
            <li class="replacement-confirm-item">
                å°†æ›¿æ¢ç¬¬ <strong>${op.line}</strong> è¡Œçš„ <strong>[${op.type.toUpperCase().replace('JAVASCRIPT-', '')}]</strong>: <code>${op.name}</code>
            </li>
        `).join('');

        dialog.innerHTML = `
            <div class="dialog-header">
                <h3 class="dialog-title">ç¡®è®¤æ›¿æ¢æ“ä½œ</h3>
                <button class="icon-btn icon-close" onclick="closeReplacementConfirmation()"></button>
            </div>
            <div class="dialog-content">
                <p>å°†æ‰§è¡Œä»¥ä¸‹ ${operations.length} é¡¹æ›¿æ¢ï¼Œè¯·ç¡®è®¤ï¼š</p>
                <ul class="replacement-confirm-list">${listItems}</ul>
            </div>
            <div class="dialog-actions">
                <button class="btn btn-text" onclick="closeReplacementConfirmation()">å–æ¶ˆ</button>
                <button class="btn btn-primary" onclick="performActualReplacement()">ç¡®è®¤æ›¿æ¢</button>
            </div>
        `;

        document.body.appendChild(dialog);
        document.getElementById('overlay').classList.add('active');
    }

    function closeReplacementConfirmation() {
        const dialog = document.getElementById('replacementConfirmDialog');
        if (dialog) {
            dialog.remove();
        }
        // åªæœ‰åœ¨æ²¡æœ‰å…¶ä»–å¯¹è¯æ¡†æ—¶æ‰éšè—é®ç½©å±‚
        if (document.querySelectorAll('.dialog.active').length === 0) {
            document.getElementById('overlay').classList.remove('active');
        }
        _pendingReplacements = []; // æ¸…ç†æš‚å­˜çš„æ“ä½œ
    }

                function performActualReplacement() {
            const operations = _pendingReplacements;
            if (!operations || operations.length === 0) {
                showToast('æ²¡æœ‰å¾…å¤„ç†çš„æ›¿æ¢æ“ä½œ', 'error');
                return;
            }
        
            let currentCode = editor.getValue();
            const originalCode = currentCode;
            let replacementsMade = 0;
        
            // æ ¹æ®èµ·å§‹ä½ç½®ä»åå¾€å‰æ’åºï¼Œé˜²æ­¢æ›¿æ¢æ—¶ä½ç½®é”™ä¹±
            operations.sort((a, b) => b.start - a.start);
        
            operations.forEach(op => {
                currentCode = currentCode.substring(0, op.start) + op.newCode + currentCode.substring(op.end);
                replacementsMade++;
            });
        
            // ä»…åœ¨ä»£ç ç¡®å®å‘ç”Ÿæ”¹å˜æ—¶æ‰æ‰§è¡Œæ›´æ–°å’Œè®°å½•
            if (currentCode !== originalCode) {
                editor.setValue(currentCode);
        
                // ================== æ¡ä»¶è·³è½¬é€»è¾‘ ==================
                if (replacementsMade === 1) {
                    // ã€æƒ…å†µä¸€ï¼šåªæ›¿æ¢äº†ä¸€ä¸ªã€‘è·³è½¬å¹¶é«˜äº®
                    const op = operations[0]; // è·å–è¿™å”¯ä¸€çš„æ“ä½œ
                    const pos = editor.posFromIndex(op.start); // è®¡ç®—æ›¿æ¢åçš„èµ·å§‹ä½ç½®
        
                    // ç¡®ä¿ç¼–è¾‘å™¨æ˜¯æ¿€æ´»çŠ¶æ€
                    switchTab('editor');
        
                    // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿ç¼–è¾‘å™¨æ¸²æŸ“å®Œæˆ
                    setTimeout(() => {
                        editor.focus();
                        editor.setCursor(pos); // è®¾ç½®å…‰æ ‡
                        editor.scrollIntoView({ line: pos.line, ch: 0 }, 200); // å°†è¯¥è¡Œæ»šåŠ¨åˆ°è§†å›¾ä¸­å¤®
        
                        // ä¸€ä¸ªçŸ­æš‚çš„é«˜äº®æ•ˆæœ
                        const endPos = editor.posFromIndex(op.start + op.newCode.length);
                        const mark = editor.markText(pos, endPos, {
                            className: 'replaced-text-highlight'
                        });
        
                        // 2.5ç§’åç§»é™¤é«˜äº®
                        setTimeout(() => mark.clear(), 2500);
        
                        showToast('æˆåŠŸæ›¿æ¢1å¤„å¹¶å·²è·³è½¬', 'success');
                    }, 100);
        
                } else {
                    // ã€æƒ…å†µäºŒï¼šæ›¿æ¢äº†å¤šä¸ªã€‘åªåšæç¤ºï¼Œä¸è·³è½¬
                    showToast(`æˆåŠŸæ›¿æ¢äº† ${replacementsMade} å¤„`, 'success');
                }
                // ========================================================
        
                const replacedNames = [...new Set(operations.map(op => op.name))].join(', ');
                addHistory({
                    name: `æ‰¹é‡æ›¿æ¢: ${replacedNames.substring(0, 50)}...`,
                    type: 'batch',
                    time: new Date(),
                    oldCode: originalCode,
                    newCode: currentCode,
                    replacedCount: replacementsMade
                });
            } else {
                 showToast('ä»£ç æ— å˜åŒ–ï¼Œæœªæ‰§è¡Œæ›¿æ¢', 'info');
            }
        
            closeReplacementConfirmation();
            closeDialog('methodReplaceDialog'); // å…³é—­åŸå§‹çš„æ›¿æ¢å¯¹è¯æ¡†
        }

// è·å–è¡Œåˆ—ä½ç½®
function getLineColumn(text, index) {
    const lines = text.substring(0, index).split('\n');
    return {
        line: lines.length - 1,
        column: lines[lines.length - 1].length
    };
}
        
        // æ·»åŠ åˆ°å†å²è®°å½•
        function addHistory(record) {
    // å…ƒæ•°æ®
    const historyRecord = {
        ...record,
        id: Date.now(),
        codeHash: generateCodeHash(record.oldCode),
        preview: generateMethodPreview(record.name, record.type)
    };
    
    replaceHistory.unshift(historyRecord);
    
    // å†å²è®°å½•æ•°é‡é™åˆ¶
    if (replaceHistory.length > 100) {
        replaceHistory = replaceHistory.slice(0, 100);
    }
    
    localStorage.setItem('replaceHistory', JSON.stringify(replaceHistory));
}

// ç”Ÿæˆä»£ç å“ˆå¸Œ
function generateCodeHash(code) {
    let hash = 0;
    for (let i = 0; i < code.length; i++) {
        const char = code.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return hash.toString(36);
}

// ç”Ÿæˆæ–¹æ³•é¢„è§ˆ
function generateMethodPreview(methodName, methodType) {
    const typeIcon = {
        'function': 'ğŸ”§',
        'object-method': 'ğŸ“¦',
        'arrow-function': 'â¡ï¸',
        'class-method': 'ğŸ—ï¸',
        'async-function': 'âš¡',
        'generator-function': 'ğŸ”„'
    };
    
    return `${typeIcon[methodType] || 'ğŸ”§'} ${methodName}`;
}
        
        // åŠ è½½å†å²è®°å½•
        function loadHistory() {
            const saved = localStorage.getItem('replaceHistory');
            if (saved) {
                replaceHistory = JSON.parse(saved);
            }
        }
        
        // æ˜¾ç¤ºå†å²è®°å½•
        function showHistory() {
    closeSidebar();
    
    const list = document.getElementById('historyList');
    if (replaceHistory.length === 0) {
        list.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">æš‚æ— æ›¿æ¢å†å²</p>';
    } else {
        list.innerHTML = replaceHistory.map((item, index) => `
            <div class="history-item" onclick="showHistoryDetails(${index})">
                <div class="history-header">
                    <div class="history-method">${item.preview}</div>
                    <div class="history-actions">
                        <button class="history-btn" onclick="event.stopPropagation(); restoreHistory(${index})" title="æ¢å¤">â†¶</button>
                        <button class="history-btn" onclick="event.stopPropagation(); deleteHistory(${index})" title="åˆ é™¤">ğŸ—‘</button>
                    </div>
                </div>
                <div class="history-meta">
                    <span class="history-time">${new Date(item.time).toLocaleString()}</span>
                    <span class="history-count">æ›¿æ¢äº† ${item.replacedCount || 1} å¤„</span>
                </div>
            </div>
        `).join('');
    }
    
    showDialog('historyDialog');
}

// æ˜¾ç¤ºå†å²è¯¦æƒ…
function showHistoryDetails(index) {
    const item = replaceHistory[index];
    const detailsHtml = `
        <div class="history-details">
            <h4>æ–¹æ³•ä¿¡æ¯</h4>
            <p><strong>åç§°:</strong> ${item.name}</p>
            <p><strong>ç±»å‹:</strong> ${getMethodTypeText(item.type)}</p>
            <p><strong>æ›¿æ¢æ—¶é—´:</strong> ${new Date(item.time).toLocaleString()}</p>
            <p><strong>æ›¿æ¢æ•°é‡:</strong> ${item.replacedCount || 1} å¤„</p>
            
            <h4>æ“ä½œ</h4>
            <button class="btn btn-primary" onclick="restoreHistory(${index}); closeHistoryDetails();">æ¢å¤åˆ°æ›¿æ¢å‰</button>
            <button class="btn btn-text" onclick="closeHistoryDetails();">å…³é—­</button>
        </div>
    `;
    
    // åˆ›å»ºè¯¦æƒ…å¯¹è¯æ¡†
    const detailsDialog = document.createElement('div');
    detailsDialog.className = 'dialog active';
    detailsDialog.id = 'historyDetailsDialog';
    detailsDialog.innerHTML = `
        <div class="dialog-header">
            <h3 class="dialog-title">å†å²è¯¦æƒ…</h3>
            <button class="icon-btn icon-close" onclick="closeHistoryDetails()"></button>
        </div>
        <div class="dialog-content">${detailsHtml}</div>
    `;
    
    document.body.appendChild(detailsDialog);
}

// å…³é—­å†å²è¯¦æƒ…
function closeHistoryDetails() {
    const dialog = document.getElementById('historyDetailsDialog');
    if (dialog) {
        dialog.remove();
    }
}

// åˆ é™¤å†å²è®°å½•
function deleteHistory(index) {
    if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡å†å²è®°å½•å—ï¼Ÿ')) {
        replaceHistory.splice(index, 1);
        localStorage.setItem('replaceHistory', JSON.stringify(replaceHistory));
        showHistory(); // åˆ·æ–°æ˜¾ç¤º
        showToast('å†å²è®°å½•å·²åˆ é™¤');
    }
}
        
        // æ¢å¤å†å²
        function restoreHistory(index) {
            const item = replaceHistory[index];
            if (confirm(`ç¡®å®šè¦æ¢å¤åˆ°æ›¿æ¢å‰çš„ä»£ç å—ï¼Ÿ`)) {
                editor.setValue(item.oldCode);
                closeDialog('historyDialog');
                showToast('å·²æ¢å¤ä»£ç ', 'success');
            }
        }
        
        // æ˜¾ç¤ºè®¾ç½®
        function showSettings() {
            closeSidebar();
            showDialog('settingsDialog');
        }
        
        // åˆ‡æ¢è®¾ç½®
        function toggleWordWrap() {
            const enabled = document.getElementById('wordWrapToggle').checked;
            editor.setOption('lineWrapping', enabled);
            saveSettings();
        }
        
        function toggleLineNumbers() {
            const enabled = document.getElementById('lineNumbersToggle').checked;
            editor.setOption('lineNumbers', enabled);
            saveSettings();
        }
        
        function toggleAutocomplete() {
            // è‡ªåŠ¨å®Œæˆè®¾ç½®
            saveSettings();
        }
        
        function changeTheme() {
            const theme = document.getElementById('themeSelect').value;
            editor.setOption('theme', theme);
            saveSettings();
        }
        
        // ä¿å­˜è®¾ç½®
        function saveSettings() {
            const settings = {
                wordWrap: document.getElementById('wordWrapToggle').checked,
                lineNumbers: document.getElementById('lineNumbersToggle').checked,
                autocomplete: document.getElementById('autocompleteToggle').checked,
                theme: document.getElementById('themeSelect').value
            };
            localStorage.setItem('editorSettings', JSON.stringify(settings));
        }
        
        // åŠ è½½è®¾ç½®
        function loadSettings() {
            const saved = localStorage.getItem('editorSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                document.getElementById('wordWrapToggle').checked = settings.wordWrap !== false;
                document.getElementById('lineNumbersToggle').checked = settings.lineNumbers !== false;
                document.getElementById('autocompleteToggle').checked = settings.autocomplete !== false;
                document.getElementById('themeSelect').value = settings.theme || 'material-darker';
                
                // åº”ç”¨è®¾ç½®
                editor.setOption('lineWrapping', settings.wordWrap !== false);
                editor.setOption('lineNumbers', settings.lineNumbers !== false);
                editor.setOption('theme', settings.theme || 'material-darker');
            }
        }
        
        // å¯¹è¯æ¡†æ§åˆ¶
        function showDialog(id) {
            const dialog = document.getElementById(id);
            const overlay = document.getElementById('overlay');
            dialog.classList.add('active');
            overlay.classList.add('active');
        }
        
        function closeDialog(id) {
            const dialog = document.getElementById(id);
            const overlay = document.getElementById('overlay');
            dialog.classList.remove('active');
            overlay.classList.remove('active');
            
            // æ¸…ç†è¡¨å•
            if (id === 'methodReplaceDialog') {
                document.getElementById('methodInput').value = '';
                document.getElementById('detectedMethod').style.display = 'none';
                document.getElementById('replaceBtn').style.display = 'none';
                detectedMethod = null;
            }
        }
        
        // Toast æç¤º
        function showToast(message, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast show ${type}`;
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
  

// æ˜¾ç¤ºæœç´¢æ›¿æ¢é¢æ¿
function showSearchReplace() {
    closeSidebar();
    const panel = document.getElementById('searchReplacePanel');
    const overlay = document.getElementById('overlay');
    
    panel.classList.add('active');
    overlay.classList.add('active');
    
    // èšç„¦æœç´¢è¾“å…¥æ¡†
    setTimeout(() => {
        document.getElementById('searchInput').focus();
    }, 100);
}

// å…³é—­æœç´¢æ›¿æ¢é¢æ¿
function closeSearchReplace() {
    const panel = document.getElementById('searchReplacePanel');
    const overlay = document.getElementById('overlay');
    
    panel.classList.remove('active');
    overlay.classList.remove('active');
    
    // æ¸…é™¤é«˜äº®
    clearSearchHighlight();
}

// æ‰§è¡Œæœç´¢
function performSearch() {
    const query = document.getElementById('searchInput').value;
    const caseSensitive = document.getElementById('caseSensitive').checked;
    const wholeWord = document.getElementById('wholeWord').checked;
    const useRegex = document.getElementById('useRegex').checked;
    
    if (!query) {
        showSearchResults('è¯·è¾“å…¥æœç´¢å†…å®¹');
        return;
    }
    
    searchState.query = query;
    searchState.caseSensitive = caseSensitive;
    searchState.wholeWord = wholeWord;
    searchState.useRegex = useRegex;
    searchState.matches = [];
    searchState.currentMatch = -1;
    
    try {
        let searchRegex;
        
        if (useRegex) {
            searchRegex = new RegExp(query, caseSensitive ? 'g' : 'gi');
        } else {
            let escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            if (wholeWord) {
                escapedQuery = '\\b' + escapedQuery + '\\b';
            }
            searchRegex = new RegExp(escapedQuery, caseSensitive ? 'g' : 'gi');
        }
        
        const content = editor.getValue();
        const lines = content.split('\n');
        let match;
        
        lines.forEach((line, lineIndex) => {
            searchRegex.lastIndex = 0;
            while ((match = searchRegex.exec(line)) !== null) {
                searchState.matches.push({
                    line: lineIndex,
                    ch: match.index,
                    text: match[0]
                });
            }
        });
        
        if (searchState.matches.length > 0) {
            showSearchResults(`æ‰¾åˆ° ${searchState.matches.length} ä¸ªåŒ¹é…é¡¹`);
            highlightAllMatches();
        } else {
            showSearchResults('æœªæ‰¾åˆ°åŒ¹é…é¡¹');
        }
        
    } catch (error) {
        showSearchResults('æœç´¢è¡¨è¾¾å¼é”™è¯¯: ' + error.message);
    }
}

// æŸ¥æ‰¾ä¸‹ä¸€ä¸ª
function findNext() {
    if (searchState.matches.length === 0) {
        performSearch();
        return;
    }
    
    searchState.currentMatch = (searchState.currentMatch + 1) % searchState.matches.length;
    const match = searchState.matches[searchState.currentMatch];
    
    editor.setSelection(
        { line: match.line, ch: match.ch },
        { line: match.line, ch: match.ch + match.text.length }
    );
    editor.scrollIntoView({ line: match.line, ch: match.ch });
    
    showSearchResults(`ç¬¬ ${searchState.currentMatch + 1} ä¸ªï¼Œå…± ${searchState.matches.length} ä¸ªåŒ¹é…é¡¹`);
}

// æŸ¥æ‰¾ä¸Šä¸€ä¸ª
function findPrevious() {
    if (searchState.matches.length === 0) {
        performSearch();
        return;
    }
    
    searchState.currentMatch = searchState.currentMatch <= 0 ? 
        searchState.matches.length - 1 : searchState.currentMatch - 1;
    
    const match = searchState.matches[searchState.currentMatch];
    
    editor.setSelection(
        { line: match.line, ch: match.ch },
        { line: match.line, ch: match.ch + match.text.length }
    );
    editor.scrollIntoView({ line: match.line, ch: match.ch });
    
    showSearchResults(`ç¬¬ ${searchState.currentMatch + 1} ä¸ªï¼Œå…± ${searchState.matches.length} ä¸ªåŒ¹é…é¡¹`);
}

// æ›¿æ¢ä¸‹ä¸€ä¸ª
function replaceNext() {
    const replaceText = document.getElementById('replaceInput').value;
    
    if (searchState.matches.length === 0) {
        performSearch();
        return;
    }
    
    if (searchState.currentMatch === -1) {
        findNext();
        return;
    }
    
    const match = searchState.matches[searchState.currentMatch];
    
    editor.replaceRange(
        replaceText,
        { line: match.line, ch: match.ch },
        { line: match.line, ch: match.ch + match.text.length }
    );
    
    // é‡æ–°æœç´¢ä»¥æ›´æ–°åŒ¹é…é¡¹
    performSearch();
    
    showToast('å·²æ›¿æ¢ 1 ä¸ªåŒ¹é…é¡¹', 'success');
}

// å…¨éƒ¨æ›¿æ¢
function replaceAll() {
    const replaceText = document.getElementById('replaceInput').value;
    
    if (searchState.matches.length === 0) {
        performSearch();
        return;
    }
    
    const totalMatches = searchState.matches.length;
    
    // ä»åå¾€å‰æ›¿æ¢ï¼Œé¿å…ä½ç½®åç§»
    for (let i = searchState.matches.length - 1; i >= 0; i--) {
        const match = searchState.matches[i];
        editor.replaceRange(
            replaceText,
            { line: match.line, ch: match.ch },
            { line: match.line, ch: match.ch + match.text.length }
        );
    }
    
    // æ¸…ç©ºæœç´¢çŠ¶æ€
    searchState.matches = [];
    searchState.currentMatch = -1;
    clearSearchHighlight();
    
    showSearchResults(`å·²æ›¿æ¢ ${totalMatches} ä¸ªåŒ¹é…é¡¹`);
    showToast(`å·²æ›¿æ¢ ${totalMatches} ä¸ªåŒ¹é…é¡¹`, 'success');
}

// é«˜äº®æ‰€æœ‰åŒ¹é…é¡¹
function highlightAllMatches() {
    clearSearchHighlight();
    
    searchState.matches.forEach(match => {
        editor.markText(
            { line: match.line, ch: match.ch },
            { line: match.line, ch: match.ch + match.text.length },
            {
                className: 'search-highlight',
                css: 'background-color: rgba(255, 255, 0, 0.3); border-radius: 2px;'
            }
        );
    });
}

// æ¸…é™¤æœç´¢é«˜äº®
function clearSearchHighlight() {
    const marks = editor.getAllMarks();
    marks.forEach(mark => {
        if (mark.className === 'search-highlight') {
            mark.clear();
        }
    });
}

// æ˜¾ç¤ºæœç´¢ç»“æœ
function showSearchResults(message) {
    const results = document.getElementById('searchResults');
    results.textContent = message;
    results.style.display = 'block';
}

// æ˜¾ç¤ºä½¿ç”¨è¯´æ˜
function showHelp() {
    showDialog('helpDialog');
}

// å¯¼å…¥æ–‡ä»¶åŠŸèƒ½
function importFile() {
    closeSidebar();
    
    // åˆ›å»ºå¯¼å…¥é€‰é¡¹å¯¹è¯æ¡†
    showImportDialog();
}

// æ˜¾ç¤ºå¯¼å…¥å¯¹è¯æ¡†
function showImportDialog() {
    const dialog = document.createElement('div');
    dialog.className = 'import-dialog active';
    dialog.id = 'importDialog';
    
    // ä¼˜åŒ–ï¼šç§»é™¤äº†æœªå®ç°çš„â€œè¿½åŠ â€å’Œâ€œæ’å…¥â€é€‰é¡¹ï¼Œé¿å…ç”¨æˆ·æ··æ·†
    dialog.innerHTML = `
        <div class="dialog-header">
            <h3 class="dialog-title">å¯¼å…¥æ–‡æ¡£</h3>
            <button class="icon-btn icon-close" onclick="closeImportDialog()"></button>
        </div>
        <div class="dialog-content">
            <p>é€‰æ‹©çš„æ–‡ä»¶å°†æ›¿æ¢å½“å‰é¡¹ç›®çš„æ‰€æœ‰å†…å®¹ã€‚</p>
            <div class="file-info" style="margin-top: 20px;">
                <h4>æ”¯æŒçš„æ–‡ä»¶ç±»å‹</h4>
                <p><strong>ç½‘é¡µæ–‡ä»¶ï¼š</strong> .html, .htm</p>
                <p><strong>æ ·å¼æ–‡ä»¶ï¼š</strong> .css</p>
                <p><strong>è„šæœ¬æ–‡ä»¶ï¼š</strong> .js, .mjs, .jsx</p>
                <p><strong>æ•°æ®æ–‡ä»¶ï¼š</strong> .json, .xml</p>
                <p><strong>æ–‡æ¡£æ–‡ä»¶ï¼š</strong> .txt, .md</p>
            </div>
        </div>
        <div class="dialog-actions">
            <button class="btn btn-text" onclick="closeImportDialog()">å–æ¶ˆ</button>
            <button class="btn btn-primary" onclick="triggerFileSelect()">é€‰æ‹©æ–‡ä»¶</button>
        </div>
    `;
    
    document.body.appendChild(dialog);
    
    // é®ç½©å±‚
    const overlay = document.getElementById('overlay');
    overlay.classList.add('active');
}

// å…³é—­å¯¼å…¥å¯¹è¯æ¡†
function closeImportDialog() {
    const dialog = document.getElementById('importDialog');
    const overlay = document.getElementById('overlay');
    
    if (dialog) {
        dialog.remove();
    }
    overlay.classList.remove('active');
}

// è§¦å‘æ–‡ä»¶é€‰æ‹©
function triggerFileSelect() {
    const fileInput = document.getElementById('fileInput');
    
    // é‡ç½®æ–‡ä»¶è¾“å…¥ï¼Œç¡®ä¿å¯ä»¥é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
    fileInput.value = '';
    
    // åŠ¨æ€è®¾ç½®acceptå±æ€§ä»¥ç¡®ä¿å…¼å®¹æ€§
    fileInput.setAttribute('accept', '.html,.htm,.js,.mjs,.jsx,.css,.txt,.json,.xml,.md,text/javascript,application/javascript,text/html,text/css,text/plain');
    
    fileInput.click();
}

// éªŒè¯JavaScriptæ–‡ä»¶
function isJavaScriptFile(file) {
    const jsExtensions = ['.js', '.mjs', '.jsx'];
    const jsMimeTypes = ['text/javascript', 'application/javascript', 'application/x-javascript'];
    
    const extension = '.' + file.name.split('.').pop().toLowerCase();
    return jsExtensions.includes(extension) || jsMimeTypes.includes(file.type);
}

// å¤„ç†æ–‡ä»¶å¯¼å…¥
function handleFileImport(event) {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    // è·å–å¯¼å…¥æ¨¡å¼
    const importMode = document.querySelector('input[name="importMode"]:checked')?.value || 'replace';

    // å¦‚æœæ˜¯æ›¿æ¢æ¨¡å¼ï¼Œæ¸…ç©ºç°æœ‰é¡¹ç›®
    if (importMode === 'replace') {
        projectFiles.clear();
    }

    let importedCount = 0;
    const importPromises = [];
    const importedFileNames = [];

    // å¤„ç†æ¯ä¸ªæ–‡ä»¶
    Array.from(files).forEach(file => {
        const promise = new Promise((resolve) => {
            // æ£€æŸ¥æ–‡ä»¶ç±»å‹
            const allowedTypes = ['.html', '.htm', '.js', '.css', '.txt', '.json', '.xml', '.md'];
            const allowedMimeTypes = ['text/javascript', 'application/javascript', 'text/html', 'text/css', 'text/plain', 'application/json'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();

            // æ£€æŸ¥æ–‡ä»¶æ‰©å±•åæˆ–MIMEç±»å‹
            const isValidExtension = allowedTypes.includes(fileExtension);
            const isValidMimeType = allowedMimeTypes.includes(file.type);

            if (!isValidExtension && !isValidMimeType) {
                showToast(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.name}`, 'error');
                resolve();
                return;
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ä¸º10MBï¼‰
            if (file.size > 10 * 1024 * 1024) {
                showToast(`æ–‡ä»¶å¤§å°è¶…è¿‡10MBé™åˆ¶: ${file.name}`, 'error');
                resolve();
                return;
            }

            // è¯»å–æ–‡ä»¶å†…å®¹
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;

                    // ä¿®å¤ç‚¹ï¼šå¤„ç†index.htmlæ–‡ä»¶
                    // å¦‚æœæ˜¯index.htmlæ–‡ä»¶ï¼Œç¡®ä¿å®ƒæˆä¸ºä¸»æ–‡ä»¶
                    if (file.name.toLowerCase() === 'index.html') {
                        projectFiles.set('index.html', {
                            content: content,
                            type: 'html',
                            lastModified: Date.now()
                        });
                        importedFileNames.push('index.html');
                    } 
                    // éindex.htmlæ–‡ä»¶æ­£å¸¸å¤„ç†
                    else {
                        projectFiles.set(file.name, {
                            content: content,
                            type: getFileType(file.name),
                            lastModified: Date.now()
                        });
                        importedFileNames.push(file.name);
                    }
                    
                    importedCount++;
                    resolve();
                } catch (error) {
                    console.error(`å¯¼å…¥å¤±è´¥ ${file.name}:`, error);
                    showToast(`æ–‡ä»¶å¯¼å…¥å¤±è´¥: ${file.name}`, 'error');
                    resolve();
                }
            };

            reader.onerror = function() {
                showToast(`æ–‡ä»¶è¯»å–å¤±è´¥: ${file.name}`, 'error');
                resolve();
            };

            reader.readAsText(file, 'UTF-8');
        });

        importPromises.push(promise);
    });

    // ç­‰å¾…æ‰€æœ‰æ–‡ä»¶å¯¼å…¥å®Œæˆ
    Promise.all(importPromises).then(() => {
        closeImportDialog();

        if (importedCount > 0) {
            showToast(`æˆåŠŸå¯¼å…¥ ${importedCount} ä¸ªæ–‡ä»¶`, 'success');

            // å†³å®šåˆ‡æ¢åˆ°å“ªä¸ªæ–‡ä»¶
            let fileToSwitchTo = null;
            
            // ä¿®å¤ç‚¹ï¼šä¼˜å…ˆé€‰æ‹©index.htmlä½œä¸ºä¸»æ–‡ä»¶
            if (projectFiles.has('index.html')) {
                fileToSwitchTo = 'index.html';
            } else if (importedFileNames.length === 1) {
                // å¦‚æœåªæ›¿æ¢å¹¶å¯¼å…¥äº†ä¸€ä¸ªæ–‡ä»¶ï¼Œå°±åˆ‡æ¢åˆ°è¿™ä¸ªæ–‡ä»¶
                fileToSwitchTo = importedFileNames[0];
            } else if (importedFileNames.length > 1) {
                // å¦‚æœå¯¼å…¥äº†å¤šä¸ªæ–‡ä»¶ï¼Œä¼˜å…ˆæ‰¾ç¬¬ä¸€ä¸ªhtmlæ–‡ä»¶ï¼Œæœ€åæ‰¾ç¬¬ä¸€ä¸ªæ–‡ä»¶
                fileToSwitchTo = importedFileNames.find(name => getFileType(name) === 'html') || 
                                 importedFileNames[0];
            }

            if (fileToSwitchTo) {
                switchToFile(fileToSwitchTo);
            } else {
                // å¯¹äºè¿½åŠ æˆ–æ’å…¥ï¼Œåªéœ€åˆ·æ–°UI
                updateFileList();
            }

            switchTab('editor'); // ç¡®ä¿ç¼–è¾‘å™¨æ˜¯æ¿€æ´»çŠ¶æ€
        }
    });

    // æ¸…ç©ºæ–‡ä»¶è¾“å…¥ï¼Œä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥å¯¼å…¥åŒåæ–‡ä»¶
    event.target.value = '';
}

// åº”ç”¨å¯¼å…¥çš„å†…å®¹
function applyImportedContent(content, mode, fileName) {
    const importComment = '\n\n<!-- å¯¼å…¥çš„æ–‡ä»¶: ' + fileName + ' -->\n';

    switch (mode) {
        case 'append':
            const currentContent = editor.getValue();
            editor.setValue(currentContent + importComment + content);
            break;
            
        case 'insert':
            const cursor = editor.getCursor();
            editor.replaceRange(importComment + content + '\n', cursor);
            break;
    }
    
    // ç«‹å³ä¿å­˜åˆ°é¡¹ç›®å’Œæœ¬åœ°å­˜å‚¨
    saveCode();
}

// ç®€å•çš„Markdownè½¬HTMLå‡½æ•°
function markdownToHtml(markdown) {
    return markdown
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>')
        .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
        .replace(/\*(.*)\*/gim, '<em>$1</em>')
        .replace(/`(.*)`/gim, '<code>$1</code>')
        .replace(/\n\n/gim, '</p><p>')
        .replace(/\n/gim, '<br>')
        .replace(/^(.*)$/gim, '<p>$1</p>');
}

function getFileType(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const typeMap = {
        'html': 'html',
        'htm': 'html',
        'css': 'css',
        'js': 'javascript',
        'mjs': 'javascript',
        'jsx': 'javascript',
        'json': 'json',
        'xml': 'xml',
        'md': 'markdown',
        'txt': 'text'
    };
    return typeMap[ext] || 'text';
}

function getCodeMirrorMode(fileType) {
    const modeMap = {
        'html': 'htmlmixed',
        'css': 'css',
        'javascript': 'javascript',
        'json': 'application/json',
        'xml': 'xml',
        'markdown': 'markdown',
        'text': 'text/plain'
    };
    return modeMap[fileType] || 'text/plain';
}

//  åˆ›å»ºæ–‡ä»¶åˆ—è¡¨UI
function createFileListUI() {
    const storageInfo = getStorageUsage();
    const storageInfoHTML = storageInfo ? `
        <div class="storage-info" style="padding: 12px; background: var(--background-color); margin: 8px 0; border-radius: 4px; font-size: 12px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                <span>å­˜å‚¨ä½¿ç”¨æƒ…å†µ</span>
                <span>${storageInfo.percentage}%</span>
            </div>
            <div style="background: var(--border-color); height: 4px; border-radius: 2px; overflow: hidden;">
                <div style="background: var(--primary-color); height: 100%; width: ${storageInfo.percentage}%; transition: width 0.3s;"></div>
            </div>
            <div style="margin-top: 4px; color: #666;">
                é¡¹ç›®: ${formatFileSize(storageInfo.project)} | 
                å†å²: ${formatFileSize(storageInfo.history)}
            </div>
        </div>
    ` : '';
    
    const fileListHTML = `
    <div class="file-manager-panel" id="fileManagerPanel">
        <div class="file-manager-header">
            <h3>é¡¹ç›®æ–‡ä»¶ (${projectFiles.size})</h3>
            <div class="file-manager-actions">
                <button class="icon-btn" onclick="createNewFile()" title="æ–°å»ºæ–‡ä»¶">+</button>
                <button class="icon-btn" onclick="cleanupStorage()" title="æ¸…ç†å­˜å‚¨">ğŸ§¹</button>
                <button class="icon-btn icon-close" onclick="closeFileManager()"></button>
            </div>
        </div>
        ${storageInfoHTML}
        <div class="file-tabs" id="fileTabs">
            <!-- æ–‡ä»¶æ ‡ç­¾å°†åœ¨è¿™é‡ŒåŠ¨æ€æ·»åŠ  -->
        </div>
        <div class="file-list" id="fileList">
            <div class="file-category">
                <h4>HTMLæ–‡ä»¶</h4>
                <div id="htmlFiles" class="file-items"></div>
            </div>
            <div class="file-category">
                <h4>CSSæ–‡ä»¶</h4>
                <div id="cssFiles" class="file-items"></div>
            </div>
            <div class="file-category">
                <h4>JavaScriptæ–‡ä»¶</h4>
                <div id="jsFiles" class="file-items"></div>
            </div>
            <div class="file-category">
                <h4>å…¶ä»–æ–‡ä»¶</h4>
                <div id="otherFiles" class="file-items"></div>
            </div>
        </div>
    </div>
    `;
    
    // å¦‚æœé¢æ¿ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
    if (!document.getElementById('fileManagerPanel')) {
        const panel = document.createElement('div');
        panel.innerHTML = fileListHTML;
        document.body.appendChild(panel.firstElementChild);
    }
}

// æ›´æ–°æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤º
function updateFileList() {
    createFileListUI();
    
    // æ¸…ç©ºç°æœ‰åˆ—è¡¨
    projectStructure = {
        html: [],
        css: [],
        js: [],
        other: []
    };
    
    // åˆ†ç±»æ–‡ä»¶
    projectFiles.forEach((fileData, filename) => {
        const type = getFileType(filename);
        const fileInfo = {
            name: filename,
            type: type,
            size: new Blob([fileData.content]).size
        };
        
        if (type === 'html') {
            projectStructure.html.push(fileInfo);
        } else if (type === 'css') {
            projectStructure.css.push(fileInfo);
        } else if (type === 'javascript') {
            projectStructure.js.push(fileInfo);
        } else {
            projectStructure.other.push(fileInfo);
        }
    });
    
    // æ›´æ–°UI
    updateFileListUI('htmlFiles', projectStructure.html);
    updateFileListUI('cssFiles', projectStructure.css);
    updateFileListUI('jsFiles', projectStructure.js);
    updateFileListUI('otherFiles', projectStructure.other);
    
    // æ›´æ–°æ ‡ç­¾æ 
    updateFileTabs();
}

function updateFileListUI(containerId, files) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = files.map(file => `
        <div class="file-item ${file.name === currentFileName ? 'active' : ''}" onclick="switchToFile('${file.name}')">
            <span class="file-name">${file.name}</span>
            <span class="file-size">${formatFileSize(file.size)}</span>
            <button class="file-delete" onclick="event.stopPropagation(); deleteFile('${file.name}')">Ã—</button>
        </div>
    `).join('');
}

// æ›´æ–°æ–‡ä»¶æ ‡ç­¾
function updateFileTabs() {
    const tabsContainer = document.getElementById('fileTabs');
    if (!tabsContainer) return;
    
    const tabs = Array.from(projectFiles.keys()).map(filename => `
        <div class="file-tab ${filename === currentFileName ? 'active' : ''}" onclick="switchToFile('${filename}')">
            <span>${filename}</span>
            <button class="tab-close" onclick="event.stopPropagation(); closeFileTab('${filename}')">Ã—</button>
        </div>
    `).join('');
    
    tabsContainer.innerHTML = tabs;
}

function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// åˆ‡æ¢æ–‡ä»¶
function switchToFile(filename) {
    // ä¿å­˜å½“å‰æ–‡ä»¶
    if (currentFileName && editor && projectFiles.has(currentFileName)) {
        projectFiles.set(currentFileName, {
            content: editor.getValue(),
            type: getFileType(currentFileName),
            lastModified: Date.now()
        });
    }
    
    // åˆ‡æ¢åˆ°æ–°æ–‡ä»¶
    currentFileName = filename;
    const fileData = projectFiles.get(filename);
    
    if (fileData) {
        editor.setValue(fileData.content);
        
        // æ ¹æ®æ–‡ä»¶ç±»å‹è®¾ç½®ç¼–è¾‘å™¨æ¨¡å¼
        const mode = getCodeMirrorMode(fileData.type);
        editor.setOption('mode', mode);
        
        // æ›´æ–°æ ‡é¢˜
        document.querySelector('.app-title').textContent = `HTMLç¼–è¾‘å™¨ - ${filename}`;
    }
    
    // æ›´æ–°æ–‡ä»¶åˆ—è¡¨UI
    updateFileList();
}

// åˆ›å»ºæ–°æ–‡ä»¶
function createNewFile() {
    const filename = prompt('è¯·è¾“å…¥æ–‡ä»¶åï¼ˆåŒ…å«æ‰©å±•åï¼‰ï¼š', 'new-file.html');
    if (!filename) return;
    
    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
    if (projectFiles.has(filename)) {
        showToast('æ–‡ä»¶å·²å­˜åœ¨', 'error');
        return;
    }
    
    // æ ¹æ®æ–‡ä»¶ç±»å‹åˆ›å»ºé»˜è®¤å†…å®¹
    const type = getFileType(filename);
    let defaultContent = '';
    
    switch(type) {
        case 'html':
            defaultContent = '<!DOCTYPE html>\n<html>\n<head>\n    <title>New Page</title>\n</head>\n<body>\n    \n</body>\n</html>';
            break;
        case 'css':
            defaultContent = '/* CSS styles */\n';
            break;
        case 'javascript':
            defaultContent = '// JavaScript code\n';
            break;
    }
    
    // æ·»åŠ æ–‡ä»¶
    projectFiles.set(filename, {
        content: defaultContent,
        type: type,
        lastModified: Date.now()
    });
    
    // åˆ‡æ¢åˆ°æ–°æ–‡ä»¶
    switchToFile(filename);
    
    showToast(`æ–‡ä»¶ ${filename} å·²åˆ›å»º`, 'success');
}

// åˆ é™¤æ–‡ä»¶
function deleteFile(filename) {
    if (!confirm(`ç¡®å®šè¦åˆ é™¤æ–‡ä»¶ ${filename} å—ï¼Ÿ`)) return;
    
    projectFiles.delete(filename);
    
    // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ–‡ä»¶ï¼Œåˆ‡æ¢åˆ°å¦ä¸€ä¸ªæ–‡ä»¶
    if (filename === currentFileName) {
        const files = Array.from(projectFiles.keys());
        if (files.length > 0) {
            switchToFile(files[0]);
        } else {
            // å¦‚æœæ²¡æœ‰æ–‡ä»¶äº†ï¼Œåˆ›å»ºä¸€ä¸ªé»˜è®¤çš„index.html
            projectFiles.set('index.html', {
                content: DEFAULT_TEMPLATE,
                type: 'html',
                lastModified: Date.now()
            });
            switchToFile('index.html');
        }
    }
    
    updateFileList();
    showToast(`æ–‡ä»¶ ${filename} å·²åˆ é™¤`, 'success');
}

// æ˜¾ç¤ºæ–‡ä»¶ç®¡ç†å™¨
function showFileManager() {
    closeSidebar();
    createFileListUI();
    updateFileList();
    
    const panel = document.getElementById('fileManagerPanel');
    const overlay = document.getElementById('overlay');
    
    panel.classList.add('active');
    overlay.classList.add('active');
}

// å…³é—­æ–‡ä»¶ç®¡ç†å™¨
function closeFileManager() {
    const panel = document.getElementById('fileManagerPanel');
    const overlay = document.getElementById('overlay');
    
    if (panel) {
        panel.classList.remove('active');
    }
    overlay.classList.remove('active');
}

// å¯¼å‡ºæ•´ä¸ªé¡¹ç›®
function exportProject() {
    closeSidebar();
    
    // ä¿å­˜å½“å‰æ–‡ä»¶
    if (currentFileName && editor) {
        projectFiles.set(currentFileName, {
            content: editor.getValue(),
            type: getFileType(currentFileName),
            lastModified: Date.now()
        });
    }
    
    // å¦‚æœåªæœ‰ä¸€ä¸ªæ–‡ä»¶ï¼Œä½¿ç”¨åŸæ¥çš„å¯¼å‡ºåŠŸèƒ½
    if (projectFiles.size <= 1) {
        exportCode();
        return;
    }
    
    // åˆ›å»ºZIPæ–‡ä»¶ï¼ˆéœ€è¦å¼•å…¥JSZipåº“ï¼‰
    if (typeof JSZip === 'undefined') {
        // å¦‚æœæ²¡æœ‰JSZipï¼Œæä¾›æ›¿ä»£æ–¹æ¡ˆ
        showExportOptions();
        return;
    }
    
    try {
        const zip = new JSZip();
        
        // æ·»åŠ æ‰€æœ‰æ–‡ä»¶åˆ°ZIP
        projectFiles.forEach((fileData, filename) => {
            zip.file(filename, fileData.content);
        });
        
        // ç”ŸæˆZIPæ–‡ä»¶
        zip.generateAsync({ type: 'blob' }).then(content => {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `project-export-${timestamp}.zip`;
            
            // ä¸‹è½½ZIPæ–‡ä»¶
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            showToast('é¡¹ç›®å¯¼å‡ºæˆåŠŸï¼', 'success');
        });
        
    } catch (error) {
        console.error('å¯¼å‡ºå¤±è´¥:', error);
        showToast('å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
    }
}

// æ˜¾ç¤ºå¯¼å‡ºé€‰é¡¹
function showExportOptions() {
    const dialog = document.createElement('div');
    dialog.className = 'dialog active';
    dialog.id = 'exportOptionsDialog';
    
    dialog.innerHTML = `
        <div class="dialog-header">
            <h3 class="dialog-title">å¯¼å‡ºé¡¹ç›®</h3>
            <button class="icon-btn icon-close" onclick="closeExportOptionsDialog()"></button>
        </div>
        <div class="dialog-content">
            <p>é¡¹ç›®åŒ…å« ${projectFiles.size} ä¸ªæ–‡ä»¶ã€‚è¯·é€‰æ‹©å¯¼å‡ºæ–¹å¼ï¼š</p>
            <div class="export-options">
                <button class="export-option-btn" onclick="exportAsCombinedHTML()">
                    <i>ğŸ“„</i>
                    <span>å¯¼å‡ºä¸ºå•ä¸ªHTMLæ–‡ä»¶</span>
                    <small>å°†æ‰€æœ‰CSSå’ŒJSæ–‡ä»¶åˆå¹¶åˆ°HTMLä¸­</small>
                </button>
                <button class="export-option-btn" onclick="exportFilesSeparately()">
                    <i>ğŸ“</i>
                    <span>åˆ†åˆ«ä¸‹è½½æ¯ä¸ªæ–‡ä»¶</span>
                    <small>æ¯ä¸ªæ–‡ä»¶å•ç‹¬ä¸‹è½½</small>
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(dialog);
    
    const overlay = document.getElementById('overlay');
    overlay.classList.add('active');
}

function closeExportOptionsDialog() {
    const dialog = document.getElementById('exportOptionsDialog');
    if (dialog) {
        dialog.remove();
    }
    document.getElementById('overlay').classList.remove('active');
}

// å¯¼å‡ºä¸ºåˆå¹¶çš„HTML
function exportAsCombinedHTML() {
    closeExportOptionsDialog();
    
    try {
        const fullHTML = buildProjectHTML();
        
        const blob = new Blob([fullHTML], { 
            type: 'text/html;charset=utf-8' 
        });
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `combined-export-${timestamp}.html`;
        
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        showToast('é¡¹ç›®å·²å¯¼å‡ºä¸ºå•ä¸ªHTMLæ–‡ä»¶ï¼', 'success');
        
    } catch (error) {
        console.error('å¯¼å‡ºå¤±è´¥:', error);
        showToast('å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
    }
}

// åˆ†åˆ«å¯¼å‡ºæ–‡ä»¶
function exportFilesSeparately() {
    closeExportOptionsDialog();
    
    let exportedCount = 0;
    
    projectFiles.forEach((fileData, filename) => {
        try {
            const blob = new Blob([fileData.content], { 
                type: 'text/plain;charset=utf-8' 
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            
            // å»¶è¿Ÿæ¯ä¸ªæ–‡ä»¶çš„ä¸‹è½½ï¼Œé¿å…æµè§ˆå™¨é˜»æ­¢
            setTimeout(() => {
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                exportedCount++;
                
                if (exportedCount === projectFiles.size) {
                    showToast(`å·²å¯¼å‡º ${exportedCount} ä¸ªæ–‡ä»¶ï¼`, 'success');
                }
            }, exportedCount * 200);
            
        } catch (error) {
            console.error(`å¯¼å‡ºæ–‡ä»¶ ${filename} å¤±è´¥:`, error);
        }
    });
}

function loadProject() {
    const savedProject = localStorage.getItem('htmlEditorProject');
    
    if (savedProject) {
        try {
            const projectData = JSON.parse(savedProject);
            
            // æ£€æŸ¥ç‰ˆæœ¬å…¼å®¹æ€§
            if (projectData.version && projectData.version !== '2.0') {
                console.warn('é¡¹ç›®ç‰ˆæœ¬ä¸åŒ¹é…ï¼Œå°è¯•å…¼å®¹åŠ è½½');
            }
            
            // æ¢å¤æ–‡ä»¶
            projectFiles.clear();
            if (projectData.files && Array.isArray(projectData.files)) {
                projectData.files.forEach(([filename, fileData]) => {
                    // éªŒè¯æ–‡ä»¶æ•°æ®å®Œæ•´æ€§
                    if (filename && fileData && fileData.content !== undefined) {
                        projectFiles.set(filename, {
                            content: fileData.content,
                            type: fileData.type || getFileType(filename),
                            lastModified: fileData.lastModified || Date.now()
                        });
                    }
                });
            }
            
            // æ¢å¤å½“å‰æ–‡ä»¶
            if (projectData.currentFile && projectFiles.has(projectData.currentFile)) {
                currentFileName = projectData.currentFile;
                const fileData = projectFiles.get(currentFileName);
                editor.setValue(fileData.content);
                editor.setOption('mode', getCodeMirrorMode(fileData.type));
                document.querySelector('.app-title').textContent = `HTMLç¼–è¾‘å™¨ - ${currentFileName}`;
            } else if (projectFiles.size > 0) {
                // ä¿®å¤ç‚¹ï¼šä¼˜å…ˆé€‰æ‹©index.htmlä½œä¸ºä¸»æ–‡ä»¶
                const indexFile = Array.from(projectFiles.keys()).find(name => name.toLowerCase() === 'index.html');
                
                if (indexFile) {
                    switchToFile(indexFile);
                } else {
                    // å¦‚æœå½“å‰æ–‡ä»¶ä¸å­˜åœ¨ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªæ–‡ä»¶
                    const firstFile = Array.from(projectFiles.keys())[0];
                    switchToFile(firstFile);
                }
            }
            
            console.log(`å·²åŠ è½½é¡¹ç›®ï¼ŒåŒ…å« ${projectFiles.size} ä¸ªæ–‡ä»¶`);
            
        } catch (e) {
            console.error('åŠ è½½é¡¹ç›®å¤±è´¥:', e);
            showToast('é¡¹ç›®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ¨¡æ¿', 'warning');
            
            // åˆ›å»ºé»˜è®¤æ–‡ä»¶
            projectFiles.clear();
            projectFiles.set('index.html', {
                content: DEFAULT_TEMPLATE,
                type: 'html',
                lastModified: Date.now()
            });
            currentFileName = 'index.html';
            editor.setValue(DEFAULT_TEMPLATE);
        }
    } else {
        // å…¼å®¹æ—§ç‰ˆæœ¬æˆ–åˆ›å»ºæ–°é¡¹ç›®
        const savedCode = localStorage.getItem('htmlEditorCode');
        if (savedCode) {
            projectFiles.set('index.html', {
                content: savedCode,
                type: 'html',
                lastModified: Date.now()
            });
            currentFileName = 'index.html';
            editor.setValue(savedCode);
            
            // æ¸…ç†æ—§å­˜å‚¨
            localStorage.removeItem('htmlEditorCode');
            saveCode(); // ä¿å­˜åˆ°æ–°æ ¼å¼
        } else {
            // åˆ›å»ºé»˜è®¤æ–‡ä»¶
            projectFiles.set('index.html', {
                content: DEFAULT_TEMPLATE,
                type: 'html',
                lastModified: Date.now()
            });
            currentFileName = 'index.html';
            editor.setValue(DEFAULT_TEMPLATE);
        }
    }
}

// è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µ
function getStorageUsage() {
    try {
        const projectData = localStorage.getItem('htmlEditorProject');
        const historyData = localStorage.getItem('replaceHistory');
        const settingsData = localStorage.getItem('editorSettings');
        
        const projectSize = projectData ? new Blob([projectData]).size : 0;
        const historySize = historyData ? new Blob([historyData]).size : 0;
        const settingsSize = settingsData ? new Blob([settingsData]).size : 0;
        
        const totalSize = projectSize + historySize + settingsSize;
        const maxSize = 5 * 1024 * 1024; // å‡è®¾5MBé™åˆ¶
        
        return {
            project: projectSize,
            history: historySize,
            settings: settingsSize,
            total: totalSize,
            max: maxSize,
            percentage: (totalSize / maxSize * 100).toFixed(1)
        };
    } catch (error) {
        return null;
    }
}

// æ¸…ç†å­˜å‚¨ç©ºé—´
function cleanupStorage() {
    try {
        // æ¸…ç†è¿‡æœŸçš„å†å²è®°å½•ï¼ˆè¶…è¿‡30å¤©ï¼‰
        const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
        replaceHistory = replaceHistory.filter(item => 
            new Date(item.time).getTime() > thirtyDaysAgo
        );
        
        // é™åˆ¶å†å²è®°å½•æ•°é‡
        if (replaceHistory.length > 50) {
            replaceHistory = replaceHistory.slice(0, 50);
        }
        
        localStorage.setItem('replaceHistory', JSON.stringify(replaceHistory));
        showToast('å­˜å‚¨ç©ºé—´å·²æ¸…ç†', 'success');
        
    } catch (error) {
        showToast('æ¸…ç†å¤±è´¥: ' + error.message, 'error');
    }
}

// æ‰¹é‡åˆ é™¤æ–‡ä»¶
function showBatchDeleteDialog() {
    const dialog = document.createElement('div');
    dialog.className = 'dialog active';
    dialog.id = 'batchDeleteDialog';
    
    const fileList = Array.from(projectFiles.keys()).map(filename => `
        <label style="display: flex; align-items: center; padding: 8px; margin: 4px 0;">
            <input type="checkbox" value="${filename}" style="margin-right: 8px;">
            <span>${filename}</span>
            <small style="margin-left: auto; color: #666;">${formatFileSize(new Blob([projectFiles.get(filename).content]).size)}</small>
        </label>
    `).join('');
    
    dialog.innerHTML = `
        <div class="dialog-header">
            <h3 class="dialog-title">æ‰¹é‡åˆ é™¤æ–‡ä»¶</h3>
            <button class="icon-btn icon-close" onclick="closeBatchDeleteDialog()"></button>
        </div>
        <div class="dialog-content">
            <p>é€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶ï¼š</p>
            <div style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px;">
                ${fileList}
            </div>
        </div>
        <div class="dialog-actions">
            <button class="btn btn-text" onclick="closeBatchDeleteDialog()">å–æ¶ˆ</button>
            <button class="btn btn-primary" onclick="executeBatchDelete()">åˆ é™¤é€‰ä¸­</button>
        </div>
    `;
    
    document.body.appendChild(dialog);
    document.getElementById('overlay').classList.add('active');
}

function closeBatchDeleteDialog() {
    const dialog = document.getElementById('batchDeleteDialog');
    if (dialog) {
        dialog.remove();
    }
    document.getElementById('overlay').classList.remove('active');
}

function executeBatchDelete() {
    const checkboxes = document.querySelectorAll('#batchDeleteDialog input[type="checkbox"]:checked');
    const filesToDelete = Array.from(checkboxes).map(cb => cb.value);
    
    if (filesToDelete.length === 0) {
        showToast('è¯·é€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶', 'warning');
        return;
    }
    
    if (!confirm(`ç¡®å®šè¦åˆ é™¤ ${filesToDelete.length} ä¸ªæ–‡ä»¶å—ï¼Ÿ`)) {
        return;
    }
    
    filesToDelete.forEach(filename => {
        projectFiles.delete(filename);
    });
    
    // å¦‚æœåˆ é™¤äº†å½“å‰æ–‡ä»¶ï¼Œåˆ‡æ¢åˆ°å…¶ä»–æ–‡ä»¶
    if (filesToDelete.includes(currentFileName)) {
        const remainingFiles = Array.from(projectFiles.keys());
        if (remainingFiles.length > 0) {
            switchToFile(remainingFiles[0]);
        } else {
            // åˆ›å»ºé»˜è®¤æ–‡ä»¶
            projectFiles.set('index.html', {
                content: DEFAULT_TEMPLATE,
                type: 'html',
                lastModified: Date.now()
            });
            switchToFile('index.html');
        }
    }
    
    closeBatchDeleteDialog();
    updateFileList();
    saveCode();
    showToast(`å·²åˆ é™¤ ${filesToDelete.length} ä¸ªæ–‡ä»¶`, 'success');
}

// æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦æ˜¯index.htmlï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
function isIndexFile(filename) {
    return filename.toLowerCase() === 'index.html';
}

// ç›‘å¬æœç´¢è¾“å…¥æ¡†å˜åŒ–
document.addEventListener('DOMContentLoaded', () => {
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.addEventListener('input', debounce(performSearch, 300));
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    findPrevious();
                } else {
                    findNext();
                }
            }
        });
    }
});

// overlayç‚¹å‡»äº‹ä»¶å¤„ç†
document.addEventListener('DOMContentLoaded', () => {
    const overlay = document.getElementById('overlay');
    
    overlay.onclick = function() {
        // å…³é—­ä¾§è¾¹æ 
        closeSidebar();
        
        // å…³é—­æ‰€æœ‰å¯¹è¯æ¡†
        const dialogs = document.querySelectorAll('.dialog.active');
        dialogs.forEach(dialog => {
            dialog.classList.remove('active');
        });
        
        // å…³é—­å¯¼å…¥å¯¹è¯æ¡†
        const importDialog = document.getElementById('importDialog');
        if (importDialog) {
            importDialog.remove();
        }
        
        // å…³é—­æœç´¢æ›¿æ¢é¢æ¿
        const searchPanel = document.getElementById('searchReplacePanel');
        if (searchPanel && searchPanel.classList.contains('active')) {
            searchPanel.classList.remove('active');
        }
        
// å…³é—­æ–‡ä»¶ç®¡ç†å™¨
const fileManagerPanel = document.getElementById('fileManagerPanel');
if (fileManagerPanel && fileManagerPanel.classList.contains('active')) {
    fileManagerPanel.classList.remove('active');
}

// å…³é—­å¯¼å‡ºé€‰é¡¹å¯¹è¯æ¡†
const exportOptionsDialog = document.getElementById('exportOptionsDialog');
if (exportOptionsDialog) {
    exportOptionsDialog.remove();
}
        
        // éšè—overlay
        this.classList.remove('active');
    };
});
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            initEditor();
            
            
            // æ¢å¤ç¼©æ”¾çº§åˆ«
            restoreZoom();
    
            // ç›‘å¬è¿”å›é”®
            window.addEventListener('popstate', (e) => {
                if (document.querySelector('.sidebar.active')) {
                    closeSidebar();
                    e.preventDefault();
                }
            });
            
        });
        
        // ç›‘å¬é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + Enter è¿è¡Œ
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                runCode();
            }
            
            // Ctrl/Cmd + S ä¿å­˜
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveCode();
            }
            
// Ctrl/Cmd + Shift + P æ–°çª—å£é¢„è§ˆ
if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'P') {
    e.preventDefault();
    previewInNewWindow();
}

        });
    </script>
</body>
</html>