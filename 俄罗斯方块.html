<!DOCTYPE html>
<html lang="zh-CN">
  <head>        
  <meta charset="UTF-8" />        
  <title>‰øÑÁΩóÊñØÊñπÂùó</title>        
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />        
  <!-- Èü≥È¢ëÂ∫ì Howler.js -->        
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>        
  <style>        
    :root{        
  --bg:#0e1322;        
  --panel:#151a2e;        
  --accent:#4f8cff;        
  --text:#e7ebf3;        
  --muted:#94a3b8;        
  --grid:#1d2544;        
  --ghost:#7aa2ff55;        
  --cell-gap:1;        
  --side-ctrl-w: 100px;        
}        
*{box-sizing:border-box}        
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,"Segoe UI",Roboto,Helvetica,Arial}        
a{color:var(--accent);text-decoration:none}        
.app{        
  display:grid; gap:12px; padding:12px; height:100%;        
  grid-template-rows:auto 1fr auto;        
}        
header, footer{        
  display:flex; align-items:center; justify-content:space-between;        
  background:var(--panel); border-radius:10px; padding:8px 12px;        
  border:1px solid #263057;        
}        
header .title{font-weight:700; letter-spacing:.3px;}        
header .controls{display:flex; gap:8px; flex-wrap:wrap}        
button,select,input{        
  background:#1b2140; color:var(--text); border:1px solid #2b345d; border-radius:8px;        
  padding:8px 10px; font-size:14px; cursor:pointer;        
  transition:transform .08s ease, background .15s ease, box-shadow .15s ease;        
}        
button:hover{background:#232b50}        
button:active{transform:translateY(1px)}        
button.primary{background:#3563e9; border-color:#3563e9}        
button.primary:hover{background:#2f55c8}        
button.danger{background:#dc2626; border-color:#dc2626}        
button.danger:hover{background:#b91c1c}        
.layout{        
  display:grid; gap:12px;        
  grid-template-columns: 180px 1fr 180px;        
  grid-auto-rows: minmax(0,1fr);        
  overflow:hidden;        
}        
.panel{        
  background:var(--panel); border-radius:10px; padding:10px; overflow:auto;        
  border:1px solid #263057;        
}        
.stats{display:grid; gap:6px; font-size:14px}        
.stat-line{display:flex; justify-content:space-between; color:var(--muted)}        
.stat-value{color:var(--text); font-weight:600}        
.right .previews{display:flex; flex-direction:column; gap:8px}        
.preview-item, .hold-box{        
  background:#10142a; border:1px solid #2b3156; border-radius:8px; padding:8px;        
  display:flex; justify-content:center; align-items:center;        
}        
.preview-title{font-size:12px; color:var(--muted); margin-bottom:6px}        
.playfield-wrap{        
  position:relative; display:flex; justify-content:center; align-items:center; height:100%;        
}        
canvas.playfield{background:#0b0f23; border:1px solid #2b3156; border-radius:10px; touch-action:none;}        
.overlay{        
  position:absolute; inset:0; display:none; align-items:center; justify-content:center;        
  background:rgba(10,12,24,.65); backdrop-filter: blur(4px);        
  z-index:1000;        
}        
.overlay.visible{display:flex}        
.modal{        
  width:min(92vw, 820px); max-height:85vh; overflow:auto;        
  background:var(--panel); border:1px solid #2b3156; border-radius:12px; padding:16px;        
  box-shadow:0 20px 50px rgba(0,0,0,.35);        
}        
.modal h3{margin:0 0 8px 0}        
.grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}        
.row{display:flex; gap:10px; align-items:center; margin:6px 0}        
.row label{flex:1; color:var(--muted); font-size:14px}        
.row input[type="number"], .row select{width:140px}        
.modal .actions{display:flex; justify-content:flex-end; gap:8px; margin-top:12px}        
.legend{font-size:12px; color:var(--muted); line-height:1.5}        
.badges{display:flex; gap:6px; flex-wrap:wrap; font-size:11px; margin-top:6px}        
.badge{background:#1a1f3d; border:1px solid #2b3156; color:var(--muted); padding:2px 6px; border-radius:999px}        
        
/* ========== ÁßªÂä®Á´ØÊéßÂà∂ ========== */        
.mobile-controls{        
  display:none; gap:10px; flex-wrap:wrap; justify-content:center; padding:12px;        
}        
.mobile-controls .btn{        
  min-width:70px; padding:14px 16px; border-radius:12px;        
  background:#1b2140; border:2px solid #2b345d;        
  user-select:none; touch-action:manipulation; color:var(--text);        
  box-shadow:0 3px 0 rgba(0,0,0,.4);        
  transition:transform .06s ease, background .12s ease, box-shadow .12s ease;        
  font-size:15px; font-weight:500;        
}        
        
.mobile-controls .btn[data-act="rotateLeft"],        
.mobile-controls .btn[data-act="rotateRight"] {        
  background: linear-gradient(135deg, #2d3a6e, #1f2847);        
  border-color: #4f8cff;        
  color: #4f8cff;        
  font-weight: bold;        
  box-shadow:0 3px 0 rgba(79,140,255,.3);        
}        
        
.mobile-controls .btn:active,        
.mobile-controls .btn.pressed{        
  transform:translateY(2px);        
  box-shadow:0 1px 0 rgba(0,0,0,.5);        
}        
        
/* ‰æßËæπÊéßÂà∂ */        
.mobile-side{        
  position:absolute;        
  display:none;        
  z-index:10;        
}        
        
.mobile-left{        
  left: 0;        
  top: 50%;        
  transform: translateY(-50%);        
}        
        
.mobile-right{        
  right: 0;        
  top: 50%;        
  transform: translateY(-50%);        
}        
        
.mobile-side .btn{        
  display:block;        
  width:calc(var(--side-ctrl-w) - 16px);        
  padding:12px 8px;        
  margin:8px 8px;        
  text-align:center;        
  border-radius:10px;        
  background:#1b2140;        
  border:2px solid #2b345d;        
  color:var(--text);        
  box-shadow:0 3px 0 rgba(0,0,0,.4);        
  user-select:none;        
  touch-action:manipulation;        
  transition:transform .06s ease, background .12s ease, box-shadow .12s ease;        
  font-size:13px;        
  font-weight:500;        
}        
        
.mobile-side .btn[data-act="rotateLeft"],        
.mobile-side .btn[data-act="rotateRight"] {        
  background: linear-gradient(135deg, #2d3a6e, #1f2847);        
  border-color: #4f8cff;        
  color: #4f8cff;        
  font-weight: bold;        
  box-shadow:0 3px 0 rgba(79,140,255,.3);        
}        
        
.mobile-side .btn:active,        
.mobile-side .btn.pressed{        
  transform:translateY(2px);        
  box-shadow:0 1px 0 rgba(0,0,0,.5);        
}        
        
.header-toggle{        
  position:fixed;        
  top:10px;        
  left:50%;        
  transform:translateX(-50%);        
  z-index:100;        
  display:none;        
  background:#1b2140;        
  color:var(--text);        
  border:2px solid #2b345d;        
  border-radius:999px;        
  padding:10px 16px;        
  font-size:13px;        
  box-shadow:0 4px 12px rgba(0,0,0,.4);        
}        
.header-toggle:active{ transform:translateX(-50%) translateY(1px); }        
        
.combo-notification {        
  position: absolute;        
  top: 50%;        
  left: 50%;        
  transform: translate(-50%, -50%);        
  pointer-events: none;        
  z-index: 1000;        
  opacity: 0;        
  font-size: 48px;        
  font-weight: bold;        
  text-shadow: 0 0 10px rgba(0,0,0,0.8), 0 0 20px currentColor;        
  white-space: nowrap;        
}        
        
.combo-notification.show {        
  animation: comboAnim 1.2s ease-out forwards;        
}        
        
@keyframes comboAnim {        
  0% {        
    opacity: 0;        
    transform: translate(-50%, -50%) scale(0.5);        
  }        
  20% {        
    opacity: 1;        
    transform: translate(-50%, -50%) scale(1.3);        
  }        
  40% {        
    transform: translate(-50%, -50%) scale(1.1);        
  }        
  100% {        
    opacity: 0;        
    transform: translate(-50%, -70%) scale(0.9);        
  }        
}        
        
.combo-1 { color: #4f8cff; }        
.combo-2 { color: #10b981; }        
.combo-3 { color: #f59e0b; }        
.combo-4 {        
  color: #ef4444;        
  font-size: 64px;        
  text-shadow: 0 0 20px rgba(239,68,68,0.8), 0 0 40px rgba(239,68,68,0.6);        
}        
.combo-tspin {        
  color: #a855f7;        
  font-size: 56px;        
  text-shadow: 0 0 20px rgba(168,85,247,0.8), 0 0 40px rgba(168,85,247,0.6);        
}        
.combo-b2b {        
  color: #f97316;        
  font-size: 52px;        
  text-shadow: 0 0 20px rgba(249,115,22,0.8), 0 0 40px rgba(249,115,22,0.6);        
}        
        
.status-indicators {        
  display: flex;        
  gap: 8px;        
  flex-wrap: wrap;        
  margin-top: 8px;        
}        
.indicator {        
  padding: 4px 10px;        
  border-radius: 6px;        
  font-size: 11px;        
  font-weight: 600;        
  letter-spacing: 0.5px;        
  opacity: 0.4;        
  transition: opacity 0.3s ease;        
}        
.indicator.active {        
  opacity: 1;        
  animation: pulse 1s ease-in-out infinite;        
}        
.indicator.combo-ind {        
  background: linear-gradient(135deg, #4f8cff, #3563e9);        
}        
.indicator.b2b-ind {        
  background: linear-gradient(135deg, #f97316, #ea580c);        
}        
@keyframes pulse {        
  0%, 100% { transform: scale(1); }        
  50% { transform: scale(1.05); }        
}        
        
/* Ê∏∏ÊàèÊ®°ÂºèÈÄâÊã© */        
.mode-selector {        
  display: grid;        
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));        
  gap: 12px;        
  margin: 16px 0;        
}        
.mode-card {        
  background: #1a1f3d;        
  border: 2px solid #2b3156;        
  border-radius: 10px;        
  padding: 14px;        
  cursor: pointer;        
  transition: all 0.2s ease;        
}        
.mode-card:hover {        
  border-color: #4f8cff;        
  transform: translateY(-2px);        
}        
.mode-card.selected {        
  border-color: #4f8cff;        
  background: #1f2847;        
  box-shadow: 0 0 20px rgba(79, 140, 255, 0.3);        
}        
.mode-card h4 {        
  margin: 0 0 6px 0;        
  color: var(--accent);        
  font-size: 15px;        
}        
.mode-card p {        
  margin: 0;        
  font-size: 12px;        
  color: var(--muted);        
  line-height: 1.4;        
}        
        
/* ËÆ°Êó∂Âô®ÊòæÁ§∫ */        
.timer-display {        
  font-size: 32px;        
  font-weight: bold;        
  text-align: center;        
  color: var(--accent);        
  padding: 12px;        
  background: #1a1f3d;        
  border-radius: 8px;        
  margin: 8px 0;        
  font-variant-numeric: tabular-nums;        
}        
.timer-display.warning {        
  color: #f59e0b;        
  animation: pulse 1s ease-in-out infinite;        
}        
.timer-display.danger {        
  color: #ef4444;        
}        
        
/* ÈîÆ‰ΩçËá™ÂÆö‰πâÁïåÈù¢ */        
.keybind-grid {        
  display: grid;        
  grid-template-columns: 1fr 1fr;        
  gap: 10px;        
  margin: 12px 0;        
}        
.keybind-item {        
  display: flex;        
  justify-content: space-between;        
  align-items: center;        
  padding: 8px 12px;        
  background: #1a1f3d;        
  border-radius: 8px;        
  border: 1px solid #2b3156;        
}        
.keybind-label {        
  color: var(--muted);        
  font-size: 13px;        
}        
.keybind-button {        
  background: #2b345d;        
  color: var(--text);        
  border: 1px solid #3d4873;        
  border-radius: 6px;        
  padding: 6px 12px;        
  font-size: 12px;        
  min-width: 80px;        
  text-align: center;        
  cursor: pointer;        
  transition: all 0.2s ease;        
}        
.keybind-button:hover {        
  background: #364070;        
}        
.keybind-button.listening {        
  background: #3563e9;        
  border-color: #4f8cff;        
  animation: pulse 0.8s ease-in-out infinite;        
}        
        
/* ÊâãÊüÑÊåáÁ§∫Âô® */        
.gamepad-indicator {        
  display: none;        
  align-items: center;        
  gap: 8px;        
  padding: 6px 12px;        
  background: #1a1f3d;        
  border: 1px solid #2b3156;        
  border-radius: 8px;        
  font-size: 12px;        
  margin: 8px 0;        
}        
.gamepad-indicator.connected {        
  display: flex;        
  border-color: #10b981;        
}        
.gamepad-icon {        
  width: 16px;        
  height: 16px;        
  background: #10b981;        
  border-radius: 50%;        
  animation: pulse 2s ease-in-out infinite;        
}        
        
/* Êí§ÈîÄ/ÈáçÂÅöÊåâÈíÆ */        
.undo-controls {        
  display: none;        
  gap: 6px;        
  margin-top: 8px;        
}        
.undo-controls.visible {        
  display: flex;        
}        
.undo-controls button {        
  flex: 1;        
  padding: 6px;        
  font-size: 12px;        
}        
        
/* ÊåñÊéòÊ®°ÂºèÂûÉÂúæË°åÈ¢ÑËßà */        
.cheese-preview {        
  margin-top: 10px;        
  padding: 8px;        
  background: #1a1f3d;        
  border-radius: 8px;        
  border: 1px solid #2b3156;        
}        
.cheese-preview-title {        
  font-size: 11px;        
  color: var(--muted);        
  margin-bottom: 4px;        
}        
.cheese-bar {        
  height: 6px;        
  background: #2b345d;        
  border-radius: 3px;        
  overflow: hidden;        
}        
.cheese-progress {        
  height: 100%;        
  background: linear-gradient(90deg, #10b981, #34d399);        
  transition: width 0.3s ease;        
}        
        
/* ========== ÂìçÂ∫îÂºèÂ∏ÉÂ±Ä ========== */        
        
/* Á´ñÂ±èÊ®°Âºè */        
@media (max-width: 980px) and (orientation: portrait){        
  .layout{        
    grid-template-columns: 1fr;        
    grid-template-rows: auto auto auto;        
    overflow:auto;        
  }        
  .right, .left{order:2}        
  .center{order:1; min-height:55vh}        
          
  .mobile-controls{        
    display:flex;        
    padding:16px 12px;        
  }        
  .mobile-controls .btn{        
    flex:1 1 calc(25% - 8px);        
    min-width:70px;        
    max-width:120px;        
    padding:16px 12px;        
    font-size:14px;        
  }        
  .mobile-side{display:none}        
          
  header, footer{        
    position:sticky;        
    top:0;        
    z-index:50;        
  }        
          
  .combo-notification {        
    font-size: 32px;        
  }        
  .combo-4 { font-size: 42px; }        
  .combo-tspin { font-size: 38px; }        
  .combo-b2b { font-size: 36px; }        
          
  .header-toggle{ display:none; }        
}        
        
/* Ê®™Â±èÊ®°Âºè */        
@media (max-width: 980px) and (orientation: landscape){        
  .layout{        
    grid-template-columns: 120px 1fr 120px;        
    grid-template-rows: 1fr;        
    overflow:hidden;        
  }        
  .left, .right{        
    order:initial;        
    font-size:12px;        
  }        
  .center{        
    min-height:100%;        
  }        
          
  header{        
    display:none;        
  }        
  header.header-visible{        
    display:flex;        
    position:fixed;        
    left:10px;        
    right:10px;        
    top:50px;        
    z-index:100;        
    box-shadow:0 8px 20px rgba(0,0,0,.5);        
  }        
  footer{display:none}        
        
  .mobile-controls{display:none}        
          
  .playfield-wrap{        
    padding-left: var(--side-ctrl-w);        
    padding-right: var(--side-ctrl-w);        
  }        
          
  .mobile-side{        
    display:block;        
  }        
          
  .header-toggle{        
    display:inline-flex;        
    align-items:center;        
    gap:6px;        
  }        
          
  /* Ê®™Â±èÊó∂Âè≥‰æßÈù¢ÊùøÁâπÊÆäÂ∏ÉÂ±Ä */        
  .right {        
    display: flex;        
    flex-direction: column;        
    gap:8px;        
    padding:8px;        
  }        
          
  .right .preview-title {        
    order: 1;        
    margin-bottom: 4px;        
    font-size:11px;        
  }        
          
  .right .previews {        
    order: 2;        
    flex:1;        
    overflow-y:auto;        
  }        
          
  .right .previews .preview-item{        
    padding:4px;        
  }        
          
  .right .previews canvas{        
    width:100%;        
    height:auto;        
    max-height:70px;        
  }        
          
  /* Â∑¶‰æßÈù¢Êùø‰ºòÂåñ */        
  .left{        
    padding:8px;        
  }        
  .left .hold-box{        
    margin-bottom:8px;        
    padding:6px;        
  }        
  .left .preview-title{        
    font-size:11px;        
  }        
  .left .stats{        
    font-size:12px;        
    gap:4px;        
  }        
  .left .badges{        
    display:none;        
  }        
          
  .combo-notification {        
    font-size: 28px;        
  }        
  .combo-4 { font-size: 36px; }        
  .combo-tspin { font-size: 32px; }        
  .combo-b2b { font-size: 30px; }        
}        
        
/* Ë∂ÖÂ∞èÂ±èÂπï‰ºòÂåñ */        
@media (max-width: 640px) and (orientation: landscape){        
  .layout{        
    grid-template-columns: 100px 1fr 100px;        
  }        
          
  :root{        
    --side-ctrl-w: 85px;        
  }        
          
  .mobile-side .btn{        
    padding:10px 6px;        
    font-size:12px;        
    margin:6px 6px;        
  }        
          
  .left, .right{        
    font-size:11px;        
  }        
          
  .stat-line{        
    font-size:11px;        
  }        
}        
        
/* Tab ÂØºËà™ */        
.tab-nav {        
  display: flex;        
  gap: 8px;        
  margin-bottom: 16px;        
  border-bottom: 2px solid #2b3156;        
}        
.tab-btn {        
  background: transparent;        
  border: none;        
  border-bottom: 2px solid transparent;        
  padding: 8px 16px;        
  margin-bottom: -2px;        
  cursor: pointer;        
  color: var(--muted);        
  transition: all 0.2s ease;        
}        
.tab-btn:hover {        
  color: var(--text);        
  background: transparent;        
}        
.tab-btn.active {        
  color: var(--accent);        
  border-bottom-color: var(--accent);        
}        
.tab-content {        
  display: none;        
}        
.tab-content.active {        
  display: block;        
}        
        
/* Â±èÂπïÈúáÂä®Âä®Áîª */        
@keyframes screen-shake {        
  0%, 100% { transform: translate(0, 0) rotate(0deg); }        
  10% { transform: translate(-2px, 1px) rotate(-0.5deg); }        
  20% { transform: translate(2px, -1px) rotate(0.5deg); }        
  30% { transform: translate(-1px, 2px) rotate(-0.3deg); }        
  40% { transform: translate(1px, -2px) rotate(0.3deg); }        
  50% { transform: translate(-2px, -1px) rotate(-0.4deg); }        
  60% { transform: translate(2px, 1px) rotate(0.4deg); }        
  70% { transform: translate(-1px, -2px) rotate(-0.2deg); }        
  80% { transform: translate(1px, 2px) rotate(0.2deg); }        
  90% { transform: translate(-2px, -1px) rotate(-0.1deg); }        
}        
        
.playfield-wrap.shake {        
  animation: screen-shake 0.5s ease-in-out;        
}        
        
.playfield-wrap.all-clear {        
  animation: allClearFlash 0.8s ease-in-out 3;        
}        
        
/* Hold Âä®Áîª */        
@keyframes hold-fly-in {        
  0% {        
    opacity: 0;        
    transform: translateX(-100px) scale(0.5) rotate(-180deg);        
  }        
  60% {        
    transform: translateX(10px) scale(1.1) rotate(10deg);        
  }        
  100% {        
    opacity: 1;        
    transform: translateX(0) scale(1) rotate(0deg);        
  }        
}        
        
@keyframes hold-fly-out {        
  0% {        
    opacity: 1;        
    transform: translateX(0) scale(1) rotate(0deg);        
  }        
  100% {        
    opacity: 0;        
    transform: translateX(-100px) scale(0.5) rotate(-180deg);        
  }        
}        
        
.hold-box.animate-in canvas {        
  animation: hold-fly-in 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);        
}        
        
.hold-box.animate-out canvas {        
  animation: hold-fly-out 0.4s cubic-bezier(0.6, -0.28, 0.735, 0.045);        
}

.hold-box.locked {
  opacity: 0.5;
  filter: grayscale(60%);
}

.hold-box.locked::after {
  content: 'üîí';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
  pointer-events: none;
}

.hold-box {
  position: relative;
}
        
/* Âä®ÊÄÅËÉåÊôØÁ≤íÂ≠ê */        
.background-particles {        
  position: absolute;        
  top: 0;        
  left: 0;        
  width: 100%;        
  height: 100%;        
  pointer-events: none;        
  z-index: 0;        
  overflow: hidden;        
}        
        
.bg-particle {        
  position: absolute;        
  background: radial-gradient(circle, rgba(79, 140, 255, 0.3), transparent);        
  border-radius: 50%;        
  animation: float-particle linear infinite;        
}        
        
@keyframes float-particle {        
  0% {        
    transform: translateY(0) translateX(0) scale(1);        
    opacity: 0;        
  }        
  10% {        
    opacity: 0.6;        
  }        
  90% {        
    opacity: 0.3;        
  }        
  100% {        
    transform: translateY(-100vh) translateX(50px) scale(0.5);        
    opacity: 0;        
  }        
}        
        
/* ÊñπÂùóÁ∫πÁêÜÂÖâÊ≥ΩÊïàÊûú */        
.playfield.glossy {        
  filter: brightness(1.1) contrast(1.05);        
}        
        
/* Level ÂèòÂåñÈó™ÂÖâ */        
@keyframes level-flash {        
  0%, 100% {        
    box-shadow: 0 0 0 rgba(79, 140, 255, 0);        
  }        
  50% {        
    box-shadow: 0 0 30px rgba(79, 140, 255, 0.8),        
                inset 0 0 20px rgba(79, 140, 255, 0.3);        
  }        
}        
        
.playfield.level-up {        
  animation: level-flash 0.6s ease-out;        
}        
        
/* Èü≥ÈáèÊéßÂà∂ÊåâÈíÆ */        
.audio-controls {        
  display: flex;        
  gap: 8px;        
  align-items: center;        
}        
        
.audio-toggle {        
  background: #1b2140;        
  border: 1px solid #2b345d;        
  border-radius: 8px;        
  padding: 8px 12px;        
  cursor: pointer;        
  transition: all 0.2s ease;        
  font-size: 16px;        
}        
        
.audio-toggle:hover {        
  background: #232b50;        
  transform: scale(1.05);        
}        
        
.audio-toggle.muted {        
  opacity: 0.5;        
  background: #3d1f1f;        
}        
        
@keyframes allClearFlash {        
  0%, 100% { filter: brightness(1); }        
  50% { filter: brightness(1.8) contrast(1.2); }        
}        
        
/* ========== Á´ñÂ±èÊèêÁ§∫ ========== */        
.portrait-warning {        
  display: none;        
  position: fixed;        
  top: 0;        
  left: 0;        
  width: 100%;        
  height: 100%;        
  background: linear-gradient(135deg, var(--bg) 0%, #1a1f3d 100%);        
  z-index: 10000;        
  align-items: center;        
  justify-content: center;        
  flex-direction: column;        
}        
        
.portrait-warning.show {        
  display: flex;        
}        
        
.portrait-content {        
  text-align: center;        
  padding: 40px 20px;        
  max-width: 400px;        
}        
        
.portrait-icon {        
  font-size: 100px;        
  margin-bottom: 30px;        
  animation: rotate-hint 2s ease-in-out infinite;        
  filter: drop-shadow(0 0 20px rgba(79, 140, 255, 0.5));        
}        
        
@keyframes rotate-hint {        
  0%, 100% {        
    transform: rotate(0deg) scale(1);        
  }        
  25% {        
    transform: rotate(-15deg) scale(1.1);        
  }        
  50% {        
    transform: rotate(0deg) scale(1);        
  }        
  75% {        
    transform: rotate(15deg) scale(1.1);        
  }        
}        
        
.portrait-content h2 {        
  font-size: 28px;        
  margin: 20px 0;        
  color: var(--accent);        
  font-weight: 700;        
  text-shadow: 0 2px 10px rgba(79, 140, 255, 0.3);        
}        
        
.portrait-content p {        
  font-size: 16px;        
  color: var(--muted);        
  line-height: 1.8;        
  margin-top: 16px;        
}        
        
/* Âè™Âú®ÁßªÂä®Á´ØÁ´ñÂ±èÊó∂Âº∫Âà∂ÊòæÁ§∫ */        
@media (max-width: 980px) and (orientation: portrait) {        
  .portrait-warning.active {        
    display: flex !important;        
  }        
          
  /* ÈöêËóè‰∏ªÁïåÈù¢ÔºåÈò≤Ê≠¢Á©øÈÄè */        
  .portrait-warning.active ~ .app {        
    display: none;        
  }        
}        
        
/* Ê®™Â±èÊó∂Á°Æ‰øùÈöêËóè */        
@media (orientation: landscape) {        
  .portrait-warning {        
    display: none !important;        
  }        
}        
        
/* ========== ÊéíË°åÊ¶úÊ†∑Âºè ========== */        
.leaderboard-overlay {        
  position: fixed;        
  inset: 0;        
  display: none;        
  align-items: center;        
  justify-content: center;        
  background: rgba(10,12,24,.75);        
  backdrop-filter: blur(6px);        
  z-index: 2000;        
}        
.leaderboard-overlay.visible {        
  display: flex;        
}        
        
.leaderboard-modal {        
  width: min(95vw, 700px);        
  max-height: 85vh;        
  overflow: auto;        
  background: var(--panel);        
  border: 1px solid #2b3156;        
  border-radius: 12px;        
  padding: 20px;        
  box-shadow: 0 20px 50px rgba(0,0,0,.5);        
}        
        
.leaderboard-modal h3 {        
  margin: 0 0 16px 0;        
  text-align: center;        
  color: var(--accent);        
  font-size: 22px;        
}        
        
.leaderboard-tabs {        
  display: flex;        
  gap: 6px;        
  margin-bottom: 16px;        
  flex-wrap: wrap;        
  justify-content: center;        
}        
        
.leaderboard-tab {        
  background: #1b2140;        
  border: 1px solid #2b345d;        
  color: var(--muted);        
  padding: 8px 14px;        
  border-radius: 8px;        
  cursor: pointer;        
  font-size: 13px;        
  transition: all 0.2s ease;        
}        
        
.leaderboard-tab:hover {        
  background: #232b50;        
}        
        
.leaderboard-tab.active {        
  background: var(--accent);        
  border-color: var(--accent);        
  color: #fff;        
}        
        
.leaderboard-list {        
  background: #10142a;        
  border-radius: 10px;        
  overflow: hidden;        
}        
        
.leaderboard-header {        
  display: grid;        
  grid-template-columns: 50px 1fr 100px 120px;        
  gap: 10px;        
  padding: 12px 16px;        
  background: #1a1f3d;        
  font-size: 12px;        
  color: var(--muted);        
  font-weight: 600;        
  text-transform: uppercase;        
  letter-spacing: 0.5px;        
}        
        
.leaderboard-row {        
  display: grid;        
  grid-template-columns: 50px 1fr 100px 120px;        
  gap: 10px;        
  padding: 12px 16px;        
  border-top: 1px solid #1d2544;        
  font-size: 14px;        
  transition: background 0.15s ease;        
}        
        
.leaderboard-row:hover {        
  background: #1a1f3d;        
}        
        
.leaderboard-row.highlight {        
  background: rgba(79, 140, 255, 0.15);        
  border-left: 3px solid var(--accent);        
}        
        
.leaderboard-rank {        
  font-weight: 700;        
  color: var(--muted);        
}        
        
.leaderboard-rank.gold { color: #ffd700; }        
.leaderboard-rank.silver { color: #c0c0c0; }        
.leaderboard-rank.bronze { color: #cd7f32; }        
        
.leaderboard-score {        
  font-weight: 600;        
  color: var(--accent);        
}        
        
.leaderboard-date {        
  color: var(--muted);        
  font-size: 12px;        
}        
        
.leaderboard-empty {        
  text-align: center;        
  padding: 40px 20px;        
  color: var(--muted);        
  font-size: 14px;        
}        
        
.leaderboard-actions {        
  display: flex;        
  justify-content: space-between;        
  margin-top: 16px;        
  gap: 10px;        
}        
        
/* ÁªüËÆ°Èù¢ÊùøÊ†∑Âºè */        
.stats-panel {        
  display: grid;        
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));        
  gap: 12px;        
  margin-bottom: 16px;        
}        
        
.stats-card {        
  background: #1a1f3d;        
  border: 1px solid #2b3156;        
  border-radius: 10px;        
  padding: 14px;        
  text-align: center;        
}        
        
.stats-card-value {        
  font-size: 24px;        
  font-weight: 700;        
  color: var(--accent);        
  margin-bottom: 4px;        
}        
        
.stats-card-label {        
  font-size: 11px;        
  color: var(--muted);        
  text-transform: uppercase;        
  letter-spacing: 0.5px;        
}        
        
/* ÁªßÁª≠Ê∏∏ÊàèÊèêÁ§∫ */        
.resume-prompt {        
  background: linear-gradient(135deg, #1a3a5c, #1f2847);        
  border: 2px solid var(--accent);        
  border-radius: 12px;        
  padding: 16px;        
  margin-bottom: 16px;        
  text-align: center;        
}        
        
.resume-prompt h4 {        
  margin: 0 0 8px 0;        
  color: var(--accent);        
}        
        
.resume-prompt p {        
  margin: 0 0 12px 0;        
  font-size: 13px;        
  color: var(--muted);        
}        
        
.resume-prompt .actions {        
  display: flex;        
  gap: 10px;        
  justify-content: center;        
}        
        
/* Èü≥È¢ëÊéßÂà∂ÊªëÂùó */        
.volume-control {        
  display: flex;        
  align-items: center;        
  gap: 10px;        
  margin: 8px 0;        
}        
        
.volume-control label {        
  flex: 1;        
  color: var(--muted);        
  font-size: 14px;        
}        
        
  .volume-slider {        
  width: 120px;        
  height: 6px;        
  -webkit-appearance: none;        
  appearance: none;        
  background: #2b345d;        
  border-radius: 3px;        
  outline: none;        
}        
        
.volume-slider::-webkit-slider-thumb {        
  -webkit-appearance: none;        
  width: 16px;        
  height: 16px;        
  background: var(--accent);        
  border-radius: 50%;        
  cursor: pointer;        
  transition: transform 0.1s ease;        
}        
        
.volume-slider::-webkit-slider-thumb:hover {        
  transform: scale(1.2);        
}        
        
/* Ê®™Â±èÊéíË°åÊ¶ú‰ºòÂåñ */        
@media (max-width: 980px) and (orientation: landscape) {        
  .leaderboard-modal {        
    max-height: 90vh;        
    padding: 12px;        
  }        
          
  .leaderboard-modal h3 {        
    font-size: 18px;        
    margin-bottom: 10px;        
  }        
          
  .leaderboard-header,        
  .leaderboard-row {        
    grid-template-columns: 40px 1fr 80px 100px;        
    padding: 8px 12px;        
    font-size: 12px;        
  }        
          
  .leaderboard-tabs {        
    gap: 4px;        
    margin-bottom: 10px;        
  }        
          
  .leaderboard-tab {        
    padding: 6px 10px;        
    font-size: 11px;        
  }        
          
  .stats-panel {        
    grid-template-columns: repeat(3, 1fr);        
    gap: 8px;        
  }        
          
  .stats-card {        
    padding: 10px;        
  }        
          
  .stats-card-value {        
    font-size: 18px;        
  }        
          
  .stats-card-label {        
    font-size: 10px;        
  }        
}        
        
/* Á´ñÂ±èÊéíË°åÊ¶ú‰ºòÂåñ */        
@media (max-width: 980px) and (orientation: portrait) {        
  .leaderboard-header,        
  .leaderboard-row {        
    grid-template-columns: 40px 1fr 70px;        
  }        
          
  .leaderboard-date {        
    display: none;        
  }        
          
  .stats-panel {        
    grid-template-columns: repeat(2, 1fr);        
  }        
}        
        
/* ========== ÂÄíËÆ°Êó∂ÊèêÁ§∫Ê†∑Âºè ========== */        
.countdown-overlay {        
  position: fixed;        
  inset: 0;        
  display: none;        
  align-items: center;        
  justify-content: center;        
  background: rgba(10,12,24,.85);        
  backdrop-filter: blur(8px);        
  z-index: 3000;        
}        
        
.countdown-overlay.visible {        
  display: flex;        
}        
        
.countdown-content {        
  text-align: center;        
}        
        
.countdown-number {        
  font-size: 150px;        
  font-weight: 900;        
  color: var(--accent);        
  text-shadow: 0 0 40px rgba(79, 140, 255, 0.8), 0 0 80px rgba(79, 140, 255, 0.5);        
  animation: countdownPulse 0.8s ease-out;        
}        
        
.countdown-number.go {        
  font-size: 120px;        
  color: #10b981;        
  text-shadow: 0 0 40px rgba(16, 185, 129, 0.8), 0 0 80px rgba(16, 185, 129, 0.5);        
}        
        
@keyframes countdownPulse {        
  0% {        
    transform: scale(0.3);        
    opacity: 0;        
  }        
  50% {        
    transform: scale(1.2);        
    opacity: 1;        
  }        
  100% {        
    transform: scale(1);        
    opacity: 1;        
  }        
}        
        
/* ========== ÊöÇÂÅúËèúÂçïÁæéÂåñ ========== */        
.pause-overlay {        
  position: fixed;        
  inset: 0;        
  display: none;        
  align-items: center;        
  justify-content: center;        
  background: rgba(10,12,24,.7);        
  backdrop-filter: blur(12px);        
  z-index: 2500;        
}        
        
.pause-overlay.visible {        
  display: flex;        
}        
        
.pause-modal {        
  background: var(--panel);        
  border: 2px solid var(--accent);        
  border-radius: 16px;        
  padding: 32px 48px;        
  text-align: center;        
  box-shadow: 0 0 60px rgba(79, 140, 255, 0.3);        
}        
        
.pause-modal h2 {        
  font-size: 36px;        
  margin: 0 0 8px 0;        
  color: var(--accent);        
}        
        
.pause-modal p {        
  color: var(--muted);        
  margin: 0 0 24px 0;        
}        
        
.pause-modal .pause-stats {        
  display: grid;        
  grid-template-columns: repeat(3, 1fr);        
  gap: 16px;        
  margin-bottom: 24px;        
  padding: 16px;        
  background: #10142a;        
  border-radius: 10px;        
}        
        
.pause-modal .pause-stat {        
  text-align: center;        
}        
        
.pause-modal .pause-stat-value {        
  font-size: 24px;        
  font-weight: bold;        
  color: var(--text);        
}        
        
.pause-modal .pause-stat-label {        
  font-size: 11px;        
  color: var(--muted);        
  text-transform: uppercase;        
}        
        
.pause-modal .actions {        
  display: flex;        
  gap: 12px;        
  justify-content: center;        
}        
        
/* ========== Á≠âÁ∫ßÊèêÂçáÂÖ®Â±èÂä®Áîª ========== */        
.levelup-overlay {        
  position: fixed;        
  inset: 0;        
  display: none;        
  align-items: center;        
  justify-content: center;        
  background: transparent;        
  pointer-events: none;        
  z-index: 2800;        
}        
        
.levelup-overlay.visible {        
  display: flex;        
  animation: levelupFlash 1.5s ease-out forwards;        
}        
        
@keyframes levelupFlash {        
  0% {        
    background: rgba(79, 140, 255, 0.4);        
  }        
  100% {        
    background: transparent;        
  }        
}        
        
.levelup-content {        
  text-align: center;        
  animation: levelupZoom 1.5s ease-out forwards;        
}        
        
@keyframes levelupZoom {        
  0% {        
    transform: scale(0.5) rotate(-10deg);        
    opacity: 0;        
  }        
  20% {        
    transform: scale(1.3) rotate(5deg);        
    opacity: 1;        
  }        
  40% {        
    transform: scale(1) rotate(0deg);        
  }        
  100% {        
    transform: scale(1.5) translateY(-50px);        
    opacity: 0;        
  }        
}        
        
.levelup-text {        
  font-size: 48px;        
  font-weight: 900;        
  color: #ffd700;        
  text-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.5);        
}        
        
.levelup-level {        
  font-size: 80px;        
  font-weight: 900;        
  color: var(--accent);        
  text-shadow: 0 0 40px rgba(79, 140, 255, 0.8);        
}        
        
/* ========== Ê∏∏ÊàèÁªìÊùüÁªüËÆ°È°µ ========== */        
.gameover-overlay {        
  position: fixed;        
  inset: 0;        
  display: none;        
  align-items: center;        
  justify-content: center;        
  background: rgba(10,12,24,.85);        
  backdrop-filter: blur(10px);        
  z-index: 3500;        
}        
        
.gameover-overlay.visible {        
  display: flex;        
}        
        
.gameover-modal {        
  width: min(95vw, 500px);        
  max-height: 90vh;        
  overflow: auto;        
  background: var(--panel);        
  border: 2px solid #ef4444;        
  border-radius: 16px;        
  padding: 24px;        
  text-align: center;        
  box-shadow: 0 0 60px rgba(239, 68, 68, 0.3);        
}        
        
.gameover-modal.victory {        
  border-color: #10b981;        
  box-shadow: 0 0 60px rgba(16, 185, 129, 0.3);        
}        
        
.gameover-modal h2 {        
  font-size: 32px;        
  margin: 0 0 8px 0;        
  color: #ef4444;        
}        
        
.gameover-modal.victory h2 {        
  color: #10b981;        
}        
        
.gameover-modal .subtitle {        
  color: var(--muted);        
  margin: 0 0 20px 0;        
  font-size: 14px;        
}        
        
.gameover-stats-grid {        
  display: grid;        
  grid-template-columns: repeat(2, 1fr);        
  gap: 12px;        
  margin-bottom: 20px;        
}        
        
.gameover-stat-card {        
  background: #10142a;        
  border: 1px solid #2b3156;        
  border-radius: 10px;        
  padding: 14px;        
}        
        
.gameover-stat-card.highlight {        
  border-color: var(--accent);        
  background: rgba(79, 140, 255, 0.1);        
}        
        
.gameover-stat-value {        
  font-size: 28px;        
  font-weight: bold;        
  color: var(--text);        
}        
        
.gameover-stat-label {        
  font-size: 11px;        
  color: var(--muted);        
  text-transform: uppercase;        
  margin-top: 4px;        
}        
        
.gameover-rank {        
  background: linear-gradient(135deg, #ffd700, #f59e0b);        
  color: #000;        
  padding: 12px 20px;        
  border-radius: 10px;        
  margin-bottom: 20px;        
  font-weight: bold;        
}        
        
.gameover-rank.new-record {        
  animation: newRecordPulse 1s ease-in-out infinite;        
}        
        
@keyframes newRecordPulse {        
  0%, 100% { transform: scale(1); }        
  50% { transform: scale(1.05); }        
}        
        
.gameover-actions {        
  display: flex;        
  flex-direction: column;        
  gap: 10px;        
}        
        
/* ========== ËæìÂÖ•ÂèçÈ¶àÔºàÊåâÈîÆÈ´ò‰∫ÆÔºâ========== */        
.key-feedback {        
  position: fixed;        
  bottom: 20px;        
  left: 50%;        
  transform: translateX(-50%);        
  display: flex;        
  gap: 8px;        
  z-index: 100;        
  pointer-events: none;        
}        
        
.key-indicator {        
  background: #1b2140;        
  border: 2px solid #2b345d;        
  border-radius: 8px;        
  padding: 8px 14px;        
  font-size: 12px;        
  color: var(--muted);        
  transition: all 0.1s ease;        
  min-width: 50px;        
  text-align: center;        
}        
        
.key-indicator.active {        
  background: var(--accent);        
  border-color: var(--accent);        
  color: #fff;        
  transform: scale(1.1);        
  box-shadow: 0 0 15px rgba(79, 140, 255, 0.5);        
}        
        
.key-indicator.left.active { background: #3563e9; border-color: #3563e9; }        
.key-indicator.right.active { background: #3563e9; border-color: #3563e9; }        
.key-indicator.rotate.active { background: #a855f7; border-color: #a855f7; }        
.key-indicator.drop.active { background: #10b981; border-color: #10b981; }        
.key-indicator.hard.active { background: #ef4444; border-color: #ef4444; }        
.key-indicator.hold.active { background: #f59e0b; border-color: #f59e0b; }        
        
/* Ê®™Â±èÊâãÊú∫Á´ØÈöêËóèÊåâÈîÆÂèçÈ¶àÔºàÈÅøÂÖçÈÅÆÊå°Ôºâ */        
@media (max-width: 980px) and (orientation: landscape) {        
  .key-feedback {        
    display: none;        
  }        
          
  .pause-modal .pause-stats {        
    grid-template-columns: repeat(2, 1fr);        
    gap: 8px;        
  }        
          
  .pause-modal {        
    padding: 20px 30px;        
  }        
          
  .pause-modal h2 {        
    font-size: 28px;        
  }        
          
  .gameover-modal {        
    max-height: 85vh;        
    padding: 16px;        
  }        
          
  .gameover-stats-grid {        
    grid-template-columns: repeat(3, 1fr);        
    gap: 8px;        
  }        
          
  .gameover-stat-card {        
    padding: 10px;        
  }        
          
  .gameover-stat-value {        
    font-size: 20px;        
  }        
          
  .levelup-text {        
    font-size: 36px;        
  }        
          
  .levelup-level {        
    font-size: 60px;        
  }        
          
  .countdown-number {        
    font-size: 100px;        
  }        
          
  .countdown-number.go {        
    font-size: 80px;        
  }        
}        
        
/* Á´ñÂ±èÊâãÊú∫Á´Ø */        
@media (max-width: 980px) and (orientation: portrait) {        
  .key-feedback {        
    bottom: 10px;        
    gap: 4px;        
  }        
          
  .key-indicator {        
    padding: 6px 10px;        
    font-size: 10px;        
    min-width: 40px;        
  }        
          
  .gameover-stats-grid {        
    grid-template-columns: 1fr 1fr;        
  }        
}

.lock-progress-bar {
  position: absolute;
  bottom: 2px;
  left: 2px;
  right: 2px;
  height: 6px;
  background: rgba(30, 40, 80, 0.8);
  border-radius: 3px;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.lock-progress-fill {
  height: 100%;
  transition: width 0.05s linear, background-color 0.2s ease;
  border-radius: 2px;
}

.lock-progress-fill.safe {
  background: linear-gradient(90deg, #10b981, #34d399);
  box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
}

.lock-progress-fill.warning {
  background: linear-gradient(90deg, #f59e0b, #fbbf24);
  box-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
}

.lock-progress-fill.danger {
  background: linear-gradient(90deg, #ef4444, #f87171);
  box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
  animation: dangerPulse 0.3s ease-in-out infinite;
}

@keyframes dangerPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

@keyframes pieceBlink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.piece-locking {
  animation: pieceBlink 0.2s ease-in-out infinite;
}
        
  </style>        
</head>        
<body>        
<div class="app">          
<!-- Á´ñÂ±èÊèêÁ§∫ÈÅÆÁΩ© -->          
<div id="portraitWarning" class="portrait-warning">          
  <div class="portrait-content">          
    <div class="portrait-icon">üì±</div>          
    <h2>ËØ∑ÊóãËΩ¨ÊÇ®ÁöÑËÆæÂ§á</h2>          
    <p>‰∏∫‰∫ÜËé∑ÂæóÊúÄ‰Ω≥Ê∏∏Êàè‰ΩìÈ™å<br>ËØ∑Â∞ÜËÆæÂ§áÊ®™ÂêëÊîæÁΩÆ</p>          
  </div>          
</div>          
  <header id="topHeader">          
    <div class="title">‰øÑÁΩóÊñØÊñπÂùó</div>          
    <div class="controls">          
  <button id="btnPlayPause" class="primary">‚ñ∂ ÂºÄÂßã</button>          
  <button id="btnRestart">üîÑ ÈáçÊñ∞ÂºÄÂßã</button>          
  <button id="btnSettings">‚öô ËÆæÁΩÆ</button>          
  <button id="btnLeaderboard">üèÜ ÊéíË°åÊ¶ú</button>          
</div>          
  </header>          
          
  <button class="header-toggle" id="btnHeaderToggle">‚ò∞ ËèúÂçï</button>          
          
  <div class="layout">          
    <div class="panel left">          
      <div class="preview-title">ÊöÇÂ≠ò (C/Shift)</div>          
      <div class="hold-box" style="margin-bottom:10px">          
        <canvas id="hold" width="140" height="140"></canvas>          
      </div>          
                
      <div class="stat-line" style="margin-bottom: 8px;">          
        <span>Ê®°Âºè</span>          
        <strong class="stat-value" id="modeDisplay">È©¨ÊãâÊùæ</strong>          
      </div>          
          
      <div id="timerContainer" style="display:none;">          
        <div class="timer-display" id="timerDisplay">00:00.00</div>          
      </div>          
          
      <div id="cheeseContainer" class="cheese-preview" style="display:none;">          
        <div class="cheese-preview-title">ÂûÉÂúæË°åÂâ©‰Ωô</div>          
        <div class="stat-line">          
          <span>Ââ©‰Ωô</span>          
          <strong class="stat-value" id="cheeseRemaining">0</strong>          
        </div>          
        <div class="cheese-bar">          
          <div class="cheese-progress" id="cheeseProgress" style="width: 0%"></div>          
        </div>          
      </div>          
          
      <div class="gamepad-indicator" id="gamepadIndicator">          
        <div class="gamepad-icon"></div>          
        <span id="gamepadName">ÊâãÊüÑÂ∑≤ËøûÊé•</span>          
      </div>          
          
      <div class="stats">          
        <div class="stat-line" id="scoreRow">          
          <span>ÂàÜÊï∞</span>          
          <strong class="stat-value" id="score">0</strong>          
        </div>          
        <div class="stat-line">          
          <span>Á∫ßÂà´</span>          
          <strong class="stat-value" id="level">1</strong>          
        </div>          
        <div class="stat-line">          
          <span>Ë°åÊï∞</span>          
          <strong class="stat-value" id="lines">0</strong>          
        </div>          
        <div class="stat-line">          
          <span>ËøûÂáª</span>          
          <strong class="stat-value" id="combo">0</strong>          
        </div>          
                  
        <div class="status-indicators">          
          <div class="indicator combo-ind" id="comboInd">COMBO</div>          
          <div class="indicator b2b-ind" id="b2bInd">B2B</div>          
        </div>          
          
        <div class="undo-controls" id="undoControls">          
          <button id="btnUndo" title="Êí§ÈîÄ (Ctrl+Z)">‚Ü∂ Êí§ÈîÄ</button>          
          <button id="btnRedo" title="ÈáçÂÅö (Ctrl+Y)">‚Ü∑ ÈáçÂÅö</button>          
        </div>          
          
        <div class="badges">          
          <span class="badge">Ëá™ÂÆö‰πâÈîÆ‰Ωç</span>          
          <span class="badge">ÊâãÊüÑÊîØÊåÅ</span>          
          <span class="badge">ÈúáÂä®ÂèçÈ¶à</span>          
          <span class="badge">Â§öÁßçÊ®°Âºè</span>          
        </div>          
      </div>          
    </div>          
          
    <div class="panel center">          
      <div class="playfield-wrap">          
        <div class="mobile-side mobile-left" id="mobileLeft">          
          <div class="btn" data-act="left">‚Üê Â∑¶</div>          
          <div class="btn" data-act="rotateLeft">‚Ü∫ Â∑¶Êóã</div>          
          <div class="btn" data-act="soft">‚Üì ËΩØÈôç</div>          
          <div class="btn" data-act="hold">Hold</div>          
        </div>          
                  
        <canvas id="playfield" class="playfield" width="300" height="600"></canvas>          
                  
        <div class="mobile-side mobile-right" id="mobileRight">          
          <div class="btn" data-act="right">Âè≥ ‚Üí</div>          
          <div class="btn" data-act="rotateRight">‚Üª Âè≥Êóã</div>          
          <div class="btn" data-act="hard">‚§ì Á°¨Èôç</div>          
          <div class="btn" data-act="pause">‚è∏ ÊöÇÂÅú</div>          
        </div>          
      </div>          
          
          
        <div class="combo-notification" id="comboNotif"></div>          
          
        <div class="overlay" id="overlay">          
          <div class="modal">          
            <h3 id="modalTitle">Ê∏∏ÊàèËÆæÁΩÆ</h3>          
                      
            <div class="tab-nav">          
              <button class="tab-btn active" data-tab="mode">Ê∏∏ÊàèÊ®°Âºè</button>          
              <button class="tab-btn" data-tab="general">Â∏∏ËßÑËÆæÁΩÆ</button>          
              <button class="tab-btn" data-tab="controls">ÊéßÂà∂ËÆæÁΩÆ</button>          
            </div>          
          
            <div class="tab-content active" id="tabMode">          
              <div class="mode-selector">          
                <div class="mode-card selected" data-mode="marathon">          
                  <h4>üèÉ È©¨ÊãâÊùæÊ®°Âºè</h4>          
                  <p>ÁªèÂÖ∏Áé©Ê≥ïÔºåÈöèÂàÜÊï∞/Ë°åÊï∞ÂçáÁ∫ßÔºåÊåëÊàòÈ´òÂàÜ</p>          
                </div>          
                <div class="mode-card" data-mode="sprint">          
                  <h4>‚ö° 40Ë°åÁ´ûÈÄü</h4>          
                  <p>Ê∂àÈô§40Ë°åÔºåËÆ∞ÂΩïÊúÄÂø´Êó∂Èó¥ÔºåÁ´ûÊäÄÈ¶ñÈÄâ</p>          
                </div>          
                <div class="mode-card" data-mode="ultra">          
                  <h4>‚è±Ô∏è ÈôêÊó∂ÊâìÂàÜ</h4>          
                  <p>2ÂàÜÈíüÈôêÊó∂ÔºåËøΩÊ±ÇÊúÄÈ´òÂàÜÊï∞</p>          
                </div>          
                <div class="mode-card" data-mode="cheese">          
                  <h4>‚õèÔ∏è ÊåñÊéòÊ®°Âºè</h4>          
                  <p>Ê∏ÖÈô§È¢ÑÂ°´ÂÖÖÁöÑÂûÉÂúæË°å,ËÄÉÈ™åÊåñÊéòÊäÄÂ∑ß</p>          
                </div>          
                <div class="mode-card" data-mode="master">          
                  <h4>üëë Â§ßÂ∏àÊ®°Âºè</h4>          
                  <p>20GÈáçÂäõÔºåÊûÅÁü≠ÈîÅÂª∂ÔºåÁ°¨Ê†∏ÊåëÊàò</p>          
                </div>          
                <div class="mode-card" data-mode="practice">          
                  <h4>üìö ÁªÉ‰π†Ê®°Âºè</h4>          
                  <p>ÊîØÊåÅÊí§ÈîÄ/ÈáçÂÅöÔºåÈÄÇÂêàÁªÉ‰π†ÊäÄÂ∑ß</p>          
                </div>          
              </div>          
          
              <div id="cheeseSettings" style="display:none; margin-top:12px;">          
                <div class="row">          
                  <label>ÂûÉÂúæË°åÊï∞Èáè</label>          
                  <input id="cfgCheeseLines" type="number" min="5" max="18" value="10">          
                </div>          
              </div>          
          
              <div id="ultraSettings" style="display:none; margin-top:12px;">          
                <div class="row">          
                  <label>Êó∂Èó¥ÈôêÂà∂ÔºàÁßíÔºâ</label>          
                  <input id="cfgUltraTime" type="number" min="60" max="300" value="120">          
                </div>          
              </div>          
            </div>          
          
            <div class="tab-content" id="tabGeneral">          
              <div class="grid2">          
                <div class="row">          
                  <label>ÂàóÊï∞ÔºàÂÆΩÂ∫¶Ôºâ</label>          
                  <input id="cfgCols" type="number" min="6" max="20" step="1" value="10">          
                </div>          
                <div class="row">          
                  <label>Ë°åÊï∞ÔºàÈ´òÂ∫¶Ôºâ</label>          
                  <input id="cfgRows" type="number" min="12" max="40" step="1" value="20">          
                </div>          
                <div class="row">          
                  <label>È¢ÑËßàÊï∞Èáè</label>          
                  <input id="cfgPreview" type="number" min="1" max="6" step="1" value="5">          
                </div>          
                <div class="row">          
                  <label>Ëµ∑ÂßãÁ∫ßÂà´</label>          
                  <input id="cfgStartLevel" type="number" min="1" max="20" step="1" value="1">          
                </div>          
                <div class="row">          
                  <label>ÊòæÁ§∫Èò¥ÂΩ±ÔºàGhostÔºâ</label>          
                  <select id="cfgGhost"><option value="on">ÂºÄÂêØ</option><option value="off">ÂÖ≥Èó≠</option></select>          
                </div>          
                <div class="row">          
                  <label>ÈîÅÂª∂ËøüÔºàmsÔºâ</label>          
                  <input id="cfgLockDelay" type="number" min="200" max="2000" step="50" value="1500">          
                </div>          
                <div class="row">          
                  <label>DAS Âª∂ËøüÔºàmsÔºâ</label>          
                  <input id="cfgDAS" type="number" min="0" max="300" step="10" value="120">          
                </div>          
                <div class="row">          
                  <label>ARR ÈÄüÂ∫¶ÔºàmsÔºâ</label>          
                  <input id="cfgARR" type="number" min="0" max="100" step="5" value="20">          
                </div>          
                <div class="row">          
                  <label>ÊñπÂùóÈÖçËâ≤</label>          
                  <select id="cfgSkin">          
                    <option value="classic">ÁªèÂÖ∏</option>          
                    <option value="pastel">È©¨Âç°Èæô</option>          
                    <option value="neon">ÈúìËôπ</option>          
                  </select>          
                </div>          
                <div class="row">          
                  <label>ÈúáÂä®ÂèçÈ¶à</label>          
                  <select id="cfgVibration">          
                    <option value="on">ÂºÄÂêØ</option>          
                    <option value="off">ÂÖ≥Èó≠</option>          
                  </select>          
                </div>          
                <div class="row">          
                   <label>Èü≥ÊïàÈü≥Èáè</label>          
                   <input type="range" class="volume-slider" id="cfgSFXVolume" min="0" max="100" value="50">          
                </div>          
                <div class="row">          
                  <label>ËÉåÊôØÈü≥‰πê</label>          
                  <input type="range" class="volume-slider" id="cfgMusicVolume" min="0" max="100" value="30">          
                </div>          
              </div>          
            </div>          
          
            <div class="tab-content" id="tabControls">          
              <div style="margin-bottom: 12px;">          
                <button id="btnResetKeys" class="danger" style="width: 100%;">ÊÅ¢Â§çÈªòËÆ§ÈîÆ‰Ωç</button>          
              </div>          
              <div class="keybind-grid" id="keybindGrid"></div>          
              <div class="legend" style="margin-top: 12px;">          
                <strong>ÊèêÁ§∫Ôºö</strong>ÁÇπÂáªÊåâÈíÆÂêéÊåâ‰∏ãÊÉ≥Ë¶ÅÁªëÂÆöÁöÑÈîÆ„ÄÇÊîØÊåÅÈîÆÁõòÂíåÊâãÊüÑÊåâÈíÆ„ÄÇ          
              </div>          
            </div>          
          
            <div class="actions">          
              <button id="btnCloseSettings">ÂèñÊ∂à</button>          
              <button id="btnSaveStart" class="primary">‰øùÂ≠òÂπ∂ÂºÄÂßã</button>          
            </div>          
          </div>          
        </div>          
          
          
      <div class="mobile-controls" id="mobileControls">          
        <div class="btn" data-act="left">‚Üê Â∑¶</div>          
        <div class="btn" data-act="right">Âè≥ ‚Üí</div>          
        <div class="btn" data-act="rotateLeft">‚Ü∫ Â∑¶Êóã</div>          
        <div class="btn" data-act="rotateRight">‚Üª Âè≥Êóã</div>          
        <div class="btn" data-act="soft">‚Üì ËΩØÈôç</div>          
        <div class="btn" data-act="hard">‚§ì Á°¨Èôç</div>          
        <div class="btn" data-act="hold">Hold</div>          
        <div class="btn" data-act="pause">‚è∏ ÊöÇÂÅú</div>          
      </div>          
    </div>          
          
    <div class="panel right">            
      <div class="preview-title">‰∏ã‰∏Ä‰∏™ÊñπÂùóÈ¢ÑËßà</div>            
      <div class="previews" id="previews"></div>            
    </div>            
  </div>          
          
  <!-- ÂÄíËÆ°Êó∂ÈÅÆÁΩ© -->          
<div class="countdown-overlay" id="countdownOverlay">          
  <div class="countdown-content">          
    <div class="countdown-number" id="countdownNumber">3</div>          
  </div>          
</div>          
          
<!-- ÊöÇÂÅúËèúÂçïÈÅÆÁΩ© -->          
<div class="pause-overlay" id="pauseOverlay">          
  <div class="pause-modal">          
    <h2>‚è∏ Ê∏∏ÊàèÊöÇÂÅú</h2>          
    <p>‰ºëÊÅØ‰∏Ä‰∏ãÔºåÂáÜÂ§áÂ•ΩÂÜçÁªßÁª≠ÔºÅ</p>          
    <div class="pause-stats">          
      <div class="pause-stat">          
        <div class="pause-stat-value" id="pauseScore">0</div>          
        <div class="pause-stat-label">ÂàÜÊï∞</div>          
      </div>          
      <div class="pause-stat">          
        <div class="pause-stat-value" id="pauseLines">0</div>          
        <div class="pause-stat-label">Ë°åÊï∞</div>          
      </div>          
      <div class="pause-stat">          
        <div class="pause-stat-value" id="pauseLevel">1</div>          
        <div class="pause-stat-label">Á≠âÁ∫ß</div>          
      </div>          
    </div>          
    <div class="actions">          
      <button id="btnPauseResume" class="primary">‚ñ∂ ÁªßÁª≠Ê∏∏Êàè</button>          
      <button id="btnPauseRestart">üîÑ ÈáçÊñ∞ÂºÄÂßã</button>          
      <button id="btnPauseSettings">‚öô ËÆæÁΩÆ</button>          
    </div>          
  </div>          
</div>          
          
<!-- Á≠âÁ∫ßÊèêÂçáÂä®ÁîªÈÅÆÁΩ© -->          
<div class="levelup-overlay" id="levelupOverlay">          
  <div class="levelup-content">          
    <div class="levelup-text">LEVEL UP!</div>          
    <div class="levelup-level" id="levelupLevel">2</div>          
  </div>          
</div>          
          
<!-- Ê∏∏ÊàèÁªìÊùüÁªüËÆ°È°µ -->          
<div class="gameover-overlay" id="gameoverOverlay">          
  <div class="gameover-modal" id="gameoverModal">          
    <h2 id="gameoverTitle">üéÆ Ê∏∏ÊàèÁªìÊùü</h2>          
    <p class="subtitle" id="gameoverSubtitle">ÂÜçÊé•ÂÜçÂéâÔºÅ</p>          
              
    <div id="gameoverRank" class="gameover-rank" style="display:none;">          
      üèÜ ÊéíË°åÊ¶úÁ¨¨ <span id="gameoverRankNum">1</span> ÂêçÔºÅ          
    </div>          
              
    <div class="gameover-stats-grid">          
      <div class="gameover-stat-card highlight">          
        <div class="gameover-stat-value" id="goScore">0</div>          
        <div class="gameover-stat-label">ÊúÄÁªàÂæóÂàÜ</div>          
      </div>          
      <div class="gameover-stat-card">          
        <div class="gameover-stat-value" id="goLines">0</div>          
        <div class="gameover-stat-label">Ê∂àÈô§Ë°åÊï∞</div>          
      </div>          
      <div class="gameover-stat-card">          
        <div class="gameover-stat-value" id="goLevel">1</div>          
        <div class="gameover-stat-label">ËææÂà∞Á≠âÁ∫ß</div>          
      </div>          
      <div class="gameover-stat-card">          
        <div class="gameover-stat-value" id="goTime">00:00</div>          
        <div class="gameover-stat-label">Ê∏∏ÊàèÊó∂Èïø</div>          
      </div>          
      <div class="gameover-stat-card">          
        <div class="gameover-stat-value" id="goTetrises">0</div>          
        <div class="gameover-stat-label">TetrisÊ¨°Êï∞</div>          
      </div>          
      <div class="gameover-stat-card">          
        <div class="gameover-stat-value" id="goMaxCombo">0</div>          
        <div class="gameover-stat-label">ÊúÄÈ´òËøûÂáª</div>          
      </div>          
    </div>          
              
    <div class="gameover-actions">          
      <button id="btnGameoverRestart" class="primary">üîÑ ÈáçÊñ∞ÂºÄÂßã</button>          
      <button id="btnGameoverLeaderboard">üèÜ Êü•ÁúãÊéíË°åÊ¶ú</button>          
      <button id="btnGameoverSettings">‚öô ËøîÂõûËÆæÁΩÆ</button>          
    </div>          
  </div>          
</div>          
          
<!-- ÊåâÈîÆÂèçÈ¶àÊåáÁ§∫Âô® -->          
<div class="key-feedback" id="keyFeedback">          
  <div class="key-indicator left" data-key="left">‚Üê</div>          
  <div class="key-indicator right" data-key="right">‚Üí</div>          
  <div class="key-indicator rotate" data-key="rotate">‚Üª</div>          
  <div class="key-indicator drop" data-key="soft">‚Üì</div>          
  <div class="key-indicator hard" data-key="hard">‚§ì</div>          
  <div class="key-indicator hold" data-key="hold">H</div>          
</div>          
          
  <!-- ÊéíË°åÊ¶úÊ®°ÊÄÅÊ°Ü -->          
<div class="leaderboard-overlay" id="leaderboardOverlay">          
  <div class="leaderboard-modal">          
    <h3>üèÜ Êú¨Âú∞ÊéíË°åÊ¶ú</h3>          
              
    <div class="stats-panel" id="globalStats">          
      <div class="stats-card">          
        <div class="stats-card-value" id="statTotalGames">0</div>          
        <div class="stats-card-label">ÊÄªÊ∏∏ÊàèÊ¨°Êï∞</div>          
      </div>          
      <div class="stats-card">          
        <div class="stats-card-value" id="statTotalLines">0</div>          
        <div class="stats-card-label">ÊÄªÊ∂àÈô§Ë°åÊï∞</div>          
      </div>          
      <div class="stats-card">          
        <div class="stats-card-value" id="statTotalScore">0</div>          
        <div class="stats-card-label">Á¥ØËÆ°ÊÄªÂàÜ</div>          
      </div>          
      <div class="stats-card">          
        <div class="stats-card-value" id="statPlayTime">0h</div>          
        <div class="stats-card-label">Ê∏∏ÊàèÊó∂Èïø</div>          
      </div>          
      <div class="stats-card">          
        <div class="stats-card-value" id="statTetrises">0</div>          
        <div class="stats-card-label">TetrisÊ¨°Êï∞</div>          
      </div>          
      <div class="stats-card">          
        <div class="stats-card-value" id="statTSpins">0</div>          
        <div class="stats-card-label">T-SpinÊ¨°Êï∞</div>          
      </div>          
    </div>          
              
    <div class="leaderboard-tabs" id="leaderboardTabs">          
      <button class="leaderboard-tab active" data-mode="marathon">È©¨ÊãâÊùæ</button>          
      <button class="leaderboard-tab" data-mode="sprint">40Ë°åÁ´ûÈÄü</button>          
      <button class="leaderboard-tab" data-mode="ultra">ÈôêÊó∂ÊâìÂàÜ</button>          
      <button class="leaderboard-tab" data-mode="cheese">ÊåñÊéòÊ®°Âºè</button>          
      <button class="leaderboard-tab" data-mode="master">Â§ßÂ∏àÊ®°Âºè</button>          
    </div>          
              
    <div class="leaderboard-list">          
      <div class="leaderboard-header">          
        <div>ÊéíÂêç</div>          
        <div>Áé©ÂÆ∂</div>          
        <div id="scoreHeader">ÂàÜÊï∞</div>          
        <div>Êó•Êúü</div>          
      </div>          
      <div id="leaderboardContent">          
        <div class="leaderboard-empty">ÊöÇÊó†ËÆ∞ÂΩïÔºåÂø´Êù•ÂàõÈÄ†ÂéÜÂè≤ÔºÅ</div>          
      </div>          
    </div>          
              
    <div class="leaderboard-actions">          
      <button id="btnClearLeaderboard" class="danger">Ê∏ÖÁ©∫ÊéíË°åÊ¶ú</button>          
      <button id="btnCloseLeaderboard" class="primary">ÂÖ≥Èó≠</button>          
    </div>          
  </div>          
</div>          
          
          
  <footer>          
    <div>‰∏ì‰∏öÁ´ûÊäÄÁâàÔºöÂ§öÊ®°Âºè | Ëá™ÂÆö‰πâÈîÆ‰Ωç | ÊâãÊüÑÊîØÊåÅ | ÈúáÂä®ÂèçÈ¶à</div>          
  </footer>          
</div>      
      
<script>        
(()=>{        
        
// ========== Êï∞ÊçÆÊåÅ‰πÖÂåñÁ≥ªÁªü ==========        
class StorageManager {        
  constructor() {        
    this.STORAGE_KEYS = {        
      SETTINGS: 'tetris_settings',        
      STATISTICS: 'tetris_statistics',        
      KEYBINDINGS: 'tetris_keybindings',        
      LEADERBOARD: 'tetris_leaderboard',        
      GAME_PROGRESS: 'tetris_progress'        
    };        
  }        
        
  save(key, data) {        
    try {        
      localStorage.setItem(key, JSON.stringify(data));        
      return true;        
    } catch (e) {        
      console.warn('‰øùÂ≠òÊï∞ÊçÆÂ§±Ë¥•:', e);        
      return false;        
    }        
  }        
        
  load(key, defaultValue = null) {        
    try {        
      const data = localStorage.getItem(key);        
      return data ? JSON.parse(data) : defaultValue;        
    } catch (e) {        
      console.warn('ËØªÂèñÊï∞ÊçÆÂ§±Ë¥•:', e);        
      return defaultValue;        
    }        
  }        
        
  remove(key) {        
    try {        
      localStorage.removeItem(key);        
      return true;        
    } catch (e) {        
      return false;        
    }        
  }        
        
  // Áî®Êà∑ËÆæÁΩÆ        
  saveSettings(settings) {        
    return this.save(this.STORAGE_KEYS.SETTINGS, settings);        
  }        
        
  loadSettings() {        
    return this.load(this.STORAGE_KEYS.SETTINGS, {        
      cols: 10,        
      rows: 20,        
      previewCount: 5,        
      startLevel: 1,        
      ghostEnabled: true,        
      lockDelay: 1500,        
      das: 120,        
      arr: 20,        
      skin: 'classic',        
      vibration: true,        
      sfxVolume: 50,        
      musicVolume: 30,        
      gameMode: 'marathon',        
      cheeseLines: 10,        
      ultraTime: 120        
    });        
  }        
        
  // Ê∏∏ÊàèÁªüËÆ°        
  saveStatistics(stats) {        
    return this.save(this.STORAGE_KEYS.STATISTICS, stats);        
  }        
        
  loadStatistics() {        
    return this.load(this.STORAGE_KEYS.STATISTICS, {        
      totalGames: 0,        
      totalLines: 0,        
      totalScore: 0,        
      totalPlayTime: 0,        
      highestCombo: 0,        
      mostLinesInGame: 0,        
      tetrises: 0,        
      tSpins: 0,        
      perfectClears: 0        
    });        
  }        
        
  updateStatistics(gameData) {        
    const stats = this.loadStatistics();        
    stats.totalGames++;        
    stats.totalLines += gameData.lines || 0;        
    stats.totalScore += gameData.score || 0;        
    stats.totalPlayTime += gameData.playTime || 0;        
    stats.highestCombo = Math.max(stats.highestCombo, gameData.maxCombo || 0);        
    stats.mostLinesInGame = Math.max(stats.mostLinesInGame, gameData.lines || 0);        
    stats.tetrises += gameData.tetrises || 0;        
    stats.tSpins += gameData.tSpins || 0;        
    stats.perfectClears += gameData.perfectClears || 0;        
    this.saveStatistics(stats);        
    return stats;        
  }        
        
  // ÈîÆ‰ΩçÁªëÂÆö        
  saveKeybindings(bindings) {        
    return this.save(this.STORAGE_KEYS.KEYBINDINGS, bindings);        
  }        
        
  loadKeybindings() {        
    return this.load(this.STORAGE_KEYS.KEYBINDINGS, null);        
  }        
        
  // ÊéíË°åÊ¶ú        
  saveLeaderboard(leaderboard) {        
    return this.save(this.STORAGE_KEYS.LEADERBOARD, leaderboard);        
  }        
        
  loadLeaderboard() {        
    return this.load(this.STORAGE_KEYS.LEADERBOARD, {        
      marathon: [],        
      sprint: [],        
      ultra: [],        
      cheese: [],        
      master: []        
    });        
  }        
        
  addToLeaderboard(mode, entry) {        
    const leaderboard = this.loadLeaderboard();        
    if (!leaderboard[mode]) {        
      leaderboard[mode] = [];        
    }        
            
    entry.date = new Date().toISOString();        
    entry.id = Date.now();        
    leaderboard[mode].push(entry);        
            
    if (mode === 'sprint' || mode === 'cheese') {        
      leaderboard[mode].sort((a, b) => (a.time || Infinity) - (b.time || Infinity));        
    } else {        
      leaderboard[mode].sort((a, b) => (b.score || 0) - (a.score || 0));        
    }        
            
    leaderboard[mode] = leaderboard[mode].slice(0, 20);        
    this.saveLeaderboard(leaderboard);        
            
    const rank = leaderboard[mode].findIndex(e => e.id === entry.id) + 1;        
    return rank;        
  }        
        
  clearLeaderboard(mode = null) {        
    if (mode) {        
      const leaderboard = this.loadLeaderboard();        
      leaderboard[mode] = [];        
      this.saveLeaderboard(leaderboard);        
    } else {        
      this.saveLeaderboard({        
        marathon: [],        
        sprint: [],        
        ultra: [],        
        cheese: [],        
        master: []        
      });        
    }        
  }        
        
  // Ê∏∏ÊàèËøõÂ∫¶ÔºàÊú™ÂÆåÊàêÁöÑÊ∏∏ÊàèÔºâ        
  saveGameProgress(progress) {        
    return this.save(this.STORAGE_KEYS.GAME_PROGRESS, progress);        
  }        
        
  loadGameProgress() {        
    return this.load(this.STORAGE_KEYS.GAME_PROGRESS, null);        
  }        
        
  clearGameProgress() {        
    return this.remove(this.STORAGE_KEYS.GAME_PROGRESS);        
  }        
        
  hasGameProgress() {        
    return this.loadGameProgress() !== null;        
  }        
}        
        
// ÂÖ®Â±ÄÂ≠òÂÇ®ÁÆ°ÁêÜÂô®ÂÆû‰æã        
let storageManager = null;        
        
// Ê∏∏Êàè‰ºöËØùÁªüËÆ°ÔºàÁî®‰∫éÁªüËÆ°ÂΩìÂ±ÄÊ∏∏ÊàèÊï∞ÊçÆÔºâ        
let sessionStats = {        
  tetrises: 0,        
  tSpins: 0,        
  perfectClears: 0,        
  maxCombo: 0,        
  startTime: 0        
};        
        
// ========== ÂÄíËÆ°Êó∂Á≥ªÁªü ==========        
let isCountingDown = false;        
        
function showCountdown(callback) {        
  isCountingDown = true;        
  countdownOverlay.classList.add('visible');        
          
  const sequence = ['3', '2', '1', 'GO!'];        
  let index = 0;        
          
  function showNext() {        
    if (index >= sequence.length) {        
      countdownOverlay.classList.remove('visible');        
      isCountingDown = false;        
      if (callback) callback();        
      return;        
    }        
            
    const text = sequence[index];        
    countdownNumber.textContent = text;        
    countdownNumber.className = 'countdown-number' + (text === 'GO!' ? ' go' : '');        
            
    // Êí≠ÊîæÈü≥Êïà        
    if (audioSystem) {        
      if (text === 'GO!') {        
        audioSystem.playSound('countdownGo');        
      } else {        
        audioSystem.playSound('countdown');        
      }        
    }        
            
    // ÈúáÂä®ÂèçÈ¶à        
    vibrate(text === 'GO!' ? 30 : 15);        
            
    index++;        
    setTimeout(showNext, text === 'GO!' ? 600 : 800);        
  }        
          
  showNext();        
}        
        
function showPauseMenu() {        
  pauseScore.textContent = score.toLocaleString();        
  pauseLines.textContent = lines;        
  pauseLevel.textContent = level;        
  pauseOverlay.classList.add('visible');        
}        
        
function hidePauseMenu() {        
  pauseOverlay.classList.remove('visible');        
}        
        
// ========== Á≠âÁ∫ßÊèêÂçáÂä®Áîª ==========        
function showLevelUpAnimation(newLevel) {        
  levelupLevel.textContent = newLevel;        
  levelupOverlay.classList.add('visible');        
          
  // ÂàõÂª∫È¢ùÂ§ñÁöÑÁ≤íÂ≠êÊïàÊûú        
  for (let i = 0; i < 30; i++) {        
    setTimeout(() => {        
      const x = Math.random() * cvs.width;        
      const y = Math.random() * cvs.height;        
      const colors = ['#ffd700', '#4f8cff', '#10b981', '#a855f7'];        
      particles.push(new Particle(x, y, colors[Math.floor(Math.random() * colors.length)], 'spark'));        
    }, i * 30);        
  }        
          
  setTimeout(() => {        
    levelupOverlay.classList.remove('visible');        
  }, 1500);        
}        
        
// ========== Ê∏∏ÊàèÁªìÊùüÁªüËÆ°È°µ ==========        
function showGameOverStats(message, isVictory, rank) {        
  const playTime = Date.now() - sessionStats.startTime;        
          
  // ËÆæÁΩÆÊ†áÈ¢òÂíåÊ†∑Âºè        
  if (isVictory) {        
    gameoverTitle.textContent = 'üéâ ' + (message || 'ÊÅ≠ÂñúÂÆåÊàêÔºÅ');        
    gameoverModal.classList.add('victory');        
    gameoverSubtitle.textContent = 'Â§™Ê£í‰∫ÜÔºÅ‰Ω†ÂÅöÂà∞‰∫ÜÔºÅ';        
  } else {        
    gameoverTitle.textContent = 'üéâ ' + (message || 'Ê∏∏ÊàèÁªìÊùü');        
    gameoverModal.classList.remove('victory');        
    gameoverSubtitle.textContent = 'ÂÜçÊé•ÂÜçÂéâÔºÅ';        
  }        
          
  // Â°´ÂÖÖÁªüËÆ°Êï∞ÊçÆ        
  goScore.textContent = score.toLocaleString();        
  goLines.textContent = lines;        
  goLevel.textContent = level;        
  goTime.textContent = formatTime(playTime).split('.')[0]; // ‰∏çÊòæÁ§∫ÊØ´Áßí        
  goTetrises.textContent = sessionStats.tetrises;        
  goMaxCombo.textContent = sessionStats.maxCombo;        
          
  // ÊòæÁ§∫ÊéíÂêçÔºàÂ¶ÇÊûúËøõÂÖ•ÊéíË°åÊ¶úÔºâ        
  if (rank && rank <= 10) {        
    gameoverRank.style.display = 'block';        
    gameoverRankNum.textContent = rank;        
    if (rank <= 3) {        
      gameoverRank.classList.add('new-record');        
    } else {        
      gameoverRank.classList.remove('new-record');        
    }        
  } else {        
    gameoverRank.style.display = 'none';        
  }        
          
  gameoverOverlay.classList.add('visible');        
}        
        
function hideGameOverStats() {        
  gameoverOverlay.classList.remove('visible');        
}        
        
// ========== ÊåâÈîÆÂèçÈ¶àÁ≥ªÁªü ==========        
const keyIndicatorMap = {        
  'moveLeft': 'left',        
  'moveRight': 'right',        
  'rotateRight': 'rotate',        
  'rotateLeft': 'rotate',        
  'softDrop': 'soft',        
  'hardDrop': 'hard',        
  'hold': 'hold'        
};        
        
function highlightKey(action) {        
  const indicatorKey = keyIndicatorMap[action];        
  if (!indicatorKey) return;        
          
  const indicator = keyFeedback.querySelector(`[data-key="${indicatorKey}"]`);        
  if (indicator) {        
    indicator.classList.add('active');        
    setTimeout(() => {        
      indicator.classList.remove('active');        
    }, 150);        
  }        
}        
        
// ========== Á´ñÂ±èÊ£ÄÊµãÁ≥ªÁªü ==========        
let wasPortraitPaused = false; // ËÆ∞ÂΩïÊòØÂê¶Âõ†Á´ñÂ±èËÄåÊöÇÂÅú        
        
function checkOrientation() {        
  const portraitWarning = document.getElementById('portraitWarning');        
  if (!portraitWarning) return;        
          
  const isMobile = window.innerWidth <= 980;        
  const isPortrait = window.innerHeight > window.innerWidth;        
          
  if (isMobile && isPortrait) {        
    // ËøõÂÖ•Á´ñÂ±èÊ®°Âºè        
    portraitWarning.classList.add('show');        
    portraitWarning.classList.add('active');        
            
    // Â¶ÇÊûúÊ∏∏ÊàèÊ≠£Âú®ËøêË°å‰∏îÊú™ÊöÇÂÅúÔºåËá™Âä®ÊöÇÂÅú        
    if (running && !paused && !gameOver) {        
      togglePause();        
      wasPortraitPaused = true;        
    }        
  } else {        
    // ÈÄÄÂá∫Á´ñÂ±èÊ®°ÂºèÔºàÊ®™Â±èÊàñÈùûÁßªÂä®Á´ØÔºâ        
    const wasShowing = portraitWarning.classList.contains('show');        
    portraitWarning.classList.remove('show');        
    portraitWarning.classList.remove('active');        
            
    // Â¶ÇÊûúÊòØ‰ªéÁ´ñÂ±èÂàáÊç¢Âà∞Ê®™Â±èÔºå‰∏î‰πãÂâçÂõ†Á´ñÂ±èËÄåÊöÇÂÅúÔºåËá™Âä®ÊÅ¢Â§ç        
    if (wasShowing && wasPortraitPaused && running && paused && !gameOver) {        
      togglePause();        
      wasPortraitPaused = false;        
    }        
  }        
}        
        
function initOrientationDetection() {        
  // ÁõëÂê¨Â±èÂπïÊñπÂêëÂèòÂåñ        
  window.addEventListener('orientationchange', () => {        
    setTimeout(checkOrientation, 100); // Âª∂Ëøü‰ª•Á°Æ‰øùËé∑ÂèñÊ≠£Á°ÆÁöÑÂ∞∫ÂØ∏        
  });        
          
  // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñ        
  window.addEventListener('resize', checkOrientation);        
          
  // È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñÊó∂‰πüÊ£ÄÊµã        
  document.addEventListener('visibilitychange', () => {        
    if (!document.hidden) {        
      setTimeout(checkOrientation, 100);        
    }        
  });        
          
  // ÂàùÂßãÊ£ÄÊµã        
  setTimeout(checkOrientation, 100);        
}        
        
// ========== Èü≥È¢ëÁ≥ªÁªü ==========        
class AudioSystem {        
  constructor() {        
    this.enabled = true;        
    this.musicVolume = 0.3;        
    this.sfxVolume = 0.5;        
    this.sounds = {};        
    this.currentBGM = null;        
    this.initSounds();        
  }        
        
  initSounds() {        
    // ‰ΩøÁî® Web Audio API ÁîüÊàêÈü≥Êïà        
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();        
            
    // Áî±‰∫éÊó†Ê≥ï‰ΩøÁî®Â§ñÈÉ®Èü≥È¢ëÊñá‰ª∂ÔºåÊàë‰ª¨‰ΩøÁî®Á®ãÂ∫èÁîüÊàêÈü≥Êïà        
    this.generateSounds();        
  }        
        
  generateSounds() {        
    // ËøôÈáåÊàë‰ª¨ÂàõÂª∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑÈü≥ÊïàÁîüÊàêÁ≥ªÁªü        
    this.soundConfigs = {        
      move: { freq: 200, duration: 0.05, type: 'square' },        
      rotate: { freq: 400, duration: 0.08, type: 'sine' },        
      softDrop: { freq: 150, duration: 0.03, type: 'triangle' },        
      hardDrop: { freq: 100, duration: 0.15, type: 'sawtooth', envelope: 'punch' },        
      lock: { freq: 300, duration: 0.1, type: 'square' },        
      lineClear1: { freq: 440, duration: 0.2, type: 'sine' },        
      lineClear2: { freq: 554, duration: 0.25, type: 'sine' },        
      lineClear3: { freq: 659, duration: 0.3, type: 'sine' },        
      lineClear4: { freq: 880, duration: 0.4, type: 'sine', envelope: 'swell' },        
      tetris: {        
        freq: [523, 659, 784, 1046],        
        duration: 0.6,        
        type: 'sine',        
        envelope: 'arpeggio'        
      },        
      hold: { freq: 350, duration: 0.12, type: 'triangle' },        
      levelUp: {        
        freq: [440, 554, 659, 880],        
        duration: 0.5,        
        type: 'sine',        
        envelope: 'ascending'        
      },        
      gameOver: {        
        freq: [440, 392, 349, 330],        
        duration: 1.0,        
        type: 'sawtooth',        
        envelope: 'descending'        
      },        
      countdown: { freq: 440, duration: 0.15, type: 'sine' },        
      countdownGo: {        
        freq: [523, 659, 784],        
        duration: 0.4,        
        type: 'sine',        
        envelope: 'ascending'        
      },        
      combo: { freq: 600, duration: 0.15, type: 'sine', envelope: 'bounce' }        
    };        
  }        
        
  playSound(soundName, volumeMultiplier = 1.0) {        
    if (!this.enabled || !this.audioContext) return;        
            
    const config = this.soundConfigs[soundName];        
    if (!config) return;        
        
    try {        
      const now = this.audioContext.currentTime;        
      const oscillator = this.audioContext.createOscillator();        
      const gainNode = this.audioContext.createGain();        
              
      oscillator.connect(gainNode);        
      gainNode.connect(this.audioContext.destination);        
              
      oscillator.type = config.type;        
              
      const volume = this.sfxVolume * volumeMultiplier;        
              
      // Ê†πÊçÆ‰∏çÂêåÁöÑÂåÖÁªúÁ±ªÂûãËÆæÁΩÆÈü≥ÈáèÂèòÂåñ        
      if (config.envelope === 'punch') {        
        gainNode.gain.setValueAtTime(volume, now);        
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + config.duration);        
      } else if (config.envelope === 'swell') {        
        gainNode.gain.setValueAtTime(0.01, now);        
        gainNode.gain.exponentialRampToValueAtTime(volume, now + config.duration * 0.3);        
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + config.duration);        
      } else if (config.envelope === 'bounce') {        
        gainNode.gain.setValueAtTime(volume, now);        
        gainNode.gain.setValueAtTime(volume * 0.5, now + config.duration * 0.3);        
        gainNode.gain.setValueAtTime(volume, now + config.duration * 0.6);        
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + config.duration);        
      } else if (config.envelope === 'arpeggio' || config.envelope === 'ascending' || config.envelope === 'descending') {        
        // ÂíåÂº¶/Èü≥Èò∂ÊïàÊûú        
        const freqs = Array.isArray(config.freq) ? config.freq : [config.freq];        
        const noteTime = config.duration / freqs.length;        
                
        freqs.forEach((freq, i) => {        
          const osc = this.audioContext.createOscillator();        
          const gain = this.audioContext.createGain();        
                  
          osc.connect(gain);        
          gain.connect(this.audioContext.destination);        
                  
          osc.type = config.type;        
          osc.frequency.setValueAtTime(freq, now + i * noteTime);        
                  
          gain.gain.setValueAtTime(volume, now + i * noteTime);        
          gain.gain.exponentialRampToValueAtTime(0.01, now + (i + 1) * noteTime);        
                  
          osc.start(now + i * noteTime);        
          osc.stop(now + (i + 1) * noteTime);        
        });        
                
        return; // ÊèêÂâçËøîÂõûÔºåÈÅøÂÖç‰∏ãÈù¢ÁöÑ start/stop        
      } else {        
        // ÈªòËÆ§ÂåÖÁªú        
        gainNode.gain.setValueAtTime(volume, now);        
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + config.duration);        
      }        
              
      oscillator.frequency.setValueAtTime(config.freq, now);        
      oscillator.start(now);        
      oscillator.stop(now + config.duration);        
              
    } catch (e) {        
      console.warn('Èü≥ÊïàÊí≠ÊîæÂ§±Ë¥•:', e);        
    }        
  }        
        
  playLineClear(lineCount) {        
    if (lineCount === 4) {        
      this.playSound('tetris', 1.2);        
    } else if (lineCount === 3) {        
      this.playSound('lineClear3');        
    } else if (lineCount === 2) {        
      this.playSound('lineClear2');        
    } else if (lineCount === 1) {        
      this.playSound('lineClear1');        
    }        
  }        
        
  playComboSound(comboCount) {        
    const volumeMultiplier = Math.min(1.5, 1.0 + comboCount * 0.1);        
    this.playSound('combo', volumeMultiplier);        
  }        
        
  startBGM(level) {        
    if (!this.enabled || !this.audioContext) return;        
            
    // ÂÅúÊ≠¢ÂΩìÂâçBGM        
    this.stopBGM();        
            
    // ÂàõÂª∫ÁÆÄÂçïÁöÑËÉåÊôØÈü≥‰πêÂæ™ÁéØ        
    const tempo = Math.min(180, 120 + level * 5); // BPMÈöèlevelÂ¢ûÂä†        
    const beatDuration = 60 / tempo;        
            
    // ÁÆÄÂçïÁöÑËäÇÂ•èÂæ™ÁéØ        
    this.bgmInterval = setInterval(() => {        
      if (!this.enabled) return;        
              
      const now = this.audioContext.currentTime;        
      const osc = this.audioContext.createOscillator();        
      const gain = this.audioContext.createGain();        
              
      osc.connect(gain);        
      gain.connect(this.audioContext.destination);        
              
      // ÈöèÊú∫Èü≥Á¨¶Ëê•ÈÄ†Ê∞õÂõ¥        
      const notes = [261.63, 293.66, 329.63, 392, 440]; // C, D, E, G, A        
      const randomNote = notes[Math.floor(Math.random() * notes.length)];        
              
      osc.type = 'triangle';        
      osc.frequency.setValueAtTime(randomNote, now);        
              
      const volume = this.musicVolume * 0.1; // Âæà‰ΩéÁöÑÈü≥Èáè‰Ωú‰∏∫ËÉåÊôØ        
      gain.gain.setValueAtTime(volume, now);        
      gain.gain.exponentialRampToValueAtTime(0.01, now + beatDuration * 0.5);        
              
      osc.start(now);        
      osc.stop(now + beatDuration * 0.5);        
              
    }, beatDuration * 1000);        
  }        
        
  stopBGM() {        
    if (this.bgmInterval) {        
      clearInterval(this.bgmInterval);        
      this.bgmInterval = null;        
    }        
  }        
        
  toggle() {        
    this.enabled = !this.enabled;        
    if (!this.enabled) {        
      this.stopBGM();        
    }        
    return this.enabled;        
  }        
        
  setMusicVolume(vol) {        
    this.musicVolume = Math.max(0, Math.min(1, vol));        
  }        
        
  setSFXVolume(vol) {        
    this.sfxVolume = Math.max(0, Math.min(1, vol));        
  }        
}        
        
// ÂÖ®Â±ÄÈü≥È¢ëÁ≥ªÁªüÂÆû‰æã        
let audioSystem = null;        
        
// ========== Â±èÂπïÈúáÂä®Á≥ªÁªü ==========        
class ScreenShake {        
  constructor(element) {        
    this.element = element;        
    this.shaking = false;        
  }        
        
  shake(intensity = 1, duration = 500) {        
    if (this.shaking) return;        
            
    this.shaking = true;        
    this.element.classList.add('shake');        
            
    // Ê†πÊçÆÂº∫Â∫¶Ë∞ÉÊï¥CSSÂèòÈáèÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ        
    this.element.style.setProperty('--shake-intensity', intensity);        
            
    setTimeout(() => {        
      this.element.classList.remove('shake');        
      this.shaking = false;        
    }, duration);        
  }        
        
  smallShake() {        
    this.shake(0.5, 200);        
  }        
        
  mediumShake() {        
    this.shake(1.0, 400);        
  }        
        
  bigShake() {        
    this.shake(1.5, 600);        
  }        
}        
        
let screenShaker = null;        
        
// ========== Âä®ÊÄÅËÉåÊôØÁ≤íÂ≠êÁ≥ªÁªü ==========        
class BackgroundParticles {        
  constructor(container) {        
    this.container = container;        
    this.particles = [];        
    this.maxParticles = 15;        
    this.colors = ['#4f8cff', '#3563e9', '#5b9fff', '#6ba5ff'];        
    this.init();        
  }        
        
  init() {        
    // ÂàõÂª∫Á≤íÂ≠êÂÆπÂô®        
    this.particleContainer = document.createElement('div');        
    this.particleContainer.className = 'background-particles';        
    this.container.insertBefore(this.particleContainer, this.container.firstChild);        
            
    // ÂàùÂßãÁîüÊàê‰∏Ä‰∫õÁ≤íÂ≠ê        
    for (let i = 0; i < this.maxParticles; i++) {        
      setTimeout(() => this.createParticle(), i * 300);        
    }        
  }        
        
  createParticle() {        
    const particle = document.createElement('div');        
    particle.className = 'bg-particle';        
            
    const size = 20 + Math.random() * 60;        
    const startX = Math.random() * 100;        
    const duration = 8 + Math.random() * 10;        
    const delay = Math.random() * 5;        
    const color = this.colors[Math.floor(Math.random() * this.colors.length)];        
            
    particle.style.width = size + 'px';        
    particle.style.height = size + 'px';        
    particle.style.left = startX + '%';        
    particle.style.bottom = '-' + size + 'px';        
    particle.style.background = `radial-gradient(circle, ${color}40, transparent)`;        
    particle.style.animationDuration = duration + 's';        
    particle.style.animationDelay = delay + 's';        
            
    this.particleContainer.appendChild(particle);        
            
    // Âä®ÁîªÁªìÊùüÂêéÁßªÈô§Âπ∂ÂàõÂª∫Êñ∞Á≤íÂ≠ê        
    particle.addEventListener('animationend', () => {        
      particle.remove();        
      this.createParticle();        
    });        
  }        
        
  updateLevel(level) {        
  // Ê†πÊçÆÁ∫ßÂà´ÊîπÂèòÁ≤íÂ≠êÈ¢úËâ≤        
  const levelColors = {        
    1: ['#4f8cff', '#3563e9', '#5b9fff', '#6ba5ff'],   // ËìùËâ≤Á≥ª        
    5: ['#10b981', '#34d399', '#6ee7b7', '#a7f3d0'],   // ÁªøËâ≤Á≥ª        
    10: ['#f59e0b', '#fbbf24', '#fcd34d', '#fde68a'],  // ÈªÑËâ≤/Ê©ôËâ≤Á≥ª        
    15: ['#ef4444', '#f87171', '#fca5a5', '#fecaca'],  // Á∫¢Ëâ≤Á≥ª        
    20: ['#a855f7', '#c084fc', '#d8b4fe', '#e9d5ff']   // Á¥´Ëâ≤Á≥ª        
  };        
          
  // ÊâæÂà∞ÊúÄÊé•ËøëÁöÑlevelÈÖçËâ≤        
  let targetLevel = 1;        
  for (const lvl in levelColors) {        
    if (level >= parseInt(lvl)) {        
      targetLevel = parseInt(lvl);        
    }        
  }        
          
  this.colors = levelColors[targetLevel];        
          
  // ÂêåÊó∂Êõ¥Êñ∞Â∑≤Â≠òÂú®Á≤íÂ≠êÁöÑÈ¢úËâ≤ÔºàÊ∏êÂèòÊïàÊûúÔºâ        
  const particleElements = this.particleContainer.querySelectorAll('.bg-particle');        
  particleElements.forEach(p => {        
    const newColor = this.colors[Math.floor(Math.random() * this.colors.length)];        
    p.style.background = `radial-gradient(circle, ${newColor}40, transparent)`;        
  });        
}        
        
  clear() {        
    this.particleContainer.innerHTML = '';        
  }        
}        
        
let bgParticles = null;        
        
  // ========== ÈÖçËâ≤‰∏ªÈ¢ò ==========        
const SKINS = {        
  classic: {        
    I:'#00f0f0', O:'#f0f000', T:'#a000f0', S:'#00f000', Z:'#f00000', J:'#0000f0', L:'#f0a000',        
    G:'#606060',        
    ghost:'rgba(122,162,255,0.45)',        
    texture: 'flat'        
  },        
  pastel: {        
    I:'#9be7ff', O:'#fff59b', T:'#d1b3ff', S:'#b2f7b2', Z:'#ffb3b3', J:'#b3c6ff', L:'#ffd1a6',        
    G:'#a0a0a0',        
    ghost:'rgba(147,197,253,0.45)',        
    texture: 'flat'        
  },        
  neon: {        
    I:'#22d3ee', O:'#facc15', T:'#a78bfa', S:'#34d399', Z:'#fb7185', J:'#60a5fa', L:'#f59e0b',        
    G:'#505050',        
    ghost:'rgba(56,189,248,0.5)',        
    texture: 'glow'        
  },        
  glossy: {        
    I:'#00d4e8', O:'#ffd700', T:'#b24bf3', S:'#00e676', Z:'#ff1744', J:'#2979ff', L:'#ff6d00',        
    G:'#707070',        
    ghost:'rgba(122,162,255,0.45)',        
    texture: 'glossy'        
  },        
  retro: {        
    I:'#00ffff', O:'#ffff00', T:'#ff00ff', S:'#00ff00', Z:'#ff0000', J:'#0000ff', L:'#ff7f00',        
    G:'#808080',        
    ghost:'rgba(255,255,255,0.3)',        
    texture: 'pixel'        
  },        
  minimal: {        
    I:'#e0e0e0', O:'#e0e0e0', T:'#e0e0e0', S:'#e0e0e0', Z:'#e0e0e0', J:'#e0e0e0', L:'#e0e0e0',        
    G:'#909090',        
    ghost:'rgba(200,200,200,0.4)',        
    texture: 'outline'        
  }        
};        
        
          
const SRS_STATES = {        
    I: {        
        0: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],        
        1: [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]],        
        2: [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]],        
        3: [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]]        
    },        
    O: {        
        0: [[1,1], [1,1]],        
        1: [[1,1], [1,1]],        
        2: [[1,1], [1,1]],        
        3: [[1,1], [1,1]]        
    },        
    T: {        
        0: [[0,1,0], [1,1,1], [0,0,0]],        
        1: [[0,1,0], [0,1,1], [0,1,0]],        
        2: [[0,0,0], [1,1,1], [0,1,0]],        
        3: [[0,1,0], [1,1,0], [0,1,0]]        
    },        
    S: {        
        0: [[0,1,1], [1,1,0], [0,0,0]],        
        1: [[0,1,0], [0,1,1], [0,0,1]],        
        2: [[0,0,0], [0,1,1], [1,1,0]],        
        3: [[1,0,0], [1,1,0], [0,1,0]]        
    },        
    Z: {        
        0: [[1,1,0], [0,1,1], [0,0,0]],        
        1: [[0,0,1], [0,1,1], [0,1,0]],        
        2: [[0,0,0], [1,1,0], [0,1,1]],        
        3: [[0,1,0], [1,1,0], [1,0,0]]        
    },        
    J: {        
        0: [[1,0,0], [1,1,1], [0,0,0]],        
        1: [[0,1,1], [0,1,0], [0,1,0]],        
        2: [[0,0,0], [1,1,1], [0,0,1]],        
        3: [[0,1,0], [0,1,0], [1,1,0]]        
    },        
    L: {        
        0: [[0,0,1], [1,1,1], [0,0,0]],        
        1: [[0,1,0], [0,1,0], [0,1,1]],        
        2: [[0,0,0], [1,1,1], [1,0,0]],        
        3: [[1,1,0], [0,1,0], [0,1,0]]        
    }        
};        
        
const SHAPES = {        
    I: SRS_STATES.I[0],        
    O: SRS_STATES.O[0],        
    T: SRS_STATES.T[0],        
    S: SRS_STATES.S[0],        
    Z: SRS_STATES.Z[0],        
    J: SRS_STATES.J[0],        
    L: SRS_STATES.L[0]        
};        
          
  const TYPES = ['I','O','T','L','J','S','Z'];        
        
  const SRS_KICKS_JLSTZ = {        
  '0->1': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],        
  '1->0': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],        
  '1->2': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],        
  '2->1': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],        
  '2->3': [[0,0],[1,0],[1,-1],[0,2],[1,2]],        
  '3->2': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],        
  '3->0': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],        
  '0->3': [[0,0],[1,0],[1,-1],[0,2],[1,2]]        
};        
        
  const SRS_KICKS_I = {        
    '0->1': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],        
    '1->0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],        
    '1->2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],        
    '2->1': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],        
    '2->3': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],        
    '3->2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],        
    '3->0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],        
    '0->3': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]]        
  };        
        
  // ========== DOM ÂÖÉÁ¥† ==========        
  const cvs = document.getElementById('playfield');        
  const ctx = cvs.getContext('2d');        
  const holdCanvas = document.getElementById('hold');        
  const holdCtx = holdCanvas.getContext('2d');        
  const previewsEl = document.getElementById('previews');        
  const comboNotif = document.getElementById('comboNotif');        
        
  const scoreEl = document.getElementById('score');        
  const levelEl = document.getElementById('level');        
  const linesEl = document.getElementById('lines');        
  const comboEl = document.getElementById('combo');        
  const comboInd = document.getElementById('comboInd');        
  const b2bInd = document.getElementById('b2bInd');        
  const scoreRow = document.getElementById('scoreRow');        
  const overlay = document.getElementById('overlay');        
  const modeDisplayEl = document.getElementById('modeDisplay');        
  const timerContainer = document.getElementById('timerContainer');        
  const timerDisplay = document.getElementById('timerDisplay');        
  const cheeseContainer = document.getElementById('cheeseContainer');        
  const cheeseRemaining = document.getElementById('cheeseRemaining');        
  const cheeseProgress = document.getElementById('cheeseProgress');        
  const gamepadIndicator = document.getElementById('gamepadIndicator');        
  const gamepadName = document.getElementById('gamepadName');        
        
  const topHeader = document.getElementById('topHeader');        
  const btnHeaderToggle = document.getElementById('btnHeaderToggle');        
        
  const btnPlayPause = document.getElementById('btnPlayPause');        
  const btnRestart = document.getElementById('btnRestart');        
  // ÂÄíËÆ°Êó∂Áõ∏ÂÖ≥        
const countdownOverlay = document.getElementById('countdownOverlay');        
const countdownNumber = document.getElementById('countdownNumber');        
        
// ÊöÇÂÅúËèúÂçïÁõ∏ÂÖ≥        
const pauseOverlay = document.getElementById('pauseOverlay');        
const pauseScore = document.getElementById('pauseScore');        
const pauseLines = document.getElementById('pauseLines');        
const pauseLevel = document.getElementById('pauseLevel');        
const btnPauseResume = document.getElementById('btnPauseResume');        
const btnPauseRestart = document.getElementById('btnPauseRestart');        
const btnPauseSettings = document.getElementById('btnPauseSettings');        
        
// Á≠âÁ∫ßÊèêÂçáÁõ∏ÂÖ≥        
const levelupOverlay = document.getElementById('levelupOverlay');        
const levelupLevel = document.getElementById('levelupLevel');        
        
// Ê∏∏ÊàèÁªìÊùüÁõ∏ÂÖ≥        
const gameoverOverlay = document.getElementById('gameoverOverlay');        
const gameoverModal = document.getElementById('gameoverModal');        
const gameoverTitle = document.getElementById('gameoverTitle');        
const gameoverSubtitle = document.getElementById('gameoverSubtitle');        
const gameoverRank = document.getElementById('gameoverRank');        
const gameoverRankNum = document.getElementById('gameoverRankNum');

// Ê∏∏ÊàèÁªìÊùüÁªüËÆ°Êï∞ÊçÆ
const GAME_CONSTANTS = {
  ANIMATION: {
    HOLD_SWAP_DURATION: 400,
    HOLD_ANIMATE_IN_DURATION: 500,
    SHAKE_DURATION: 300,
    CLEAR_ANIMATION_DURATION: 500,
    HARD_DROP_SPEED: 0.5
  },
  GAMEPLAY: {
    MAX_LOCK_RESETS: 15,
    MAX_PENDING_INPUTS: 5,
    INPUT_BUFFER_TIME: 200,
    SOFT_DROP_SPEED: 50,
    DEFAULT_DAS: 133,
    DEFAULT_ARR: 10,
    DEFAULT_LOCK_DELAY: 500
  },
  SCORING: {
    SOFT_DROP_POINTS: 1,
    HARD_DROP_POINTS_PER_ROW: 2,
    PERFECT_CLEAR_BONUS: 3000
  },
  VISUAL: {
    PARTICLE_POOL_SIZE: 500,
    MAX_PARTICLES: 200,
    LOCK_WARNING_THRESHOLD: 100
  }
};

const goScore = document.getElementById('goScore');        
const goLines = document.getElementById('goLines');        
const goLevel = document.getElementById('goLevel');        
const goTime = document.getElementById('goTime');        
const goTetrises = document.getElementById('goTetrises');        
const goMaxCombo = document.getElementById('goMaxCombo');        
const btnGameoverRestart = document.getElementById('btnGameoverRestart');        
const btnGameoverLeaderboard = document.getElementById('btnGameoverLeaderboard');        
const btnGameoverSettings = document.getElementById('btnGameoverSettings');        
        
// ÊåâÈîÆÂèçÈ¶à        
const keyFeedback = document.getElementById('keyFeedback');        
        
  const btnSettings = document.getElementById('btnSettings');        
  const btnCloseSettings = document.getElementById('btnCloseSettings');        
  const btnSaveStart = document.getElementById('btnSaveStart');        
  const btnUndo = document.getElementById('btnUndo');        
  const btnRedo = document.getElementById('btnRedo');        
  const undoControls = document.getElementById('undoControls');        
  const btnResetKeys = document.getElementById('btnResetKeys');        
        
  const cfgCols = document.getElementById('cfgCols');        
  const cfgRows = document.getElementById('cfgRows');        
  const cfgPreview = document.getElementById('cfgPreview');        
  const cfgStartLevel = document.getElementById('cfgStartLevel');        
  const cfgGhost = document.getElementById('cfgGhost');        
  const cfgLockDelay = document.getElementById('cfgLockDelay');        
  const cfgDAS = document.getElementById('cfgDAS');        
  const cfgARR = document.getElementById('cfgARR');        
  const cfgSkin = document.getElementById('cfgSkin');        
  const cfgVibration = document.getElementById('cfgVibration');        
  const cfgCheeseLines = document.getElementById('cfgCheeseLines');        
  const cfgUltraTime = document.getElementById('cfgUltraTime');        
        
  const mobileControlsEl = document.getElementById('mobileControls');        
  const mobileLeftEl = document.getElementById('mobileLeft');        
  const mobileRightEl = document.getElementById('mobileRight');        
  const keybindGrid = document.getElementById('keybindGrid');        
  // ÊéíË°åÊ¶úÁõ∏ÂÖ≥DOM        
const leaderboardOverlay = document.getElementById('leaderboardOverlay');        
const btnLeaderboard = document.getElementById('btnLeaderboard');        
const btnCloseLeaderboard = document.getElementById('btnCloseLeaderboard');        
const btnClearLeaderboard = document.getElementById('btnClearLeaderboard');        
const leaderboardTabs = document.getElementById('leaderboardTabs');        
const leaderboardContent = document.getElementById('leaderboardContent');        
const scoreHeader = document.getElementById('scoreHeader');        
        
// ÁªüËÆ°Èù¢ÊùøDOM        
const statTotalGames = document.getElementById('statTotalGames');        
const statTotalLines = document.getElementById('statTotalLines');        
const statTotalScore = document.getElementById('statTotalScore');        
const statPlayTime = document.getElementById('statPlayTime');        
const statTetrises = document.getElementById('statTetrises');        
const statTSpins = document.getElementById('statTSpins');        
        
// Èü≥ÈáèÊéßÂà∂        
const cfgSFXVolume = document.getElementById('cfgSFXVolume');        
const cfgMusicVolume = document.getElementById('cfgMusicVolume');        
        
  // ========== Ê∏∏ÊàèÁä∂ÊÄÅ ==========        
  let COLS = 10, ROWS = 20;        
  let BLOCK = 30;        
  let board = createMatrix(COLS, ROWS);        
  let running = false, paused = false, gameOver = false;        
  let skin = SKINS.classic;        
        
  let previewCount = 5;        
  let bag = [];        
  let queue = [];        
        
  let holdType = null;        
  let holdLocked = false;        
        
  let piece = null;        
          
  let score = 0, lines = 0, level = 1;        
  let startLevel = 1;        
        
  let combo = 0;        
  let b2bCount = 0;        
  let lastClearWasSpecial = false;        
        
  let lastActionWasRotate = false;        
  let tSpinType = null;        
        
  let lastKickIndex = 0;        
        
  let particles = [];        
        
  let hardDropping = false;        
  let hardDropStartY = 0;        
  let hardDropTargetY = 0;        
  let hardDropCurrentY = 0;        
  let hardDropSpeed = 3;        
        
  let clearingLines = false;        
  let clearAnimationTimer = 0;        
  const CLEAR_ANIMATION_DURATION = 800;        
        
  let gravity = 800;        
  const levelSpeed = lvl => Math.max(80, 900 - (lvl-1)*60);        
  let dropTimer = 0;        
  let lastTS = 0;        
        
  let lockDelay = 1500;        
  let lockTimer = 0;        
  let touchingGround = false;     
        
  let ghostEnabled = true;        
        
  let DAS = 120;        
  let ARR = 20;        
  let keyState = {};        
  let dasTimer = {};        
  let arrTimer = {};        
        
  let touchStartX=0, touchStartY=0, touchStartTime=0;        
        
  let pausedBeforeOverlay = false;        
  let vibrationEnabled = true;        
  // ÂΩìÂâçÊéíË°åÊ¶úÊ®°Âºè        
  let currentLeaderboardMode = 'marathon';        
        
        
  // ========== Ê∏∏ÊàèÊ®°Âºè ==========        
  let gameMode = 'marathon'; // marathon, sprint, ultra, cheese, master, practice        
  const MODE_NAMES = {        
    marathon: 'È©¨ÊãâÊùæ',        
    sprint: '40Ë°åÁ´ûÈÄü',        
    ultra: 'ÈôêÊó∂ÊâìÂàÜ',        
    cheese: 'ÊåñÊéòÊ®°Âºè',        
    master: 'Â§ßÂ∏àÊ®°Âºè',        
    practice: 'ÁªÉ‰π†Ê®°Âºè'        
  };        
        
  // ËÆ°Êó∂Âô®        
  let gameTimer = 0;        
  let timerRunning = false;        
  let ultraTimeLimit = 120;        
        
  // ÊåñÊéòÊ®°Âºè        
  let cheeseLines = 10;        
  let initialCheeseLines = 10;        
        
  // Êí§ÈîÄ/ÈáçÂÅöÁ≥ªÁªü        
  let historyStates = [];        
  let historyIndex = -1;        
  const MAX_HISTORY = 50;        
        
  // ========== ÈîÆ‰ΩçÁªëÂÆöÁ≥ªÁªü ==========        
  const DEFAULT_KEYBINDS = {        
    moveLeft: ['ArrowLeft'],        
    moveRight: ['ArrowRight'],        
    softDrop: ['ArrowDown'],        
    hardDrop: [' ', 'Space'],        
    rotateRight: ['ArrowUp', 'x', 'X'],        
    rotateLeft: ['z', 'Z', 'Control'],        
    hold: ['c', 'C', 'Shift'],        
    pause: ['p', 'P', 'Escape']        
  };        
        
  let keyBindings = JSON.parse(JSON.stringify(DEFAULT_KEYBINDS));        
  let listeningForKey = null;        
        
  // ÊâãÊüÑÁªëÂÆö        
  const GAMEPAD_BINDINGS = {        
    moveLeft: [14], // D-Pad Left        
    moveRight: [15], // D-Pad Right        
    softDrop: [13], // D-Pad Down        
    hardDrop: [0], // A/Cross        
    rotateRight: [2], // X/Square        
    rotateLeft: [1], // B/Circle        
    hold: [3, 4, 5], // Y/Triangle, LB, RB        
    pause: [9] // Start        
  };        
        
  let connectedGamepad = null;        
  let gamepadState = {};        
  let lastGamepadState = {};  
  
  let lockWarningTimer = 0;  
  const LOCK_WARNING_TIME = 300;  
  let showLockWarning = false;

  // ÈîÅÂÆöÁßªÂä®ÈáçÁΩÆËÆ°Êï∞Âô®
  let lockMoveResets = 0;
  const MAX_LOCK_RESETS = 15;
  let lowestY = 0;
        
  // ========== Á≤íÂ≠êÁ±ª ==========        
  class Particle {        
    constructor(x, y, color, type = 'normal') {        
      this.x = x;        
      this.y = y;        
      this.type = type;        
        
      if(type === 'spark') {        
        this.vx = (Math.random() - 0.5) * 12;        
        this.vy = Math.random() * 4 - 1;        
        this.life = 1.0;        
        this.decay = 0.03 + Math.random() * 0.02;        
        this.size = 2 + Math.random() * 3;        
        this.gravity = 0.15;        
      } else {        
        this.vx = (Math.random() - 0.5) * 10;        
        this.vy = (Math.random() - 0.5) * 10 - 3;        
        this.life = 1.0;        
        this.decay = 0.008 + Math.random() * 0.008;        
        this.size = 4 + Math.random() * 5;        
        this.gravity = 0.25;        
      }        
        
      this.color = color;        
      this.rotation = Math.random() * Math.PI * 2;        
      this.rotationSpeed = (Math.random() - 0.5) * 0.3;        
    }        
        
    update() {        
      this.x += this.vx;        
      this.y += this.vy;        
      this.vy += this.gravity;        
      this.vx *= 0.98;        
      this.life -= this.decay;        
      this.rotation += this.rotationSpeed;        
      return this.life > 0;        
    }        
        
    draw(ctx) {        
      ctx.save();        
      ctx.globalAlpha = this.life;        
      ctx.translate(this.x, this.y);        
      ctx.rotate(this.rotation);        
        
      if(this.type === 'spark') {        
        ctx.fillStyle = this.color;        
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);        
        
        ctx.globalAlpha = this.life * 0.3;        
        ctx.fillStyle = '#fff';        
        ctx.fillRect(-this.size/3, -this.size/3, this.size*0.66, this.size*0.66);        
      } else {        
        ctx.fillStyle = this.color;        
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);        
      }        
        
      ctx.restore();        
    }        
  }        
        
  // ========== Â∑•ÂÖ∑ÂáΩÊï∞ ==========        
  function createMatrix(w,h){        
    const m = [];        
    for(let y=0;y<h;y++){ m.push(new Array(w).fill(0)); }        
    return m;        
  }        
  function cloneMatrix(m){ return m.map(r=>r.slice()); }        
        
  function refillBag(){        
    const arr = TYPES.slice();        
    for(let i=arr.length-1;i>0;i--){        
      const j = Math.floor(Math.random()*(i+1));        
      [arr[i],arr[j]] = [arr[j],arr[i]];        
    }        
    bag = arr;        
  }        
        
  function takeFromQueue(){        
    while(queue.length < previewCount + 1){        
      if(!bag.length) refillBag();        
      queue.push(bag.pop());        
    }        
    return queue.shift();        
  }        
          
        
  function collide(b, p) {        
    // Ê£ÄÊü•ÊñπÂùóÊú¨Ë∫´ÁöÑËæπÁïå        
    for(let y = 0; y < p.m.length; y++) {        
        for(let x = 0; x < p.m[y].length; x++) {        
            if(!p.m[y][x]) continue;        
            const nx = p.x + x;        
            const ny = p.y + y;        
                    
            // ËæπÁïåÊ£ÄÊü•        
            if(nx < 0 || nx >= COLS || ny >= ROWS) {        
                return true; // Ë∂ÖÂá∫Ê∏∏ÊàèÂå∫Âüü        
            }        
                    
            // ÊùøÂùóÁ¢∞ÊíûÊ£ÄÊü•ÔºàÂè™Ê£ÄÊü•ÂèØËßÅÂå∫ÂüüÔºâ        
            if(ny >= 0 && b[ny][nx]) {        
                return true; // ‰∏éÁé∞ÊúâÊñπÂùóÁ¢∞Êíû        
            }        
        }        
    }        
    return false;        
}        
        
  function checkBoundaries(piece) {        
    // Á°Æ‰øùÊñπÂùó‰∏ç‰ºöË∂ÖÂá∫ËæπÁïå        
    if(piece.x < 0) piece.x = 0;        
    if(piece.x + piece.m[0].length > COLS) {        
        piece.x = COLS - piece.m[0].length;        
    }        
            
    // IÊñπÂùóÁâπÊÆäÂ§ÑÁêÜ        
    if(piece.type === 'I' && piece.y < -2) {        
        piece.y = -2;        
    }        
}        
        
  function isGrounded(p){        
    if(!p) return false;        
    const test = { ...p, y: p.y + 1 };        
    return collide(board, test);        
  }        
        
  function merge(b,p){        
    for(let y=0;y<p.m.length;y++){        
      for(let x=0;x<p.m[y].length;x++){        
        if(p.m[y][x]){        
          const nx = p.x + x;        
          const ny = p.y + y;        
          if(ny>=0 && ny<ROWS && nx>=0 && nx<COLS){        
            b[ny][nx] = p.type;        
          }        
        }        
      }        
    }        
  }        
        
  function checkTSpin(p, kickIndex) {        
  if(p.type !== 'T') return null;        
  if(!lastActionWasRotate) return null;        
        
  // TÊñπÂùó‰∏≠ÂøÉÂßãÁªàÂú®3x3Áü©ÈòµÁöÑ(1,1)‰ΩçÁΩÆ        
  const centerX = p.x + 1;        
  const centerY = p.y + 1;        
        
  // Ê†πÊçÆÊóãËΩ¨Áä∂ÊÄÅÁ°ÆÂÆö"ÂâçÊñπ"‰∏§‰∏™ËßíËêΩ        
  // Áä∂ÊÄÅ0: ‰∏äÊñπ‰∏§‰∏™ÊòØÂâçÊñπ (Â∑¶‰∏ä„ÄÅÂè≥‰∏ä)        
  // Áä∂ÊÄÅ1: Âè≥Êñπ‰∏§‰∏™ÊòØÂâçÊñπ (Âè≥‰∏ä„ÄÅÂè≥‰∏ã)        
  // Áä∂ÊÄÅ2: ‰∏ãÊñπ‰∏§‰∏™ÊòØÂâçÊñπ (Â∑¶‰∏ã„ÄÅÂè≥‰∏ã)        
  // Áä∂ÊÄÅ3: Â∑¶Êñπ‰∏§‰∏™ÊòØÂâçÊñπ (Â∑¶‰∏ä„ÄÅÂ∑¶‰∏ã)        
  const frontCorners = {        
    0: [{dx: -1, dy: -1}, {dx: 1, dy: -1}],        
    1: [{dx: 1, dy: -1}, {dx: 1, dy: 1}],        
    2: [{dx: -1, dy: 1}, {dx: 1, dy: 1}],        
    3: [{dx: -1, dy: -1}, {dx: -1, dy: 1}]        
  };        
        
  const allCorners = [        
    {dx: -1, dy: -1},        
    {dx: 1, dy: -1},        
    {dx: -1, dy: 1},        
    {dx: 1, dy: 1}        
  ];        
        
  function isCornerFilled(corner) {        
    const cx = centerX + corner.dx;        
    const cy = centerY + corner.dy;        
    if(cy < 0 || cy >= ROWS || cx < 0 || cx >= COLS) {        
      return true;        
    }        
    return !!board[cy][cx];        
  }        
        
  let filledCorners = 0;        
  for(const corner of allCorners) {        
    if(isCornerFilled(corner)) filledCorners++;        
  }        
        
  if(filledCorners < 3) return null;        
        
  // Ê£ÄÊü•ÂâçÊñπ‰∏§‰∏™ËßíËêΩÊòØÂê¶ÈÉΩË¢´Â°´ÂÖÖ        
  const front = frontCorners[p.rotation] || frontCorners[0];        
  const frontFilled = front.filter(c => isCornerFilled(c)).length;        
        
  // T-Spin MiniÊù°‰ª∂Ôºö        
  // 1. ‰ΩøÁî®‰∫ÜÁ¨¨4ÊàñÁ¨¨5‰∏™Ë∏¢Â¢ôÊµãËØïÔºàÁ¥¢Âºï3Êàñ4Ôºâ        
  // 2. ÊàñËÄÖÂâçÊñπ‰∏§‰∏™ËßíËêΩÂè™Êúâ‰∏Ä‰∏™Ë¢´Â°´ÂÖÖ        
  if(kickIndex >= 3 || frontFilled < 2) {        
    // Áâπ‰æãÔºöÂ¶ÇÊûúÊ∂àÈô§3Ë°åÔºåÂç≥‰ΩøÊòØminiÊù°‰ª∂‰πüÁÆó‰Ωúnormal T-Spin        
    return 'mini';        
  }        
        
  return 'normal';        
}        
        
  function clearLines(){        
    const fullRows = [];        
    for(let y=0; y<ROWS; y++){        
      const isFull = board[y].every(v => v !== 0);        
      if(isFull) fullRows.push(y);        
    }        
        
    const cleared = fullRows.length;            
        
    if(cleared > 0){        
      vibrate([10, 20, 30][Math.min(cleared-1, 2)] || 30);        
        
      for(const y of fullRows){        
        for(let x=0; x<COLS; x++){        
          const type = board[y][x];        
          if(!type) continue;        
          const color = skin[type];        
          const px = x * BLOCK + BLOCK / 2;        
          const py = y * BLOCK + BLOCK / 2;        
          const count = 15 + Math.floor(Math.random() * 6);        
          for(let i=0; i<count; i++){        
            particles.push(new Particle(px, py, color, 'normal'));        
          }        
        }        
      }        
        
      const isTetris = (cleared === 4);        
      const isTSpin = (tSpinType !== null && cleared > 0);        
      // Êõ¥Êñ∞‰ºöËØùÁªüËÆ°        
      if (isTetris) {        
        sessionStats.tetrises++;        
      }        
      if (isTSpin) {        
        sessionStats.tSpins++;        
      }        
      sessionStats.maxCombo = Math.max(sessionStats.maxCombo, combo + 1);        
        
      const isSpecial = isTetris || isTSpin;        
        
if(cleared > 0) {        
  audioSystem.playLineClear(cleared);        
  if(combo > 1) {        
    audioSystem.playComboSound(combo);        
  }        
  if(cleared === 4 || isTSpin) {        
    screenShaker.bigShake();        
  } else {        
    screenShaker.smallShake();        
  }        
}        
        
      let b2bMultiplier = 1.0;        
      if(isSpecial) {        
        if(lastClearWasSpecial) {        
          b2bCount++;        
          b2bMultiplier = 1.5;        
        } else {        
          b2bCount = 1;        
        }        
        lastClearWasSpecial = true;        
      } else {        
        lastClearWasSpecial = false;        
        b2bCount = 0;        
      }        
        
      let baseScore = 0;        
      if(isTSpin) {        
  // T-Spin Triple Âç≥‰ΩøÊª°Ë∂≥miniÊù°‰ª∂‰πüÁÆó‰Ωúnormal        
  let effectiveTSpinType = tSpinType;        
  if(tSpinType === 'mini' && cleared >= 3) {        
    effectiveTSpinType = 'normal';        
  }        
          
  const tSpinScores = {        
    'mini': [100, 200, 400],        
    'normal': [400, 800, 1200, 1600]        
  };        
  const scoreTable = tSpinScores[effectiveTSpinType] || tSpinScores['normal'];        
  baseScore = scoreTable[Math.min(cleared - 1, scoreTable.length - 1)] || 0;        
} else {        
        const normalScores = {1:100, 2:300, 3:500, 4:800};        
        baseScore = normalScores[cleared] || 0;        
      }        
        
      combo++;        
      const comboBonus = combo > 1 ? 50 * (combo - 1) : 0;        
        
      const totalScore = Math.floor((baseScore + comboBonus) * level * b2bMultiplier);        
      score += totalScore;        
        
      lines += cleared;        
              
      // Êõ¥Êñ∞ÊåñÊéòÊ®°ÂºèËøõÂ∫¶        
      if(gameMode === 'cheese') {        
        updateCheeseProgress();        
      }        
        
      updateLevelByLines();        
      updateStats();        
        
      showClearNotification(cleared, isTSpin, tSpinType, b2bMultiplier > 1);        
        
      const fullSet = new Set(fullRows);        
      const kept = [];        
      for(let y=0; y<ROWS; y++){        
        if(!fullSet.has(y)) kept.push(board[y]);        
      }        
      const empties = new Array(cleared).fill(0).map(()=> new Array(COLS).fill(0));        
      board = [...empties, ...kept];        
        
      const allClear = board.every(row => row.every(cell => cell === 0));        
        if(allClear) {        
            triggerAllClear();        
        }        
        
      clearingLines = true;
      clearAnimationTimer = 0;
      setTimeout(()=>{ 
        clearingLines = false; 
        processPendingInputs();
      }, CLEAR_ANIMATION_DURATION);

      checkModeCompletion();

      spawn();
    } else {
      combo = 0;
      updateStats();
      spawn();
    }

    tSpinType = null;
  }        
          
  function triggerAllClear() {        
    // All Clear Â•ñÂä±ÂàÜÊï∞        
    const allClearBonus = 10000 * level;        
    score += allClearBonus;        
            
    // ÁâπÊïàÂíåÈü≥Êïà        
    audioSystem.playSound('tetris', 1.5); // Êí≠ÊîæÈü≥Êïà        
    screenShaker.bigShake();        
            
    // ÊòæÁ§∫ All Clear ÈÄöÁü•        
    showAllClearNotification();        
            
    // È¢ùÂ§ñÁöÑÁ≤íÂ≠êÊïàÊûú        
    createAllClearEffect();        
}        
        
function showAllClearNotification() {        
    comboNotif.textContent = 'ALL CLEAR!';        
    comboNotif.className = 'combo-notification combo-tspin show';        
            
    // È¢ùÂ§ñÁöÑËßÜËßâÊïàÊûú        
    const canvas = document.getElementById('playfield');        
    canvas.style.filter = 'brightness(1.5)';        
    setTimeout(() => {        
        canvas.style.filter = '';        
    }, 500);        
            
    setTimeout(() => {        
        comboNotif.classList.remove('show');        
    }, 2000);        
}        
        
function createAllClearEffect() {        
    for(let x = 0; x < COLS; x++) {        
        for(let y = 0; y < ROWS; y++) {        
            if(Math.random() < 0.3) {        
                const colors = ['#FFD700', '#FF69B4', '#00CED1', '#FF6347'];        
                const color = colors[Math.floor(Math.random() * colors.length)];        
                const px = x * BLOCK + BLOCK / 2;        
                const py = y * BLOCK + BLOCK / 2;        
                particles.push(new Particle(px, py, color, 'spark'));        
            }        
        }        
    }        
}        
        
  function showClearNotification(count, isTSpin, tSpinVariant, isB2B) {        
    let message = '';        
    let cssClass = 'combo-notification';        
        
    if(isTSpin) {        
  const lineNames = ['', 'Single', 'Double', 'Triple'];        
  const lineName = lineNames[count] || count + 'Ë°å';        
          
  if(tSpinVariant === 'mini') {        
    message = `T-Spin Mini ${lineName}!`;        
  } else {        
    message = `T-Spin ${lineName}!`;        
  }        
  cssClass += ' combo-tspin';        
} else if(count === 4) {        
      message = 'TETRIS!';        
      cssClass += ' combo-4';        
    } else if(count === 3) {        
      message = 'TRIPLE!';        
      cssClass += ' combo-3';        
    } else if(count === 2) {        
      message = 'DOUBLE!';        
      cssClass += ' combo-2';        
    } else if(count === 1) {        
      message = 'SINGLE';        
      cssClass += ' combo-1';        
    }        
        
    if(isB2B && (isTSpin || count === 4)) {        
      message = 'B2B ' + message;        
      cssClass += ' combo-b2b';        
    }        
        
    if(combo > 1) {        
      message += ` (Combo x${combo})`;        
    }        
        
    comboNotif.textContent = message;        
    comboNotif.className = cssClass + ' show';        
        
    setTimeout(() => {        
      comboNotif.classList.remove('show');        
    }, 1200);        
  }        
          
  function rotate(dir = +1) {
  if(!piece || hardDropping || gameOverAnimating) return false;
          
  if(piece.type === 'O') {
    return false;
  }
  
  if(!SRS_STATES[piece.type]) {
    console.warn(`Êú™ÊâæÂà∞ÊñπÂùóÁ±ªÂûã ${piece.type} ÁöÑSRSÁä∂ÊÄÅÂÆö‰πâ`);
    return false;
  }
          
  const oldRotation = piece.rotation;
  const newRotation = (oldRotation + (dir > 0 ? 1 : 3)) % 4;
          
  const rotated = SRS_STATES[piece.type][newRotation];
  if(!rotated) {
    console.warn(`Êú™ÊâæÂà∞ÊñπÂùó ${piece.type} ÁöÑÊóãËΩ¨Áä∂ÊÄÅ ${newRotation}`);
    return false;
  }
          
  const rotatedMatrix = rotated.map(row => [...row]);
          
  const kickKey = `${oldRotation}->${newRotation}`;
  let kicks = [];
          
  if(piece.type === 'I') {
    kicks = SRS_KICKS_I[kickKey] || [[0,0]];
  } else {
    kicks = SRS_KICKS_JLSTZ[kickKey] || [[0,0]];
  }
          
  for(let kickIdx = 0; kickIdx < kicks.length; kickIdx++) {
    const kick = kicks[kickIdx];
    if(!kick || kick.length < 2) continue;
    
    const [dx, dy] = kick;
    const test = {
      ...piece,
      x: piece.x + dx,
      y: piece.y + dy,
      m: rotatedMatrix,
      rotation: newRotation
    };
              
    if(!collide(board, test)) {
      piece.x = test.x;
      piece.y = test.y;
      piece.m = rotatedMatrix;
      piece.rotation = newRotation;
      lastActionWasRotate = true;
      lastKickIndex = kickIdx;
                  
      audioSystem.playSound('rotate');
          
      if(isGrounded(piece)) {
        maybeResetLockTimer();
      }
                  
      if(piece.type === 'T') {
        tSpinType = checkTSpin(piece, kickIdx);
      }
                  
      vibrate(5);
      return true;
    }
  }
          
  lastActionWasRotate = false;
  return false;
}        
          
function spawn() {
  piece = newPiece(takeFromQueue());
  holdLocked = false;
  lockTimer = 0;
  touchingGround = false;
  lastActionWasRotate = false;
  tSpinType = null;
  lastKickIndex = 0;
  lockMoveResets = 0;
  lowestY = -999;
      
  if(piece) {
    if(piece.type === 'I') {
      let hasCollision = false;
      for(let y = 0; y < piece.m.length; y++) {
        for(let x = 0; x < piece.m[y].length; x++) {
          if(!piece.m[y][x]) continue;
          const ny = piece.y + y;
          const nx = piece.x + x;
          if(ny >= 0 && ny < ROWS && board[ny][nx]) {
            hasCollision = true;
            break;
          }
        }
        if(hasCollision) break;
      }
              
      if(hasCollision) {
        endGame();
      }
    } else {
      if(collide(board, piece)) {
        piece.y--;
        if(collide(board, piece)) {
          endGame();
        }
      }
    }
    
    lowestY = piece.y;
  }
      
  redrawSidePanels();
}        
          
function newPiece(type) {        
    // ‰ΩøÁî® SRS_STATES ÁöÑÂàùÂßãÁä∂ÊÄÅÔºàrotation 0Ôºâ        
    const mat = SRS_STATES[type][0].map(row => [...row]); // Ê∑±Êã∑Ë¥ù        
            
    const p = {        
        type,        
        m: mat,        
        x: Math.floor(COLS/2) - Math.ceil(mat[0].length/2),        
        y: 0, // ÈªòËÆ§‰ªéÈ°∂ÈÉ®ÂºÄÂßã        
        color: skin[type],        
        animX: 0,        
        animY: 0,        
        rotation: 0        
    };        
            
    // IÊñπÂùóÁâπÊÆäÂ§ÑÁêÜÔºöÈúÄË¶Å‰ªéÊõ¥È´ò‰ΩçÁΩÆÂºÄÂßã‰ª•ÈÅøÂÖçÂàùÂßãÁ¢∞Êíû        
    if(type === 'I') {        
        p.y = -2; // IÊñπÂùó‰ªé-2Ë°åÂºÄÂßã        
    }        
            
    // Á°Æ‰øùÊñπÂùóÂú®Ê∞¥Âπ≥ÊñπÂêë‰∏çË∂ÖÂá∫ËæπÁïå        
    if(p.x < 0) {        
        p.x = 0;        
    }        
    if(p.x + mat[0].length > COLS) {        
        p.x = COLS - mat[0].length;        
    }        
            
    p.animX = p.x;        
    p.animY = p.y;        
            
    return p;        
}        
        
  function updateLevelByLines(){        
  if(gameMode === 'sprint' || gameMode === 'ultra' || gameMode === 'cheese' || gameMode === 'practice') return;        
          
  const computed = startLevel + Math.floor(lines / 10);        
  const newLevel = Math.min(20, Math.max(1, computed));        
  if(newLevel !== level){        
    const oldLevel = level;        
    level = newLevel;        
    if(gameMode !== 'master') {        
      gravity = levelSpeed(level);        
    }        
            
    // ÂçáÁ∫ßÊïàÊûú        
    audioSystem.playSound('levelUp');        
    cvs.classList.add('level-up');        
    setTimeout(() => cvs.classList.remove('level-up'), 600);        
            
    // ÊòæÁ§∫Á≠âÁ∫ßÊèêÂçáÂÖ®Â±èÂä®Áîª        
    showLevelUpAnimation(level);        
            
    // Êõ¥Êñ∞ËÉåÊôØÁ≤íÂ≠êÈ¢úËâ≤        
    if(bgParticles) {        
      bgParticles.updateLevel(level);        
    }        
  }        
}

function tryMove(dx, dy) {
  if(!piece) return false;
  
  const testPiece = {
    ...piece,
    x: piece.x + dx,
    y: piece.y + dy
  };
  
  return !collide(board, testPiece);
}

function getPieceBounds(p) {
  let minX = p.m[0].length, maxX = -1;
  let minY = p.m.length, maxY = -1;
  
  for(let y = 0; y < p.m.length; y++) {
    for(let x = 0; x < p.m[y].length; x++) {
      if(p.m[y][x]) {
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
    }
  }
  
  return {
    left: p.x + minX,
    right: p.x + maxX,
    top: p.y + minY,
    bottom: p.y + maxY,
    width: maxX - minX + 1,
    height: maxY - minY + 1
  };
}
        
  function move(dx){
  if(!piece || hardDropping || gameOverAnimating) return false;
  piece.x += dx;
  if(collide(board, piece)){
    piece.x -= dx;
    return false;
  }
  lastActionWasRotate = false;
  tSpinType = null;
  maybeResetLockTimer();
  audioSystem.playSound('move');
  return true;
}        
        
        
  let softDropActive = false;
let softDropTimer = 0;
const SOFT_DROP_SPEED = 50;

function softDropStep(){
  if(!piece || hardDropping) return false;
  piece.y += 1;
  if(collide(board, piece)){
    piece.y -= 1;
    return false;
  }else{
    lastActionWasRotate = false;
    tSpinType = null;
    score += 1;
    updateStats();
              
    audioSystem.playSound('softDrop');
              
    return true;
  }
}

function startSoftDrop() {
  if(!piece || hardDropping) return;
  softDropActive = true;
  softDropTimer = 0;
  softDropStep();
}

function stopSoftDrop() {
  softDropActive = false;
  softDropTimer = 0;
}

function updateSoftDrop(dt) {
  if(!softDropActive || !piece || hardDropping) return;
  
  softDropTimer += dt;
  while(softDropTimer >= SOFT_DROP_SPEED) {
    softDropTimer -= SOFT_DROP_SPEED;
    if(!softDropStep()) break;
  }
}       
        
        
  function hardDrop(){
  if(!piece || hardDropping || gameOverAnimating) return;

  const gy = ghostY();
  const dist = Math.max(0, gy - piece.y);

  if(dist === 0) {
    lockPiece();
    return;
  }

  hardDropping = true;
  hardDropStartY = piece.y;
  hardDropTargetY = gy;
  hardDropCurrentY = piece.y;

  score += dist * 2;
  updateStats();
  lastActionWasRotate = false;
          
  audioSystem.playSound('hardDrop');
  screenShaker.mediumShake();
          
  vibrate(15);
}        
        
  function updateHardDrop() {        
    if(!hardDropping) return;        
        
    hardDropCurrentY = Math.min(hardDropTargetY, hardDropCurrentY + hardDropSpeed);        
        
    const pieceScreenY = hardDropCurrentY * BLOCK;        
        
    for(let py = 0; py < piece.m.length; py++) {        
      for(let px = 0; px < piece.m[py].length; px++) {        
        if(!piece.m[py][px]) continue;        
        
        const nx = piece.x + px;        
        if(Math.random() < 0.3) {        
          const sparkX = nx * BLOCK + (Math.random() < 0.5 ? 2 : BLOCK - 2);        
          const sparkY = pieceScreenY + py * BLOCK + BLOCK / 2;        
        
          const sparkColors = ['#ffaa00', '#ff6600', '#ffdd00', '#fff'];        
          const sparkColor = sparkColors[Math.floor(Math.random() * sparkColors.length)];        
        
          particles.push(new Particle(sparkX, sparkY, sparkColor, 'spark'));        
        }        
      }        
    }        
        
    piece.y = Math.floor(hardDropCurrentY);        
        
    if(hardDropCurrentY >= hardDropTargetY) {        
      piece.y = hardDropTargetY;        
      hardDropping = false;        
        
      for(let py = 0; py < piece.m.length; py++) {        
        for(let px = 0; px < piece.m[py].length; px++) {        
          if(!piece.m[py][px]) continue;        
          const nx = piece.x + px;        
          const ny = piece.y + py;        
        
          const particleX = nx * BLOCK + BLOCK / 2;        
          const particleY = (ny + 1) * BLOCK;        
        
          for(let i = 0; i < 5; i++) {        
            particles.push(new Particle(particleX, particleY, '#fff', 'spark'));        
          }        
        }        
      }        
        
      vibrate(20);        
      lockPiece();        
    }        
  }        
        
  function lockPiece(){
  audioSystem.playSound('lock');
  merge(board, piece);
  piece = null;
  clearLines();
  lockTimer = 0;
  lockWarningTimer = 0;
  showLockWarning = false;
  touchingGround = false;
  if(gameMode === 'practice') {
    saveHistory();
  }
}        
        
        
  function maybeResetLockTimer(){
  if(!isGrounded(piece)) return;
  
  if(piece.y > lowestY) {
    lowestY = piece.y;
    lockMoveResets = 0;
  }
  
  if(lockMoveResets < MAX_LOCK_RESETS) {
    lockTimer = 0;
    lockWarningTimer = 0;
    showLockWarning = false;
    lockMoveResets++;
  }
}       
        
  function ghostY(){        
    let gy = piece.y;        
    while(true){        
      gy++;        
      const test = { ...piece, y: gy };        
      if(collide(board, test)) return gy - 1;        
    }        
  }        
        
  function lerp(a,b,t){ return a + (b - a) * t; }        
        
  function draw(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  ctx.fillStyle = '#0b0f23';
  ctx.fillRect(0,0,cvs.width,cvs.height);
  ctx.strokeStyle = '#1b2248';
  ctx.lineWidth = 1;
  
  for(let x=0;x<=COLS;x++){
    const px = Math.floor(x*BLOCK)+.5;
    ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,ROWS*BLOCK); ctx.stroke();
  }
  for(let y=0;y<=ROWS;y++){
    const py = Math.floor(y*BLOCK)+.5;
    ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(COLS*BLOCK,py); ctx.stroke();
  }

  if(showLockWarning && piece && !hardDropping) {
    const progress = Math.min(1, lockTimer / lockDelay);
    const barHeight = 6;
    const barY = ROWS * BLOCK - barHeight - 2;
    
    ctx.fillStyle = 'rgba(30, 40, 80, 0.8)';
    ctx.fillRect(2, barY, COLS * BLOCK - 4, barHeight);
    
    let warningColor;
    if(progress < 0.5) {
      warningColor = '#10b981';
    } else if(progress < 0.8) {
      warningColor = '#f59e0b';
    } else {
      warningColor = '#ef4444';
    }
    
    const gradient = ctx.createLinearGradient(2, barY, 2 + (COLS * BLOCK - 4) * (1 - progress), barY);
    gradient.addColorStop(0, warningColor);
    gradient.addColorStop(1, warningColor + '80');
    ctx.fillStyle = gradient;
    ctx.fillRect(2, barY, (COLS * BLOCK - 4) * (1 - progress), barHeight);
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(2, barY, COLS * BLOCK - 4, barHeight);
  }

  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const t = board[y][x];
      if(!t) continue;
      drawCell(x,y, skin[t]);
    }
  }

  if(ghostEnabled && piece && !hardDropping){
    const gy = ghostY();
    drawPiece({ ...piece, x: piece.animX, y: gy }, skin.ghost || 'rgba(122,162,255,0.45)', true);
  }

  if(piece){
    if(hardDropping) {
      const animPiece = { ...piece, y: hardDropCurrentY, x: piece.x };
      drawPiece(animPiece, piece.color, false, 0.9);
    } else {
      let alpha = 1;
      if(showLockWarning) {
        const pulseSpeed = 8;
        const pulsePhase = (Date.now() / 1000) * pulseSpeed;
        alpha = 0.5 + Math.sin(pulsePhase) * 0.3;
      }
      drawPiece({ ...piece, x: piece.animX, y: piece.animY }, piece.color, false, alpha);
      
      if(showLockWarning) {
        drawPieceOutline({ ...piece, x: piece.animX, y: piece.animY });
      }
    }
  }

  for(let i = particles.length - 1; i >= 0; i--) {
    if(!particles[i].update()) {
      particles.splice(i, 1);
    } else {
      particles[i].draw(ctx);
    }
  }
}  
  
function drawPieceOutline(p) {
  const gap = varGap();
  const phase = (Date.now() / 100) % 1;
  const glowIntensity = Math.sin(phase * Math.PI * 2) * 0.5 + 0.5;
  
  const progress = Math.min(1, lockTimer / lockDelay);
  let outlineColor;
  if(progress < 0.5) {
    outlineColor = `rgba(16, 185, 129, ${0.6 + glowIntensity * 0.4})`;
  } else if(progress < 0.8) {
    outlineColor = `rgba(245, 158, 11, ${0.6 + glowIntensity * 0.4})`;
  } else {
    outlineColor = `rgba(239, 68, 68, ${0.7 + glowIntensity * 0.3})`;
  }
  
  ctx.strokeStyle = outlineColor;
  ctx.lineWidth = 3;
  ctx.shadowBlur = 15 * glowIntensity;
  ctx.shadowColor = outlineColor;
  
  for(let y=0;y<p.m.length;y++){
    for(let x=0;x<p.m[y].length;x++){
      if(!p.m[y][x]) continue;
      const nx = p.x + x;
      const ny = p.y + y;
      if(ny<0) continue;
      
      const px = nx * BLOCK + gap;
      const py = ny * BLOCK + gap;
      const size = BLOCK - 2 * gap;
      
      ctx.strokeRect(px + 1.5, py + 1.5, size - 3, size - 3);
    }
  }
  
  ctx.shadowBlur = 0;
}  
        
  function varGap(){ return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap')) || 1; }        
        
function drawCell(x, y, color, alpha = 1) {        
  const px = x * BLOCK;        
  const py = y * BLOCK;        
  const gap = varGap();        
  const size = BLOCK - 2 * gap;        
          
  ctx.globalAlpha = alpha;        
          
  const texture = skin.texture || 'flat';        
          
  switch(texture) {        
    case 'glossy':        
      // ÊûúÂÜªË¥®ÊÑü - Â∏¶È´òÂÖâÂíåÂ∫ïÈÉ®Èò¥ÂΩ±        
      ctx.fillStyle = color;        
      ctx.fillRect(px + gap, py + gap, size, size);        
              
      // È´òÂÖâ        
      const glossGradient = ctx.createLinearGradient(px + gap, py + gap, px + gap, py + size * 0.4);        
      glossGradient.addColorStop(0, 'rgba(255,255,255,0.6)');        
      glossGradient.addColorStop(1, 'rgba(255,255,255,0)');        
      ctx.fillStyle = glossGradient;        
      ctx.fillRect(px + gap, py + gap, size, size * 0.4);        
              
      // Â∫ïÈÉ®Èò¥ÂΩ±        
      const shadowGradient = ctx.createLinearGradient(px + gap, py + size * 0.6, px + gap, py + size);        
      shadowGradient.addColorStop(0, 'rgba(0,0,0,0)');        
      shadowGradient.addColorStop(1, 'rgba(0,0,0,0.4)');        
      ctx.fillStyle = shadowGradient;        
      ctx.fillRect(px + gap, py + size * 0.6, size, size * 0.4);        
              
      // ËæπÊ°ÜÈ´òÂÖâ        
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';        
      ctx.lineWidth = 1;        
      ctx.strokeRect(px + gap + 0.5, py + gap + 0.5, size - 1, size - 1);        
      break;        
              
    case 'glow':        
      // ÈúìËôπÂèëÂÖâÊïàÊûú        
      ctx.shadowBlur = 15 * alpha;        
      ctx.shadowColor = color;        
      ctx.fillStyle = color;        
      ctx.fillRect(px + gap, py + gap, size, size);        
      ctx.shadowBlur = 0;        
              
      // ÂÜÖÈÉ®Êõ¥‰∫ÆÁöÑÊ†∏ÂøÉ        
      const glowGradient = ctx.createRadialGradient(        
        px + BLOCK/2, py + BLOCK/2, 0,        
        px + BLOCK/2, py + BLOCK/2, size/2        
      );        
      glowGradient.addColorStop(0, 'rgba(255,255,255,0.6)');        
      glowGradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');        
      glowGradient.addColorStop(1, 'rgba(255,255,255,0)');        
      ctx.fillStyle = glowGradient;        
      ctx.fillRect(px + gap, py + gap, size, size);        
      break;        
              
    case 'pixel':        
      // Â§çÂè§ÂÉèÁ¥†È£é - Â∏¶ÂÉèÁ¥†ÂåñËæπÊ°Ü        
      ctx.fillStyle = color;        
      ctx.fillRect(px + gap, py + gap, size, size);        
              
      // ÂÉèÁ¥†ÂåñÈ´òÂÖâÔºàÂ∑¶‰∏äËßíÔºâ        
      ctx.fillStyle = 'rgba(255,255,255,0.5)';        
      ctx.fillRect(px + gap, py + gap, size, 2);        
      ctx.fillRect(px + gap, py + gap, 2, size);        
              
      // ÂÉèÁ¥†ÂåñÈò¥ÂΩ±ÔºàÂè≥‰∏ãËßíÔºâ        
      ctx.fillStyle = 'rgba(0,0,0,0.5)';        
      ctx.fillRect(px + gap, py + gap + size - 2, size, 2);        
      ctx.fillRect(px + gap + size - 2, py + gap, 2, size);        
      break;        
              
    case 'outline':        
      // ÊûÅÁÆÄÁ∫øÊ°ÜÈ£éÊ†º        
      ctx.strokeStyle = color;        
      ctx.lineWidth = 2;        
      ctx.strokeRect(px + gap + 1, py + gap + 1, size - 2, size - 2);        
              
      // ÂçäÈÄèÊòéÂ°´ÂÖÖ        
      ctx.fillStyle = color + '20'; // 20ÊòØÂçÅÂÖ≠ËøõÂà∂ÁöÑÈÄèÊòéÂ∫¶        
      ctx.fillRect(px + gap + 2, py + gap + 2, size - 4, size - 4);        
      break;        
              
    case 'flat':        
    default:        
      // ÂéüÊúâÁöÑÂπ≥Èù¢È£éÊ†º        
      ctx.fillStyle = color;        
      ctx.fillRect(px + gap, py + gap, size, size);        
              
      // È°∂ÈÉ®È´òÂÖâ        
      ctx.globalAlpha = alpha * 0.4;        
      ctx.fillStyle = 'rgba(255,255,255,0.10)';        
      ctx.fillRect(px + gap, py + gap, size, 4);        
              
      // Â∫ïÈÉ®Èò¥ÂΩ±        
      ctx.globalAlpha = alpha * 0.35;        
      ctx.fillStyle = 'rgba(0,0,0,0.25)';        
      ctx.fillRect(px + gap, py + size - 4, size, 4);        
      break;        
  }        
          
  ctx.globalAlpha = 1;        
}        
        
  function drawPiece(p, color, isGhost=false, alpha=1){        
    for(let y=0;y<p.m.length;y++){        
      for(let x=0;x<p.m[y].length;x++){        
        if(!p.m[y][x]) continue;        
        const nx = p.x + x;        
        const ny = p.y + y;        
        if(ny<0) continue;        
        drawCell(nx, ny, color, alpha);        
      }        
    }        
  }        
        
  function redrawSidePanels(){        
    const items = previewsEl.querySelectorAll('canvas');        
    items.forEach((cv, idx) => {        
      const type = queue[idx];        
      const c = cv.getContext('2d');        
      c.clearRect(0,0,cv.width,cv.height);        
      if(!type) return;        
      drawMini(c, type);        
    });        
            
    holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height);        
    if(holdType){ drawMini(holdCtx, holdType); }        
  }        
        
  function drawMini(c, type){        
    const mat = SHAPES[type];        
    const w = mat[0].length, h = mat.length;        
        
    const margin = Math.floor(Math.min(c.canvas.width, c.canvas.height) * 0.1);        
    const areaW = c.canvas.width - margin*2;        
    const areaH = c.canvas.height - margin*2;        
        
    const cell = Math.max(2, Math.floor(Math.min(areaW / w, areaH / h)));        
    const shapeW = w*cell, shapeH = h*cell;        
    const ox = Math.floor((c.canvas.width - shapeW)/2);        
    const oy = Math.floor((c.canvas.height - shapeH)/2);        
        
    for(let y=0;y<h;y++){        
      for(let x=0;x<w;x++){        
        if(!mat[y][x]) continue;        
        c.fillStyle = skin[type];        
        c.fillRect(ox + x*cell + 1, oy + y*cell + 1, cell-2, cell-2);        
      }        
    }        
  }        
        
  function loop(ts){
  if(!running || paused) return;
  if(!lastTS) lastTS = ts;
  const dt = ts - lastTS;
  lastTS = ts;

  updateTimer(dt);

  if(gameMode === 'ultra' && gameTimer >= ultraTimeLimit * 1000) {
    endGame('Êó∂Èó¥Âà∞ÔºÅ');
    return;
  }

  if(hardDropping) {
    updateHardDrop();
  }

  if(clearingLines) {
    clearAnimationTimer += dt;
  }

  updateSoftDrop(dt);
  updateDASARR(dt);
  pollGamepad();

  if(gameMode === 'master') {
    if(piece && !hardDropping && !isGrounded(piece)) {
      while(!isGrounded(piece)) {
        piece.y++;
        if(collide(board, piece)) {
          piece.y--;
          break;
        }
      }
    }
  } else {
    dropTimer += dt;
    while(dropTimer >= gravity){
      dropTimer -= gravity;
      if(piece && !hardDropping) {
        piece.y += 1;
        if(collide(board, piece)){
          piece.y -= 1;
          dropTimer = 0;
          break;
        }
      } else {
        break;
      }
    }
  }

  if(piece && !hardDropping){
    const grounded = isGrounded(piece);
    const frac = grounded ? 0 : Math.min(0.999, dropTimer / gravity);
    const targetY = piece.y + frac;
    piece.animX = lerp(piece.animX, piece.x, 0.35);
    if(piece.animY > targetY){
      piece.animY = targetY;
    }else{
      piece.animY = lerp(piece.animY, targetY, 0.35);
    }
    if(grounded){
      dropTimer = 0;
      piece.animY = Math.min(piece.animY, piece.y);
    }
  }

  if(piece && !hardDropping && isGrounded(piece)){
    touchingGround = true;
    lockTimer += dt;
    
    lockWarningTimer += dt;
    showLockWarning = lockWarningTimer >= LOCK_WARNING_TIME;
    
    if(lockTimer >= lockDelay){
      lockPiece();
      lockWarningTimer = 0;
      showLockWarning = false;
    }
  }else{
    touchingGround = false;
    lockTimer = 0;
    lockWarningTimer = 0;
    showLockWarning = false;
  }

  draw();
  requestAnimationFrame(loop);
}        
        
  function updateDASARR(dt) {        
    for(const key in keyState) {        
      if(!keyState[key]) continue;        
        
      if(!dasTimer[key]) dasTimer[key] = 0;        
      if(!arrTimer[key]) arrTimer[key] = 0;        
        
      dasTimer[key] += dt;        
        
      if(dasTimer[key] >= DAS) {        
        arrTimer[key] += dt;        
                
        if(ARR === 0) {        
          if(key === 'moveLeft') {        
            while(move(-1));        
          } else if(key === 'moveRight') {        
            while(move(1));        
          }        
          dasTimer[key] = DAS;        
          arrTimer[key] = 0;        
        } else {        
          while(arrTimer[key] >= ARR) {        
            arrTimer[key] -= ARR;        
            if(key === 'moveLeft') {        
              if(!move(-1)) break;        
            } else if(key === 'moveRight') {        
              if(!move(1)) break;        
            }        
          }        
        }        
      }        
    }        
  }        
        
  function buildPreviewCanvases(){        
    previewsEl.innerHTML = '';        
    for(let i=0;i<previewCount;i++){        
      const box = document.createElement('div');        
      box.className = 'preview-item';        
      const cv = document.createElement('canvas');        
      cv.width = 140; cv.height = 100;        
      box.appendChild(cv);        
      previewsEl.appendChild(box);        
    }        
  }        
        
  function updateStats(){        
    scoreEl.textContent = score;        
    levelEl.textContent = level;        
    linesEl.textContent = lines;        
    comboEl.textContent = combo;        
        
    if(combo > 1) {        
      comboInd.classList.add('active');        
    } else {        
      comboInd.classList.remove('active');        
    }        
        
    if(b2bCount > 0) {        
      b2bInd.classList.add('active');        
    } else {        
      b2bInd.classList.remove('active');        
    }        
        
    // Êõ¥Êñ∞Êí§ÈîÄ/ÈáçÂÅöÊåâÈíÆÁä∂ÊÄÅ        
    if(gameMode === 'practice') {        
      btnUndo.disabled = historyIndex <= 0;        
      btnRedo.disabled = historyIndex >= historyStates.length - 1;        
    }        
  }        
        
  function resetGame(){
  sessionStats = {
    tetrises: 0,
    tSpins: 0,
    perfectClears: 0,
    maxCombo: 0,
    startTime: Date.now()
  };
  
  board = createMatrix(COLS, ROWS);
  score = 0; lines = 0; combo = 0; b2bCount = 0;
  level = startLevel;
  
  if(gameMode === 'master') {
    gravity = 0;
    lockDelay = 200;
  } else {
    gravity = levelSpeed(level);
    lockDelay = parseInt(cfgLockDelay.value);
  }
  
  queue = [];
  bag = [];
  particles = [];
  hardDropping = false;
  clearingLines = false;
  clearAnimationTimer = 0;
  lastClearWasSpecial = false;
  lastActionWasRotate = false;
  tSpinType = null;
  gameTimer = 0;
  timerRunning = false;
  lockWarningTimer = 0;
  showLockWarning = false;
  lockMoveResets = 0;
  lowestY = -999;
  pendingInputs = [];
  softDropActive = false;
  softDropTimer = 0;
  gameOverAnimating = false;
  
  const holdBox = document.querySelector('.hold-box');
  if(holdBox) {
    holdBox.classList.remove('locked');
  }
  
  if(gameMode === 'cheese') {
    initCheeseMode();
  }
  
  historyStates = [];
  historyIndex = -1;
  
  refillBag();
  for(let i=0;i<previewCount;i++){
    if(!bag.length) refillBag();
    queue.push(bag.pop());
  }
  
  holdType = null;
  holdLocked = false;
  gameOver = false;
  updateStats();
  buildPreviewCanvases();
  updateModeDisplay();
  spawn();
  redrawSidePanels();
  
  if(gameMode === 'practice') {
    saveHistory();
  }
  
  draw();
  dropTimer = 0;
  lastTS = 0;
  lockTimer = 0;
  touchingGround = false;
}        
        
  function hold(){
  const holdBox = document.querySelector('.hold-box');
  
  if(gameOverAnimating) return;

  if(holdLocked || hardDropping) {
    if(holdLocked) {
      holdBox.classList.add('shake');
      setTimeout(() => holdBox.classList.remove('shake'), 300);
      vibrate(10);
    }
    return;
  }
        
  audioSystem.playSound('hold');
        
  const t = piece.type;
        
  if(!holdType){
    holdType = t;
    holdBox.classList.add('animate-in');
    setTimeout(() => holdBox.classList.remove('animate-in'), 500);
          
    piece = newPiece(takeFromQueue());
  }else{
    holdBox.classList.add('animate-out');
          
    setTimeout(() => {
      [holdType, piece] = [t, newPiece(holdType)];
      holdBox.classList.remove('animate-out');
      holdBox.classList.add('animate-in');
            
      redrawSidePanels();
            
      setTimeout(() => holdBox.classList.remove('animate-in'), 500);
    }, 400);
  }
        
  holdLocked = true;
  holdBox.classList.add('locked');
  
  piece.y = piece.type==='I' ? -1 : 0;
  piece.x = Math.floor(COLS/2) - Math.ceil(piece.m[0].length/2);
  piece.animX = piece.x;
  piece.animY = piece.y;
  lockTimer = 0;
  lockMoveResets = 0;
  lowestY = piece.y;
  touchingGround = false;
  lastActionWasRotate = false;
  tSpinType = null;
  vibrate(8);
        
  if(!holdType || holdBox.classList.contains('animate-out')) return;
  redrawSidePanels();
  draw();
}        

let pendingInputs = [];
const MAX_PENDING_INPUTS = 5;
        
  function inputAction(act) {  
  if (act !== 'pause' && (!running || paused || gameOver)) return;  
            
  highlightKey(act);  
      
  if (clearingLines && act !== 'pause') {  
    if (pendingInputs.length < MAX_PENDING_INPUTS) {  
      pendingInputs.push({action: act, time: Date.now()});  
    }  
    return;  
  }  

  executeAction(act);  
  draw();  
}

function executeAction(act) {
    switch(act) {
        case 'moveLeft':
        case 'left':
            move(-1);
            break;
        case 'moveRight':
        case 'right':
            move(1);
            break;
        case 'rotateRight':
            rotate(+1);
            break;
        case 'rotateLeft':
            rotate(-1);
            break;
        case 'softDrop':
        case 'soft':
            softDropStep();
            break;
        case 'hardDrop':
        case 'hard':
            hardDrop();
            break;
        case 'hold':
            hold();
            break;
        case 'pause':
            togglePause();
            break;
    }
}

function processPendingInputs() {
    const now = Date.now();
    const validInputs = pendingInputs.filter(input => now - input.time < 200);
    
    for(const input of validInputs) {
      executeAction(input.action);
    }
    
    pendingInputs = [];
}        
        
  // ========== ÈîÆÁõò‰∫ã‰ª∂ ==========        
  window.addEventListener('keydown', (e)=>{
    if(gameOver) return;

    if(listeningForKey) {
      e.preventDefault();
      assignKey(listeningForKey, e.key);
      return;
    }

    if(gameMode === 'practice' && e.ctrlKey) {
      if(e.key === 'z' || e.key === 'Z') {
        e.preventDefault();
        undo();
        return;
      }
      if(e.key === 'y' || e.key === 'Y') {
        e.preventDefault();
        redo();
        return;
      }
    }

    for(const action in keyBindings) {
      if(keyBindings[action].includes(e.key)) {
        e.preventDefault();
                
        if(action === 'moveLeft' || action === 'moveRight') {
          if(!keyState[action]) {
            keyState[action] = true;
            dasTimer[action] = 0;
            arrTimer[action] = 0;
            highlightKey(action);
            if(action === 'moveLeft') move(-1);
            else move(1);
          }
        } else if(action === 'softDrop') {
          if(!keyState[action]) {
            keyState[action] = true;
            startSoftDrop();
          }
        } else {
          inputAction(action);
        }
        return;
      }
    }
  }, {passive:false});

  window.addEventListener('keyup', (e)=>{
    for(const action in keyBindings) {
      if(keyBindings[action].includes(e.key)) {
        if(action === 'moveLeft' || action === 'moveRight') {
          keyState[action] = false;
          dasTimer[action] = 0;
          arrTimer[action] = 0;
        } else if(action === 'softDrop') {
          keyState[action] = false;
          stopSoftDrop();
        }
      }
    }
  });        
        
  // ========== Ëß¶Êë∏‰∫ã‰ª∂ ==========        
  cvs.addEventListener('touchstart', (e)=>{        
    const t = e.changedTouches[0];        
    touchStartX = t.clientX; touchStartY = t.clientY; touchStartTime = Date.now();        
  }, {passive:true});        
          
  cvs.addEventListener('touchmove', (e)=>{ e.preventDefault(); }, {passive:false});        
          
  cvs.addEventListener('touchend', (e)=>{        
    const t = e.changedTouches[0];        
    const dx = t.clientX - touchStartX;        
    const dy = t.clientY - touchStartY;        
    const adx = Math.abs(dx), ady = Math.abs(dy);        
    const dt = Date.now() - touchStartTime;        
    const TH = 24;        
            
    if(adx<TH && ady<TH && dt<220){        
      const rect = cvs.getBoundingClientRect();        
      const relY = t.clientY - rect.top;        
      if(relY < rect.height*0.5) inputAction('rotateRight');        
      else inputAction('soft');        
      return;        
    }        
            
    if(adx > ady){        
      if(dx > TH) inputAction('right');        
      else if(dx < -TH) inputAction('left');        
    }else{        
      if(dy > TH) inputAction('soft');        
      else if(dy < -TH) inputAction('hard');        
    }        
  }, {passive:false});        
        
  function attachMobileHandlers(el) {          
  if(!el) return;          

  const actionMap = {          
    left: 'moveLeft',          
    right: 'moveRight',          
    rotateLeft: 'rotateLeft',          
    rotateRight: 'rotateRight',          
    soft: 'softDrop',          
    hard: 'hardDrop',          
    hold: 'hold',          
    pause: 'pause'          
  };          
              
  el.addEventListener('click', (e) => {          
    const t = e.target.closest('.btn');          
    if(!t || !t.dataset.act) return;          
    const action = t.dataset.act;          
    const mapped = actionMap[action] || action;          
    inputAction(mapped);          
  });          
              
  el.addEventListener('touchstart', (e) => {          
    const t = e.target.closest('.btn');          
    if(!t || !t.dataset.act) return;          
    e.preventDefault();          
    t.classList.add('pressed');          
    const action = t.dataset.act;          
    const mapped = actionMap[action] || action;          

    if (mapped === 'moveLeft' || mapped === 'moveRight') {  
      if (!keyState[mapped]) {  
        keyState[mapped] = true;  
        dasTimer[mapped] = 0;  
        arrTimer[mapped] = 0;  
        highlightKey(mapped);  
        if (mapped === 'moveLeft') move(-1);  
        else move(1);  
      }  
    } else if (mapped === 'softDrop') {  
      if (!keyState[mapped]) {  
        keyState[mapped] = true;  
        startSoftDrop();  
      }  
    } else {  
      inputAction(mapped);  
    }          
  }, {passive: false});          
              
  el.addEventListener('touchend', (e) => {          
    const t = e.target.closest('.btn');          
    if(t && t.dataset.act) {          
      t.classList.remove('pressed');          
      const action = t.dataset.act;          
      const mapped = actionMap[action] || action;          

      if (mapped === 'moveLeft' || mapped === 'moveRight') {  
        keyState[mapped] = false;  
        dasTimer[mapped] = 0;  
        arrTimer[mapped] = 0;  
      } else if (mapped === 'softDrop') {  
        keyState[mapped] = false;  
        stopSoftDrop();  
      }  
    }          
  }, {passive: true});          
              
  el.addEventListener('touchcancel', (e) => {          
    const t = e.target.closest('.btn');          
    if(t && t.dataset.act) {          
      t.classList.remove('pressed');          
      const action = t.dataset.act;          
      const mapped = actionMap[action] || action;          

      if (mapped === 'moveLeft' || mapped === 'moveRight') {  
        keyState[mapped] = false;  
        dasTimer[mapped] = 0;  
        arrTimer[mapped] = 0;  
      } else if (mapped === 'softDrop') {  
        keyState[mapped] = false;  
        stopSoftDrop();  
      }  
    }          
  }, {passive: true});          
} 
          
  attachMobileHandlers(mobileControlsEl);        
  attachMobileHandlers(mobileLeftEl);        
  attachMobileHandlers(mobileRightEl);        
        
  function resize(){        
    const wrap = cvs.parentElement;        
    const w = wrap.clientWidth - 8;        
    const h = wrap.clientHeight - 8;        
    const blockW = Math.floor(w / COLS);        
    const blockH = Math.floor(h / ROWS);        
    BLOCK = Math.max(14, Math.min(blockW, blockH));        
    cvs.width = COLS * BLOCK;        
    cvs.height = ROWS * BLOCK;        
    draw();        
    redrawSidePanels();        
  }        
  window.addEventListener('resize', resize);        
        
  // ========== ÊéßÂà∂ÊåâÈíÆ ==========        
btnPlayPause.addEventListener('click', handlePlayPause);        
btnRestart.addEventListener('click', () => {      
  if (confirm('Á°ÆÂÆöË¶ÅÈáçÊñ∞ÂºÄÂßãÊ∏∏ÊàèÂêóÔºüÂΩìÂâçËøõÂ∫¶Â∞Ü‰∏¢Â§±„ÄÇ')) {      
    // Áõ¥Êé•ÈáçÁΩÆÊ∏∏ÊàèÂπ∂ÂºÄÂßãÂÄíËÆ°Êó∂      
    resetGame();      
    resize();      
          
    running = true;      
    paused = true;      
          
    showCountdown(() => {      
      paused = false;      
      timerRunning = true;      
      btnPlayPause.textContent = '‚è∏ ÊöÇÂÅú';      
            
      sessionStats.startTime = Date.now();      
      startProgressAutoSave();      
            
      if(audioSystem) {      
        audioSystem.startBGM(level);      
      }      
            
      lastTS = 0;      
      requestAnimationFrame(loop);      
    });      
  }      
});      
btnSettings.addEventListener('click', ()=> showSettingsOverlay(true));        
btnCloseSettings.addEventListener('click', ()=> showSettingsOverlay(false));        
btnSaveStart.addEventListener('click', saveSettingsAndStart);        
btnUndo.addEventListener('click', undo);        
btnRedo.addEventListener('click', redo);        
btnResetKeys.addEventListener('click', resetKeybindings);        
        
btnHeaderToggle.addEventListener('click', ()=>{        
  topHeader.classList.toggle('header-visible');        
});      
      
// ÊöÇÂÅúËèúÂçïÊåâÈíÆ‰∫ã‰ª∂ÔºàÂøÖÈ°ªÂú®DOMÂÖÉÁ¥†Â£∞Êòé‰πãÂêéÔºâ      
btnPauseResume.addEventListener('click', () => {        
  hidePauseMenu();        
  resumeGame();        
});        
        
btnPauseRestart.addEventListener('click', () => {        
  hidePauseMenu();        
  showSettingsOverlay(true, 'ÈáçÊñ∞ÂºÄÂßã');        
});        
        
btnPauseSettings.addEventListener('click', () => {        
  hidePauseMenu();        
  showSettingsOverlay(true);        
});      
      
// Ê∏∏ÊàèÁªìÊùüÁªüËÆ°È°µÊåâÈíÆ‰∫ã‰ª∂      
btnGameoverRestart.addEventListener('click', () => {        
  hideGameOverStats();        
  showSettingsOverlay(true, 'ÈáçÊñ∞ÂºÄÂßã');        
});        
        
btnGameoverLeaderboard.addEventListener('click', () => {        
  hideGameOverStats();        
  showLeaderboard();        
});        
        
btnGameoverSettings.addEventListener('click', () => {        
  hideGameOverStats();        
  showSettingsOverlay(true);        
});      
      
// ÊéíË°åÊ¶ú‰∫ã‰ª∂ÁõëÂê¨        
btnLeaderboard.addEventListener('click', showLeaderboard);        
btnCloseLeaderboard.addEventListener('click', hideLeaderboard);        
        
btnClearLeaderboard.addEventListener('click', () => {        
  if (confirm(`Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ ${MODE_NAMES[currentLeaderboardMode]} ÁöÑÊéíË°åÊ¶úÂêóÔºü`)) {        
    storageManager.clearLeaderboard(currentLeaderboardMode);        
    renderLeaderboard(currentLeaderboardMode);        
  }        
});        
        
leaderboardTabs.addEventListener('click', (e) => {        
  const tab = e.target.closest('.leaderboard-tab');        
  if (tab) {        
    renderLeaderboard(tab.dataset.mode);        
  }        
});      
      
// Èü≥ÈáèÊéßÂà∂        
cfgSFXVolume.addEventListener('input', (e) => {        
  if (audioSystem) {        
    audioSystem.setSFXVolume(parseInt(e.target.value) / 100);        
  }        
});        
        
cfgMusicVolume.addEventListener('input', (e) => {        
  if (audioSystem) {        
    audioSystem.setMusicVolume(parseInt(e.target.value) / 100);        
  }        
});      
        
  // ========== Tab ÂØºËà™ ==========        
  document.querySelectorAll('.tab-btn').forEach(btn => {        
    btn.addEventListener('click', () => {        
      const tab = btn.dataset.tab;        
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));        
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));        
      btn.classList.add('active');        
      document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');        
    });        
  });        
        
  // ========== Ê®°ÂºèÈÄâÊã© ==========        
  document.querySelectorAll('.mode-card').forEach(card => {        
    card.addEventListener('click', () => {        
      document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));        
      card.classList.add('selected');        
      gameMode = card.dataset.mode;        
              
      // ÊòæÁ§∫/ÈöêËóèÊ®°ÂºèÁâπÂÆöËÆæÁΩÆ        
      document.getElementById('cheeseSettings').style.display =        
        gameMode === 'cheese' ? 'block' : 'none';        
      document.getElementById('ultraSettings').style.display =        
        gameMode === 'ultra' ? 'block' : 'none';        
    });        
  });        
        
  function showSettingsOverlay(v, title){  
  if(v){  
    const h3 = document.getElementById('modalTitle');  
    h3.textContent = title || 'Ê∏∏ÊàèËÆæÁΩÆ';  
      
    if(title === 'ÈÄâÊã©Ê∏∏ÊàèÊ®°Âºè') {  
      btnCloseSettings.style.display = 'none';  
    } else {  
      btnCloseSettings.style.display = '';  
    }  
      
    pausedBeforeOverlay = paused;  
      
    if(running && !paused && !gameOver){  
      paused = true;  
      timerRunning = false;  
      if(btnPlayPause) {  
        btnPlayPause.textContent = '‚ñ∂ ÁªßÁª≠';  
      }  
      if(audioSystem) {  
        audioSystem.stopBGM();  
      }  
    }  
  }else{  
    if(running && !gameOver && paused && !pausedBeforeOverlay){  
      paused = false;  
      timerRunning = true;  
      if(btnPlayPause) {  
        btnPlayPause.textContent = '‚è∏ ÊöÇÂÅú';  
      }  
      if(audioSystem) {  
        audioSystem.startBGM(level);  
      }  
      lastTS = 0;  
      requestAnimationFrame(loop);  
    }  
  }  
    
  overlay.classList.toggle('visible', v);  
}      
        
  function applySkin(name){        
    skin = SKINS[name] || SKINS.classic;        
  }        
        
  function clampInt(v,min,max){        
    v = parseInt(v,10);        
    if(isNaN(v)) v = min;        
    return Math.max(min, Math.min(max, v));        
  }        
        
  function saveSettingsAndStart(){        
    COLS = clampInt(cfgCols.value,6,20);        
    ROWS = clampInt(cfgRows.value,12,40);        
    previewCount = clampInt(cfgPreview.value,1,6);        
    ghostEnabled = cfgGhost.value==='on';        
    lockDelay = clampInt(cfgLockDelay.value,200,2000);        
    DAS = clampInt(cfgDAS.value, 0, 300);        
    ARR = clampInt(cfgARR.value, 0, 100);        
    applySkin(cfgSkin.value);        
    vibrationEnabled = cfgVibration.value === 'on';        
        
    startLevel = clampInt(cfgStartLevel.value,1,20);        
    level = startLevel;        
    gravity = levelSpeed(level);        
        
    cheeseLines = clampInt(cfgCheeseLines.value, 5, 18);        
    initialCheeseLines = cheeseLines;        
        
    ultraTimeLimit = clampInt(cfgUltraTime.value, 60, 300);        
        
    // ‰øùÂ≠òËÆæÁΩÆ        
    saveCurrentSettings();        
        
// Â∫îÁî®Èü≥È¢ëËÆæÁΩÆ        
    if (audioSystem) {        
      audioSystem.setSFXVolume(parseInt(cfgSFXVolume.value) / 100);        
      audioSystem.setMusicVolume(parseInt(cfgMusicVolume.value) / 100);        
    }        
        
    resetGame();        
    resize();        
    showSettingsOverlay(false);        
        
// ÈáçÁΩÆÊ∏∏ÊàèÂêé‰ΩøÁî®ÂÄíËÆ°Êó∂ÂºÄÂßã        
running = true;        
paused = true;        
        
showCountdown(() => {        
  paused = false;        
  timerRunning = true;        
  btnPlayPause.textContent = '‚è∏ ÊöÇÂÅú';        
          
  sessionStats.startTime = Date.now();        
  startProgressAutoSave();        
          
  if(audioSystem) {        
    audioSystem.startBGM(level);        
  }        
          
  lastTS = 0;        
  requestAnimationFrame(loop);        
});        
          
  }        
        
  // ========== Êí≠Êîæ/ÊöÇÂÅúÁªü‰∏ÄÊéßÂà∂ ==========        
function handlePlayPause() {  
  if (isCountingDown) return;  
    
  if (gameOver) {  
    showSettingsOverlay(true, 'ÈáçÊñ∞ÂºÄÂßã');  
    return;  
  }  
    
  if (!running) {  
    showSettingsOverlay(true, 'ÈÄâÊã©Ê∏∏ÊàèÊ®°Âºè');  
    return;  
  }  
    
  if (paused) {  
    hidePauseMenu();  
    resumeGame();  
  } else {  
    pauseGame();  
  }  
}

let gameOverAnimating = false;
let gameOverAnimRow = 0;

function startGameOverAnimation(callback) {
  gameOverAnimating = true;
  gameOverAnimRow = ROWS - 1;
  
  function animateRow() {
    if(gameOverAnimRow < 0) {
      gameOverAnimating = false;
      setTimeout(callback, 300);
      return;
    }
    
    for(let x = 0; x < COLS; x++) {
      if(!board[gameOverAnimRow][x]) {
        board[gameOverAnimRow][x] = 'G';
      }
    }
    
    draw();
    audioSystem.playSound('lock');
    vibrate(5);
    
    gameOverAnimRow--;
    setTimeout(animateRow, 30);
  }
  
  animateRow();
}
        
function startNewGame() {        
  running = true;        
  paused = true; // ÂÖàÊöÇÂÅúÔºåÁ≠âÂÄíËÆ°Êó∂ÁªìÊùü        
          
  showCountdown(() => {        
    paused = false;        
    timerRunning = true;        
    btnPlayPause.textContent = '‚è∏ ÊöÇÂÅú';        
            
    if (sessionStats.startTime === 0) {        
      sessionStats.startTime = Date.now();        
    }        
            
    startProgressAutoSave();        
            
    if(audioSystem) {        
      audioSystem.startBGM(level);        
    }        
            
    lastTS = 0;        
    requestAnimationFrame(loop);        
  });        
}        

function updateMobilePauseButtons(label) {  
  const btns = document.querySelectorAll('.btn[data-act="pause"]');  
  btns.forEach(b => {  
    b.textContent = label;  
  });  
}
        
function pauseGame() {          
  paused = true;          
  timerRunning = false;          
  btnPlayPause.textContent = '‚ñ∂ ÁªßÁª≠';  
  updateMobilePauseButtons('‚ñ∂ ÁªßÁª≠');          
  showPauseMenu();          
            
  if(audioSystem) {          
    audioSystem.stopBGM();          
  }          
}
        
function resumeGame() {          
  paused = false;          
  timerRunning = true;          
  btnPlayPause.textContent = '‚è∏ ÊöÇÂÅú';  
  updateMobilePauseButtons('‚è∏ ÊöÇÂÅú');          
            
  if(audioSystem) {          
    audioSystem.startBGM(level);          
  }          
            
  lastTS = 0;          
  requestAnimationFrame(loop);          
}
        
  function startOrResume(){        
  if(gameOver){        
    showSettingsOverlay(true, 'ÈáçÊñ∞ÂºÄÂßã');        
    return;        
  }        
          
  if (!running) {        
    startNewGame();        
  } else if (paused) {        
    hidePauseMenu();        
    resumeGame();        
  }        
}        
        
  function togglePause(){        
  if(!running || isCountingDown) return;        
          
  if (paused) {        
    hidePauseMenu();        
    resumeGame();        
  } else {        
    pauseGame();        
  }        
}        
        
        
          
function endGame(message) {
  gameOver = true;
  timerRunning = false;
  
  const isVictory = message && (message.includes('ÂÆåÊàê') || message.includes('üéâ'));
  
  audioSystem.stopBGM();
  
  if(isVictory) {
    const rank = saveGameResult();
    stopProgressAutoSave();
    running = false;
    paused = false;
    btnPlayPause.textContent = '‚ñ∂ ÂºÄÂßã';
    audioSystem.playSound('levelUp');
    screenShaker.bigShake();
    vibrate([50, 100, 50]);
    showGameOverStats(message, isVictory, rank);
  } else {
    startGameOverAnimation(() => {
      const rank = saveGameResult();
      stopProgressAutoSave();
      running = false;
      paused = false;
      btnPlayPause.textContent = '‚ñ∂ ÂºÄÂßã';
      audioSystem.playSound('gameOver');
      screenShaker.bigShake();
      vibrate([50, 100, 50]);
      showGameOverStats(message, isVictory, rank);
    });
  }
}        
        
  // ========== ËÆ°Êó∂Âô® ==========        
  function updateTimer(dt) {        
    if(!timerRunning) return;        
            
    gameTimer += dt;        
            
    if(gameMode === 'sprint' || gameMode === 'cheese') {        
      timerDisplay.textContent = formatTime(gameTimer);        
    } else if(gameMode === 'ultra') {        
      const remaining = ultraTimeLimit * 1000 - gameTimer;        
      timerDisplay.textContent = formatTime(Math.max(0, remaining));        
              
      if(remaining < 30000) {        
        timerDisplay.classList.add('warning');        
      }        
      if(remaining < 10000) {        
        timerDisplay.classList.remove('warning');        
        timerDisplay.classList.add('danger');        
      }        
    }        
  }        
        
  function formatTime(ms) {        
    const totalSeconds = Math.floor(ms / 1000);        
    const minutes = Math.floor(totalSeconds / 60);        
    const seconds = totalSeconds % 60;        
    const centiseconds = Math.floor((ms % 1000) / 10);        
    return `${pad(minutes)}:${pad(seconds)}.${pad(centiseconds)}`;        
  }        
        
  function pad(n) {        
    return n.toString().padStart(2, '0');        
  }        
        
  function updateModeDisplay() {        
    modeDisplayEl.textContent = MODE_NAMES[gameMode] || gameMode;        
            
    // ÊòæÁ§∫/ÈöêËóèËÆ°Êó∂Âô®        
    if(gameMode === 'sprint' || gameMode === 'ultra' || gameMode === 'cheese') {        
      timerContainer.style.display = 'block';        
      timerDisplay.className = 'timer-display';        
    } else {        
      timerContainer.style.display = 'none';        
    }        
        
    // ÊòæÁ§∫/ÈöêËóèÊåñÊéòÊ®°ÂºèËøõÂ∫¶        
    if(gameMode === 'cheese') {        
      cheeseContainer.style.display = 'block';        
    } else {        
      cheeseContainer.style.display = 'none';        
    }        
        
    // ÊòæÁ§∫/ÈöêËóèÊí§ÈîÄÊéßÂà∂        
    if(gameMode === 'practice') {        
      undoControls.classList.add('visible');        
    } else {        
      undoControls.classList.remove('visible');        
    }        
  }        
        
  // ========== ÊåñÊéòÊ®°Âºè ==========        
  function initCheeseMode() {        
    // Â°´ÂÖÖÂ∫ïÈÉ®ÂûÉÂúæË°å        
    const startRow = ROWS - cheeseLines;        
    for(let y = startRow; y < ROWS; y++) {        
      const holePos = Math.floor(Math.random() * COLS);        
      for(let x = 0; x < COLS; x++) {        
        if(x !== holePos) {        
          board[y][x] = 'G';        
        }        
      }        
    }        
    updateCheeseProgress();        
  }        
        
  function countCheeseLines() {        
    let count = 0;        
    for(let y = 0; y < ROWS; y++) {        
      if(board[y].some(cell => cell === 'G')) {        
        count++;        
      }        
    }        
    return count;        
  }        
        
  function updateCheeseProgress() {        
    const remaining = countCheeseLines();        
    cheeseRemaining.textContent = remaining;        
    const progress = Math.max(0, (initialCheeseLines - remaining) / initialCheeseLines * 100);        
    cheeseProgress.style.width = progress + '%';        
  }        
        
  function checkModeCompletion() {        
    if(gameMode === 'sprint' && lines >= 40) {        
      endGame('üéâ ÂÆåÊàêÔºÅ');        
    } else if(gameMode === 'cheese' && countCheeseLines() === 0) {        
      endGame('üéâ Ê∏ÖÁêÜÂÆåÊàêÔºÅ');        
    }        
  }        
        
  // ========== Êí§ÈîÄ/ÈáçÂÅöÁ≥ªÁªü ==========        
  function saveHistory() {
  if(gameMode !== 'practice') return;

  const state = {
    board: cloneMatrix(board),
    score,
    lines,
    level,
    combo,
    b2bCount,
    lastClearWasSpecial,
    holdType,
    holdLocked,
    queue: [...queue],
    bag: [...bag],
    lockMoveResets,
    lowestY,
    piece: piece ? {
      type: piece.type,
      x: piece.x,
      y: piece.y,
      m: piece.m.map(row => row.slice()),
      rotation: piece.rotation,
      color: piece.color,
      animX: piece.animX,
      animY: piece.animY
    } : null
  };

  historyStates = historyStates.slice(0, historyIndex + 1);
    
  historyStates.push(JSON.parse(JSON.stringify(state)));
  historyIndex = historyStates.length - 1;
    
  while(historyStates.length > MAX_HISTORY) {
    historyStates.shift();
    historyIndex--;
  }

  updateStats();
}        
        
        
  function undo() {        
    if(gameMode !== 'practice' || historyIndex <= 0) return;        
        
    historyIndex--;        
    restoreHistory();        
    vibrate(5);        
  }        
        
  function redo() {        
    if(gameMode !== 'practice' || historyIndex >= historyStates.length - 1) return;        
        
    historyIndex++;        
    restoreHistory();        
    vibrate(5);        
  }        
        
  function restoreHistory() {
  const state = historyStates[historyIndex];
  board = cloneMatrix(state.board);
  score = state.score;
  lines = state.lines;
  level = state.level;
  combo = state.combo;
  b2bCount = state.b2bCount;
  lastClearWasSpecial = state.lastClearWasSpecial;
  holdType = state.holdType;
  holdLocked = state.holdLocked;
  queue = [...state.queue];
  bag = [...state.bag];
  lockMoveResets = state.lockMoveResets || 0;
  lowestY = state.lowestY || -999;
      
  if(state.piece) {
    piece = {
      type: state.piece.type,
      x: state.piece.x,
      y: state.piece.y,
      m: state.piece.m.map(row => row.slice()),
      rotation: state.piece.rotation,
      color: skin[state.piece.type],
      animX: state.piece.animX,
      animY: state.piece.animY
    };
  } else {
    piece = null;
  }

  lockTimer = 0;
  lockWarningTimer = 0;
  showLockWarning = false;
  touchingGround = false;
  
  const holdBox = document.querySelector('.hold-box');
  if(holdBox) {
    holdBox.classList.toggle('locked', holdLocked);
  }

  updateStats();
  redrawSidePanels();
  draw();
}        
        
        
  // ========== ÈîÆ‰ΩçËá™ÂÆö‰πâ ==========        
  function buildKeybindUI() {        
    keybindGrid.innerHTML = '';        
            
    const actionNames = {        
        moveLeft: 'Â∑¶Áßª',        
        moveRight: 'Âè≥Áßª',        
        softDrop: 'ËΩØÈôç',        
        hardDrop: 'Á°¨Èôç',        
        rotateRight: 'È°∫Êó∂ÈíàÊóãËΩ¨ ‚Üª',        
        rotateLeft: 'ÈÄÜÊó∂ÈíàÊóãËΩ¨ ‚Ü∫',           
        hold: 'ÊöÇÂ≠ò',        
        pause: 'ÊöÇÂÅú'        
    };        
            
    for(const action in keyBindings) {        
        const item = document.createElement('div');        
        item.className = 'keybind-item';        
                
        const label = document.createElement('div');        
        label.className = 'keybind-label';        
        label.textContent = actionNames[action] || action;        
                
        const button = document.createElement('div');        
        button.className = 'keybind-button';        
        button.textContent = formatKeys(keyBindings[action]);        
        button.dataset.action = action;        
                
        button.addEventListener('click', () => {        
            startListening(action, button);        
        });        
                
        item.appendChild(label);        
        item.appendChild(button);        
        keybindGrid.appendChild(item);        
    }        
}        
        
  function formatKeys(keys) {        
    if(!keys || keys.length === 0) return 'Êú™ËÆæÁΩÆ';        
    return keys.map(k => {        
      if(k === ' ') return 'Space';        
      if(k.length === 1) return k.toUpperCase();        
      return k;        
    }).join(', ');        
  }        
        
  function startListening(action, button) {        
    if(listeningForKey) {        
      document.querySelector('.keybind-button.listening').classList.remove('listening');        
    }        
            
    listeningForKey = action;        
    button.classList.add('listening');        
    button.textContent = 'Êåâ‰∏ãÊåâÈîÆ...';        
  }        
        
  function assignKey(action, key) {        
  // ÁßªÈô§ÂÖ∂‰ªñÂä®‰Ωú‰∏≠ÁöÑÊ≠§ÈîÆ        
  for(const act in keyBindings) {        
    keyBindings[act] = keyBindings[act].filter(k => k !== key);        
  }        
          
  // Ê∑ªÂä†Âà∞ÂΩìÂâçÂä®‰Ωú        
  keyBindings[action] = [key];        
          
  // ‰øùÂ≠òÈîÆ‰ΩçÁªëÂÆö        
  storageManager.saveKeybindings(keyBindings);        
          
  // Êõ¥Êñ∞UI        
  const button = document.querySelector(`[data-action="${action}"]`);        
  button.textContent = formatKeys(keyBindings[action]);        
  button.classList.remove('listening');        
          
  listeningForKey = null;        
}        
        
        
  function resetKeybindings() {        
  keyBindings = JSON.parse(JSON.stringify(DEFAULT_KEYBINDS));        
  storageManager.saveKeybindings(keyBindings);        
  buildKeybindUI();        
}        
        
        
  // ========== ÊéíË°åÊ¶úÁ≥ªÁªü ==========        
function showLeaderboard() {        
  updateGlobalStatsDisplay();        
  renderLeaderboard(currentLeaderboardMode);        
  leaderboardOverlay.classList.add('visible');        
          
  if(running && !paused && !gameOver) {        
    togglePause();        
  }        
}        
        
function hideLeaderboard() {        
  leaderboardOverlay.classList.remove('visible');        
}        
        
function updateGlobalStatsDisplay() {        
  const stats = storageManager.loadStatistics();        
          
  statTotalGames.textContent = stats.totalGames.toLocaleString();        
  statTotalLines.textContent = stats.totalLines.toLocaleString();        
  statTotalScore.textContent = formatLargeNumber(stats.totalScore);        
  statPlayTime.textContent = formatPlayTime(stats.totalPlayTime);        
  statTetrises.textContent = stats.tetrises.toLocaleString();        
  statTSpins.textContent = stats.tSpins.toLocaleString();        
}        
        
function formatLargeNumber(num) {        
  if (num >= 1000000) {        
    return (num / 1000000).toFixed(1) + 'M';        
  } else if (num >= 1000) {        
    return (num / 1000).toFixed(1) + 'K';        
  }        
  return num.toLocaleString();        
}        
        
function formatPlayTime(ms) {        
  const hours = Math.floor(ms / 3600000);        
  const minutes = Math.floor((ms % 3600000) / 60000);        
  if (hours > 0) {        
    return `${hours}h ${minutes}m`;        
  }        
  return `${minutes}m`;        
}        
        
function renderLeaderboard(mode) {        
  currentLeaderboardMode = mode;        
  const leaderboard = storageManager.loadLeaderboard();        
  const entries = leaderboard[mode] || [];        
          
  // Êõ¥Êñ∞Ê†áÁ≠æÈ°µ        
  leaderboardTabs.querySelectorAll('.leaderboard-tab').forEach(tab => {        
    tab.classList.toggle('active', tab.dataset.mode === mode);        
  });        
          
  // Êõ¥Êñ∞Ë°®Â§¥        
  if (mode === 'sprint' || mode === 'cheese') {        
    scoreHeader.textContent = 'Áî®Êó∂';        
  } else {        
    scoreHeader.textContent = 'ÂàÜÊï∞';        
  }        
          
  if (entries.length === 0) {        
    leaderboardContent.innerHTML = '<div class="leaderboard-empty">ÊöÇÊó†ËÆ∞ÂΩïÔºåÂø´Êù•ÂàõÈÄ†ÂéÜÂè≤ÔºÅ</div>';        
    return;        
  }        
          
  let html = '';        
  entries.forEach((entry, index) => {        
    const rank = index + 1;        
    let rankClass = '';        
    if (rank === 1) rankClass = 'gold';        
    else if (rank === 2) rankClass = 'silver';        
    else if (rank === 3) rankClass = 'bronze';        
            
    const scoreDisplay = (mode === 'sprint' || mode === 'cheese')        
      ? formatTime(entry.time)        
      : entry.score.toLocaleString();        
            
    const dateDisplay = formatDate(entry.date);        
            
    html += `        
      <div class="leaderboard-row">        
        <div class="leaderboard-rank ${rankClass}">#${rank}</div>        
        <div class="leaderboard-name">${entry.name || 'Áé©ÂÆ∂'}</div>        
        <div class="leaderboard-score">${scoreDisplay}</div>        
        <div class="leaderboard-date">${dateDisplay}</div>        
      </div>        
    `;        
  });        
          
  leaderboardContent.innerHTML = html;        
}        
        
function formatDate(isoString) {        
  const date = new Date(isoString);        
  const month = date.getMonth() + 1;        
  const day = date.getDate();        
  const hours = date.getHours().toString().padStart(2, '0');        
  const minutes = date.getMinutes().toString().padStart(2, '0');        
  return `${month}/${day} ${hours}:${minutes}`;        
}        
        
function saveGameResult() {        
  if (gameMode === 'practice') return;        
          
  const playTime = Date.now() - sessionStats.startTime;        
          
  // Êõ¥Êñ∞ÊÄª‰ΩìÁªüËÆ°        
  storageManager.updateStatistics({        
    lines: lines,        
    score: score,        
    playTime: playTime,        
    maxCombo: sessionStats.maxCombo,        
    tetrises: sessionStats.tetrises,        
    tSpins: sessionStats.tSpins,        
    perfectClears: sessionStats.perfectClears        
  });        
          
  // ÊûÑÂª∫ÊéíË°åÊ¶úÊù°ÁõÆ        
  const entry = {        
    name: 'Áé©ÂÆ∂',        
    score: score,        
    lines: lines,        
    level: level,        
    time: gameTimer        
  };        
          
  // Ê∑ªÂä†Âà∞ÊéíË°åÊ¶ú        
  const rank = storageManager.addToLeaderboard(gameMode, entry);        
          
  // Ê∏ÖÈô§‰øùÂ≠òÁöÑÊ∏∏ÊàèËøõÂ∫¶        
  storageManager.clearGameProgress();        
          
  return rank;        
}        
        
// ========== Ê∏∏ÊàèËøõÂ∫¶‰øùÂ≠òÁ≥ªÁªü ==========        
function saveCurrentProgress() {        
  if (!running || gameOver || gameMode === 'practice') return;        
          
  const progress = {        
    board: cloneMatrix(board),        
    score: score,        
    lines: lines,        
    level: level,        
    combo: combo,        
    b2bCount: b2bCount,        
    lastClearWasSpecial: lastClearWasSpecial,        
    holdType: holdType,        
    holdLocked: holdLocked,        
    queue: [...queue],        
    bag: [...bag],        
    gameMode: gameMode,        
    gameTimer: gameTimer,        
    piece: piece ? {        
      type: piece.type,        
      x: piece.x,        
      y: piece.y,        
      m: piece.m.map(row => [...row]),        
      rotation: piece.rotation        
    } : null,        
    sessionStats: {...sessionStats},        
    savedAt: Date.now()        
  };        
          
  storageManager.saveGameProgress(progress);        
}        
        
function loadSavedProgress() {        
  const progress = storageManager.loadGameProgress();        
  if (!progress) return false;        
          
  // Ê£ÄÊü•‰øùÂ≠òÊó∂Èó¥ÔºåË∂ÖËøá24Â∞èÊó∂ËßÜ‰∏∫ËøáÊúü        
  if (Date.now() - progress.savedAt > 24 * 60 * 60 * 1000) {        
    storageManager.clearGameProgress();        
    return false;        
  }        
          
  return progress;        
}        
        
function restoreGameProgress(progress) {        
  board = cloneMatrix(progress.board);        
  score = progress.score;        
  lines = progress.lines;        
  level = progress.level;        
  combo = progress.combo;        
  b2bCount = progress.b2bCount;        
  lastClearWasSpecial = progress.lastClearWasSpecial;        
  holdType = progress.holdType;        
  holdLocked = progress.holdLocked;        
  queue = [...progress.queue];        
  bag = [...progress.bag];        
  gameMode = progress.gameMode;        
  gameTimer = progress.gameTimer;        
  sessionStats = {...progress.sessionStats};        
          
  if (progress.piece) {        
    piece = {        
      type: progress.piece.type,        
      x: progress.piece.x,        
      y: progress.piece.y,        
      m: progress.piece.m.map(row => [...row]),        
      rotation: progress.piece.rotation,        
      color: skin[progress.piece.type],        
      animX: progress.piece.x,        
      animY: progress.piece.y        
    };        
  }        
          
  gravity = levelSpeed(level);        
  gameOver = false;        
  running = false;        
  paused = false;        
          
  buildPreviewCanvases();        
  updateModeDisplay();        
  updateStats();        
  redrawSidePanels();        
  resize();        
  draw();        
          
  storageManager.clearGameProgress();        
  return true;        
}        
        
// ÂÆöÊúü‰øùÂ≠òÊ∏∏ÊàèËøõÂ∫¶ÔºàÊØè30ÁßíÔºâ        
let progressSaveInterval = null;        
        
function startProgressAutoSave() {        
  stopProgressAutoSave();        
  progressSaveInterval = setInterval(() => {        
    if (running && !paused && !gameOver) {        
      saveCurrentProgress();        
    }        
  }, 30000);        
}        
        
function stopProgressAutoSave() {        
  if (progressSaveInterval) {        
    clearInterval(progressSaveInterval);        
    progressSaveInterval = null;        
  }        
}        
        
// È°µÈù¢Âç∏ËΩΩÊó∂‰øùÂ≠òËøõÂ∫¶        
window.addEventListener('beforeunload', () => {        
  if (running && !gameOver) {        
    saveCurrentProgress();        
  }        
});        
        
// È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñÊó∂‰øùÂ≠ò        
document.addEventListener('visibilitychange', () => {        
  if (document.hidden && running && !gameOver) {        
    saveCurrentProgress();        
  }        
});        
        
// ========== ËÆæÁΩÆÊåÅ‰πÖÂåñ ==========        
function saveCurrentSettings() {        
  const settings = {        
    cols: parseInt(cfgCols.value),        
    rows: parseInt(cfgRows.value),        
    previewCount: parseInt(cfgPreview.value),        
    startLevel: parseInt(cfgStartLevel.value),        
    ghostEnabled: cfgGhost.value === 'on',        
    lockDelay: parseInt(cfgLockDelay.value),        
    das: parseInt(cfgDAS.value),        
    arr: parseInt(cfgARR.value),        
    skin: cfgSkin.value,        
    vibration: cfgVibration.value === 'on',        
    sfxVolume: parseInt(cfgSFXVolume.value),        
    musicVolume: parseInt(cfgMusicVolume.value),        
    gameMode: gameMode,        
    cheeseLines: parseInt(cfgCheeseLines.value),        
    ultraTime: parseInt(cfgUltraTime.value)        
  };        
          
  storageManager.saveSettings(settings);        
}        
        
function loadSavedSettings() {        
  const settings = storageManager.loadSettings();        
          
  cfgCols.value = settings.cols || 10;        
  cfgRows.value = settings.rows || 20;        
  cfgPreview.value = settings.previewCount || 5;        
  cfgStartLevel.value = settings.startLevel || 1;        
  cfgGhost.value = settings.ghostEnabled !== false ? 'on' : 'off';        
  cfgLockDelay.value = settings.lockDelay || 1500;        
  cfgDAS.value = settings.das !== undefined ? settings.das : 120;        
  cfgARR.value = settings.arr !== undefined ? settings.arr : 20;        
  cfgSkin.value = settings.skin || 'classic';        
  cfgVibration.value = settings.vibration !== false ? 'on' : 'off';        
  cfgSFXVolume.value = settings.sfxVolume !== undefined ? settings.sfxVolume : 50;        
  cfgMusicVolume.value = settings.musicVolume !== undefined ? settings.musicVolume : 30;        
  cfgCheeseLines.value = settings.cheeseLines || 10;        
  cfgUltraTime.value = settings.ultraTime || 120;        
          
  // Â∫îÁî®Ê∏∏ÊàèÊ®°Âºè        
  if (settings.gameMode) {        
    gameMode = settings.gameMode;        
    document.querySelectorAll('.mode-card').forEach(card => {        
      card.classList.toggle('selected', card.dataset.mode === gameMode);        
    });        
    document.getElementById('cheeseSettings').style.display =        
      gameMode === 'cheese' ? 'block' : 'none';        
    document.getElementById('ultraSettings').style.display =        
      gameMode === 'ultra' ? 'block' : 'none';        
  }        
          
  // Â∫îÁî®Èü≥È¢ëËÆæÁΩÆ        
  if (audioSystem) {        
    audioSystem.setSFXVolume(settings.sfxVolume / 100 || 0.5);        
    audioSystem.setMusicVolume(settings.musicVolume / 100 || 0.3);        
  }        
}        
        
function loadSavedKeybindings() {        
  const saved = storageManager.loadKeybindings();        
  if (saved) {        
    keyBindings = saved;        
    buildKeybindUI();        
  }        
}        
        
  // ========== ÊâãÊüÑÊîØÊåÅ ==========        
  window.addEventListener('gamepadconnected', (e) => {        
    connectedGamepad = e.gamepad;        
    gamepadIndicator.classList.add('connected');        
    gamepadName.textContent = e.gamepad.id.substring(0, 20) + '...';        
    console.log('ÊâãÊüÑÂ∑≤ËøûÊé•:', e.gamepad.id);        
  });        
        
  window.addEventListener('gamepaddisconnected', (e) => {
    connectedGamepad = null;
    gamepadIndicator.classList.remove('connected');
    
    for(const action in gamepadState) {
      if(gamepadState[action]) {
        if(action === 'moveLeft' || action === 'moveRight') {
          keyState[action] = false;
          dasTimer[action] = 0;
          arrTimer[action] = 0;
        }
      }
    }
    gamepadState = {};
    lastGamepadState = {};
    
    console.log('ÊâãÊüÑÂ∑≤Êñ≠ÂºÄ');
  });        
        
  function pollGamepad() {
    if(!connectedGamepad) return;
    if(isCountingDown) return;

    const gamepads = navigator.getGamepads();
    const gp = gamepads[connectedGamepad.index];
    if(!gp) return;        
        
    // Ê£ÄÊü•ÊåâÈíÆÁä∂ÊÄÅ        
    for(const action in GAMEPAD_BINDINGS) {        
      const buttons = GAMEPAD_BINDINGS[action];        
      let pressed = false;        
              
      for(const btnIdx of buttons) {        
        if(gp.buttons[btnIdx] && gp.buttons[btnIdx].pressed) {        
          pressed = true;        
          break;        
        }        
      }        
        
      const wasPressed = gamepadState[action] || false;        
        
      if(pressed && !wasPressed) {        
        // ÊåâÈíÆÂàöË¢´Êåâ‰∏ã        
        if(action === 'moveLeft' || action === 'moveRight') {        
          keyState[action] = true;        
          dasTimer[action] = 0;        
          arrTimer[action] = 0;        
          if(action === 'moveLeft') move(-1);        
          else move(1);        
        } else {        
          inputAction(action);        
        }        
      } else if(!pressed && wasPressed) {        
        // ÊåâÈíÆÂàöË¢´ÈáäÊîæ        
        if(action === 'moveLeft' || action === 'moveRight') {        
          keyState[action] = false;        
          dasTimer[action] = 0;        
          arrTimer[action] = 0;        
        }        
      }        
        
      gamepadState[action] = pressed;        
    }        
        
    // ÊñπÂêëÈîÆÔºàËΩ¥ÔºâÊîØÊåÅ        
    const threshold = 0.5;        
    const leftStickX = gp.axes[0];        
            
    if(leftStickX < -threshold) {        
      if(!gamepadState['axisLeft']) {        
        keyState['moveLeft'] = true;        
        dasTimer['moveLeft'] = 0;        
        arrTimer['moveLeft'] = 0;        
        move(-1);        
        gamepadState['axisLeft'] = true;        
      }        
    } else {        
      if(gamepadState['axisLeft']) {        
        keyState['moveLeft'] = false;        
        dasTimer['moveLeft'] = 0;        
        arrTimer['moveLeft'] = 0;        
        gamepadState['axisLeft'] = false;        
      }        
    }        
        
    if(leftStickX > threshold) {        
      if(!gamepadState['axisRight']) {        
        keyState['moveRight'] = true;        
        dasTimer['moveRight'] = 0;        
        arrTimer['moveRight'] = 0;        
        move(1);        
        gamepadState['axisRight'] = true;        
      }        
    } else {        
      if(gamepadState['axisRight']) {        
        keyState['moveRight'] = false;        
        dasTimer['moveRight'] = 0;        
        arrTimer['moveRight'] = 0;        
        gamepadState['axisRight'] = false;        
      }        
    }        
  }        
        
  // ========== ÈúáÂä®ÂèçÈ¶à ==========        
  function vibrate(duration) {        
    if(!vibrationEnabled) return;        
            
    // ÁßªÂä®Á´ØÈúáÂä®        
    if(navigator.vibrate) {        
      navigator.vibrate(duration);        
    }        
        
    // ÊâãÊüÑÈúáÂä®        
    if(connectedGamepad && connectedGamepad.vibrationActuator) {        
      const intensity = Math.min(1.0, duration / 50);        
      connectedGamepad.vibrationActuator.playEffect('dual-rumble', {        
        startDelay: 0,        
        duration: duration,        
        weakMagnitude: intensity * 0.5,        
        strongMagnitude: intensity        
      });        
    }        
  }        
        
  function showResumePrompt(progress) {        
  const modalContent = document.querySelector('.modal');        
  const existingPrompt = document.querySelector('.resume-prompt');        
  if (existingPrompt) existingPrompt.remove();        
          
  const modeNames = {        
    marathon: 'È©¨ÊãâÊùæ',        
    sprint: '40Ë°åÁ´ûÈÄü',        
    ultra: 'ÈôêÊó∂ÊâìÂàÜ',        
    cheese: 'ÊåñÊéòÊ®°Âºè',        
    master: 'Â§ßÂ∏àÊ®°Âºè'        
  };        
          
  const prompt = document.createElement('div');        
  prompt.className = 'resume-prompt';        
  prompt.innerHTML = `        
    <h4>üéÆ ÂèëÁé∞Êú™ÂÆåÊàêÁöÑÊ∏∏Êàè</h4>        
    <p>Ê®°Âºè: ${modeNames[progress.gameMode] || progress.gameMode} | ÂàÜÊï∞: ${progress.score.toLocaleString()} | Ë°åÊï∞: ${progress.lines}</p>        
    <div class="actions">        
      <button id="btnResumeGame" class="primary">ÁªßÁª≠Ê∏∏Êàè</button>        
      <button id="btnNewGame">ÂºÄÂßãÊñ∞Ê∏∏Êàè</button>        
    </div>        
  `;        
          
  modalContent.insertBefore(prompt, modalContent.querySelector('.tab-nav'));        
  showSettingsOverlay(true, 'Ê¨¢ËøéÂõûÊù•');        
          
  document.getElementById('btnResumeGame').addEventListener('click', () => {        
  prompt.remove();        
  if (restoreGameProgress(progress)) {        
    showSettingsOverlay(false);        
            
    // ÊÅ¢Â§çÊ∏∏Êàè‰πü‰ΩøÁî®ÂÄíËÆ°Êó∂        
    running = true;        
    paused = true;        
            
    showCountdown(() => {        
      paused = false;        
      timerRunning = true;        
      btnPlayPause.textContent = '‚è∏ ÊöÇÂÅú';        
              
      startProgressAutoSave();        
              
      if(audioSystem) {        
        audioSystem.startBGM(level);        
      }        
              
      lastTS = 0;        
      requestAnimationFrame(loop);        
    });        
  }        
});        
          
  document.getElementById('btnNewGame').addEventListener('click', () => {        
    prompt.remove();        
    storageManager.clearGameProgress();        
  });        
}        
        
        
  // ========== ÂàùÂßãÂåñ ==========        
(function init(){        
  // ÂàùÂßãÂåñÂ≠òÂÇ®ÁÆ°ÁêÜÂô®        
  storageManager = new StorageManager();        
          
  // Âä†ËΩΩ‰øùÂ≠òÁöÑËÆæÁΩÆ        
  loadSavedSettings();        
  loadSavedKeybindings();        
          
  audioSystem = new AudioSystem();        
          
  // Â∫îÁî®Âä†ËΩΩÁöÑÈü≥ÈáèËÆæÁΩÆ        
  audioSystem.setSFXVolume(parseInt(cfgSFXVolume.value) / 100);        
  audioSystem.setMusicVolume(parseInt(cfgMusicVolume.value) / 100);        
          
  screenShaker = new ScreenShake(document.querySelector('.playfield-wrap'));        
  bgParticles = new BackgroundParticles(document.querySelector('.playfield-wrap'));        
          
  applySkin(cfgSkin.value);        
  buildPreviewCanvases();        
  buildKeybindUI();        
  resize();        
  updateModeDisplay();        
          
  // Ê£ÄÊü•ÊòØÂê¶Êúâ‰øùÂ≠òÁöÑÊ∏∏ÊàèËøõÂ∫¶        
  const savedProgress = loadSavedProgress();        
  if (savedProgress) {        
    // ÊòæÁ§∫ÊÅ¢Â§çÊ∏∏ÊàèÊèêÁ§∫        
    showResumePrompt(savedProgress);        
  } else {        
    showSettingsOverlay(true);        
  }        
          
  // Á°Æ‰øùÊåâÈíÆÂàùÂßãÁä∂ÊÄÅ        
  btnPlayPause.textContent = '‚ñ∂ ÂºÄÂßã';        
          
  draw();        
          
  // ÂàùÂßãÂåñÁ´ñÂ±èÊ£ÄÊµã        
  initOrientationDetection();        
})();        
        
        
})();        
</script>        
</body>        
</html>