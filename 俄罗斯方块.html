<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8" />
  <title>ä¿„ç½—æ–¯æ–¹å—</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
  <style>
    :root{
  --bg:#0e1322;
  --panel:#151a2e;
  --accent:#4f8cff;
  --text:#e7ebf3;
  --muted:#94a3b8;
  --grid:#1d2544;
  --ghost:#7aa2ff55;
  --cell-gap:1;
  --side-ctrl-w: 100px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,"Segoe UI",Roboto,Helvetica,Arial}
a{color:var(--accent);text-decoration:none}
.app{
  display:grid; gap:12px; padding:12px; height:100%;
  grid-template-rows:auto 1fr auto;
}
header, footer{
  display:flex; align-items:center; justify-content:space-between;
  background:var(--panel); border-radius:10px; padding:8px 12px;
  border:1px solid #263057;
}
header .title{font-weight:700; letter-spacing:.3px;}
header .controls{display:flex; gap:8px; flex-wrap:wrap}
button,select,input{
  background:#1b2140; color:var(--text); border:1px solid #2b345d; border-radius:8px;
  padding:8px 10px; font-size:14px; cursor:pointer;
  transition:transform .08s ease, background .15s ease, box-shadow .15s ease;
}
button:hover{background:#232b50}
button:active{transform:translateY(1px)}
button.primary{background:#3563e9; border-color:#3563e9}
button.primary:hover{background:#2f55c8}
button.danger{background:#dc2626; border-color:#dc2626}
button.danger:hover{background:#b91c1c}
.layout{
  display:grid; gap:12px;
  grid-template-columns: 180px 1fr 180px;
  grid-auto-rows: minmax(0,1fr);
  overflow:hidden;
}
.panel{
  background:var(--panel); border-radius:10px; padding:10px; overflow:auto;
  border:1px solid #263057;
}
.stats{display:grid; gap:6px; font-size:14px}
.stat-line{display:flex; justify-content:space-between; color:var(--muted)}
.stat-value{color:var(--text); font-weight:600}
.right .previews{display:flex; flex-direction:column; gap:8px}
.preview-item, .hold-box{
  background:#10142a; border:1px solid #2b3156; border-radius:8px; padding:8px;
  display:flex; justify-content:center; align-items:center;
}
.preview-title{font-size:12px; color:var(--muted); margin-bottom:6px}
.playfield-wrap{
  position:relative; display:flex; justify-content:center; align-items:center; height:100%;
}
canvas.playfield{background:#0b0f23; border:1px solid #2b3156; border-radius:10px; touch-action:none;}
.overlay{
  position:absolute; inset:0; display:none; align-items:center; justify-content:center;
  background:rgba(10,12,24,.65); backdrop-filter: blur(4px);
  z-index:1000;
}
.overlay.visible{display:flex}
.modal{
  width:min(92vw, 820px); max-height:85vh; overflow:auto;
  background:var(--panel); border:1px solid #2b3156; border-radius:12px; padding:16px;
  box-shadow:0 20px 50px rgba(0,0,0,.35);
}
.modal h3{margin:0 0 8px 0}
.grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}
.row{display:flex; gap:10px; align-items:center; margin:6px 0}
.row label{flex:1; color:var(--muted); font-size:14px}
.row input[type="number"], .row select{width:140px}
.modal .actions{display:flex; justify-content:flex-end; gap:8px; margin-top:12px}
.legend{font-size:12px; color:var(--muted); line-height:1.5}
.badges{display:flex; gap:6px; flex-wrap:wrap; font-size:11px; margin-top:6px}
.badge{background:#1a1f3d; border:1px solid #2b3156; color:var(--muted); padding:2px 6px; border-radius:999px}

.mobile-side{
  position:absolute;
  display:none;
  z-index:10;
}

.mobile-left{
  left: 0;
  top: 50%;
  transform: translateY(-50%);
}

.mobile-right{
  right: 0;
  top: 50%;
  transform: translateY(-50%);
}

.mobile-controls .btn,
.mobile-side .btn{
  background:#1b2140; border:2px solid #2b345d; color:var(--text);
  box-shadow:0 3px 0 rgba(0,0,0,.4);
  user-select:none; touch-action:manipulation;
  transition:transform .06s ease, background .12s ease, box-shadow .12s ease;
  font-weight:500; border-radius:10px;
}
.mobile-controls .btn{
  min-width:70px; padding:14px 16px; font-size:15px;
}
.mobile-side .btn{
  display:block; width:calc(var(--side-ctrl-w) - 16px);
  padding:12px 8px; margin:8px; text-align:center; font-size:13px;
}
.mobile-controls .btn[data-act^="rotate"],
.mobile-side .btn[data-act^="rotate"]{
  background:linear-gradient(135deg,#2d3a6e,#1f2847);
  border-color:#4f8cff; color:#4f8cff; font-weight:bold;
  box-shadow:0 3px 0 rgba(79,140,255,.3);
}
.mobile-controls .btn:active,
.mobile-controls .btn.pressed,
.mobile-side .btn:active,
.mobile-side .btn.pressed{
  transform:translateY(2px); box-shadow:0 1px 0 rgba(0,0,0,.5);
}
        
.header-toggle{
  position:fixed;
  top:10px;
  left:50%;
  transform:translateX(-50%);
  z-index:100;
  display:none;
  background:#1b2140;
  color:var(--text);
  border:2px solid #2b345d;
  border-radius:999px;
  padding:10px 16px;
  font-size:13px;
  box-shadow:0 4px 12px rgba(0,0,0,.4);
}
.header-toggle:active{ transform:translateX(-50%) translateY(1px); }
        
.combo-notification {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
  z-index: 1000;
  opacity: 0;
  font-size: 48px;
  font-weight: bold;
  text-shadow: 0 0 10px rgba(0,0,0,0.8), 0 0 20px currentColor;
  white-space: nowrap;
}
        
.combo-notification.show {
  animation: comboAnim 1.2s ease-out forwards;
}
        
@keyframes comboAnim {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.5);
  }
  20% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.3);
  }
  40% {
    transform: translate(-50%, -50%) scale(1.1);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -70%) scale(0.9);
  }
}
        
.combo-1 { color: #4f8cff; }
.combo-2 { color: #10b981; }
.combo-3 { color: #f59e0b; }
.combo-4 {
  color: #ef4444;
  font-size: 64px;
  text-shadow: 0 0 20px rgba(239,68,68,0.8), 0 0 40px rgba(239,68,68,0.6);
}
.combo-tspin {
  color: #a855f7;
  font-size: 56px;
  text-shadow: 0 0 20px rgba(168,85,247,0.8), 0 0 40px rgba(168,85,247,0.6);
}
.combo-b2b {
  color: #f97316;
  font-size: 52px;
  text-shadow: 0 0 20px rgba(249,115,22,0.8), 0 0 40px rgba(249,115,22,0.6);
}
        
.status-indicators {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 8px;
}
.indicator {
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.5px;
  opacity: 0.4;
  transition: opacity 0.3s ease;
}
.indicator.active {
  opacity: 1;
  animation: pulse 1s ease-in-out infinite;
}
.indicator.combo-ind {
  background: linear-gradient(135deg, #4f8cff, #3563e9);
}
.indicator.b2b-ind {
  background: linear-gradient(135deg, #f97316, #ea580c);
}
@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}
        
.mode-selector {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 12px;
  margin: 16px 0;
}
.mode-card {
  background: #1a1f3d;
  border: 2px solid #2b3156;
  border-radius: 10px;
  padding: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}
.mode-card:hover {
  border-color: #4f8cff;
  transform: translateY(-2px);
}
.mode-card.selected {
  border-color: #4f8cff;
  background: #1f2847;
  box-shadow: 0 0 20px rgba(79, 140, 255, 0.3);
}
.mode-card h4 {
  margin: 0 0 6px 0;
  color: var(--accent);
  font-size: 15px;
}
.mode-card p {
  margin: 0;
  font-size: 12px;
  color: var(--muted);
  line-height: 1.4;
}
        
.timer-display {
  font-size: 32px;
  font-weight: bold;
  text-align: center;
  color: var(--accent);
  padding: 12px;
  background: #1a1f3d;
  border-radius: 8px;
  margin: 8px 0;
  font-variant-numeric: tabular-nums;
}
.timer-display.warning {
  color: #f59e0b;
  animation: pulse 1s ease-in-out infinite;
}
.timer-display.danger {
  color: #ef4444;
}
        
.keybind-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin: 12px 0;
}
.keybind-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: #1a1f3d;
  border-radius: 8px;
  border: 1px solid #2b3156;
}
.keybind-label {
  color: var(--muted);
  font-size: 13px;
}
.keybind-button {
  background: #2b345d;
  color: var(--text);
  border: 1px solid #3d4873;
  border-radius: 6px;
  padding: 6px 12px;
  font-size: 12px;
  min-width: 80px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s ease;
}
.keybind-button:hover {
  background: #364070;
}
.keybind-button.listening {
  background: #3563e9;
  border-color: #4f8cff;
  animation: pulse 0.8s ease-in-out infinite;
}
        
.gamepad-indicator {
  display: none;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: #1a1f3d;
  border: 1px solid #2b3156;
  border-radius: 8px;
  font-size: 12px;
  margin: 8px 0;
}
.gamepad-indicator.connected {
  display: flex;
  border-color: #10b981;
}
.gamepad-icon {
  width: 16px;
  height: 16px;
  background: #10b981;
  border-radius: 50%;
  animation: pulse 2s ease-in-out infinite;
}
        
.undo-controls {
  display: none;
  gap: 6px;
  margin-top: 8px;
}
.undo-controls.visible {
  display: flex;
}
.undo-controls button {
  flex: 1;
  padding: 6px;
  font-size: 12px;
}
        
.cheese-preview {
  margin-top: 10px;
  padding: 8px;
  background: #1a1f3d;
  border-radius: 8px;
  border: 1px solid #2b3156;
}
.cheese-preview-title {
  font-size: 11px;
  color: var(--muted);
  margin-bottom: 4px;
}
.cheese-bar {
  height: 6px;
  background: #2b345d;
  border-radius: 3px;
  overflow: hidden;
}
.cheese-progress {
  height: 100%;
  background: linear-gradient(90deg, #10b981, #34d399);
  transition: width 0.3s ease;
}
        
@media (max-width: 980px) and (orientation: portrait){
  .layout{
    grid-template-columns: 1fr;
    grid-template-rows: auto auto auto;
    overflow:auto;
  }
  .right, .left{order:2}
  .center{order:1; min-height:55vh}
          
  .mobile-controls{
    display:flex;
    padding:16px 12px;
  }
  .mobile-controls .btn{
    flex:1 1 calc(25% - 8px);
    min-width:70px;
    max-width:120px;
    padding:16px 12px;
    font-size:14px;
  }
  .mobile-side{display:none}
          
  header, footer{
    position:sticky;
    top:0;
    z-index:50;
  }
          
  .combo-notification {
    font-size: 32px;
  }
  .combo-4 { font-size: 42px; }
  .combo-tspin { font-size: 38px; }
  .combo-b2b { font-size: 36px; }
          
  .header-toggle{ display:none; }
}
        
@media (max-width: 980px) and (orientation: landscape){
  .layout{
    grid-template-columns: 120px 1fr 120px;
    grid-template-rows: 1fr;
    overflow:hidden;
  }
  .left, .right{
    order:initial;
    font-size:12px;
  }
  .center{
    min-height:100%;
  }
          
  header{
    display:none;
  }
  header.header-visible{
    display:flex;
    position:fixed;
    left:10px;
    right:10px;
    top:50px;
    z-index:100;
    box-shadow:0 8px 20px rgba(0,0,0,.5);
  }
  footer{display:none}
        
  .mobile-controls{display:none}
          
  .playfield-wrap{
    padding-left: var(--side-ctrl-w);
    padding-right: var(--side-ctrl-w);
  }
          
  .mobile-side{
    display:block;
  }
          
  .header-toggle{
    display:inline-flex;
    align-items:center;
    gap:6px;
  }
          
  .right {
    display: flex;
    flex-direction: column;
    gap:8px;
    padding:8px;
  }
          
  .right .preview-title {
    order: 1;
    margin-bottom: 4px;
    font-size:11px;
  }
          
  .right .previews {
    order: 2;
    flex:1;
    overflow-y:auto;
  }
          
  .right .previews .preview-item{
    padding:4px;
  }
          
  .right .previews canvas{
    width:100%;
    height:auto;
    max-height:70px;
  }
          
  .left{
    padding:8px;
  }
  .left .hold-box{
    margin-bottom:8px;
    padding:6px;
  }
  .left .preview-title{
    font-size:11px;
  }
  .left .stats{
    font-size:12px;
    gap:4px;
  }
  .left .badges{
    display:none;
  }
          
  .combo-notification {
    font-size: 28px;
  }
  .combo-4 { font-size: 36px; }
  .combo-tspin { font-size: 32px; }
  .combo-b2b { font-size: 30px; }
}
        
@media (max-width: 640px) and (orientation: landscape){
  .layout{
    grid-template-columns: 100px 1fr 100px;
  }
          
  :root{
    --side-ctrl-w: 85px;
  }
          
  .mobile-side .btn{
    padding:10px 6px;
    font-size:12px;
    margin:6px 6px;
  }
          
  .left, .right{
    font-size:11px;
  }
          
  .stat-line{
    font-size:11px;
  }
}
        
.tab-nav {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
  border-bottom: 2px solid #2b3156;
}
.tab-btn {
  background: transparent;
  border: none;
  border-bottom: 2px solid transparent;
  padding: 8px 16px;
  margin-bottom: -2px;
  cursor: pointer;
  color: var(--muted);
  transition: all 0.2s ease;
}
.tab-btn:hover {
  color: var(--text);
  background: transparent;
}
.tab-btn.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
}
.tab-content {
  display: none;
}
.tab-content.active {
  display: block;
}
        
@keyframes screen-shake {
  0%, 100% { transform: translate(0, 0) rotate(0deg); }
  10% { transform: translate(-2px, 1px) rotate(-0.5deg); }
  20% { transform: translate(2px, -1px) rotate(0.5deg); }
  30% { transform: translate(-1px, 2px) rotate(-0.3deg); }
  40% { transform: translate(1px, -2px) rotate(0.3deg); }
  50% { transform: translate(-2px, -1px) rotate(-0.4deg); }
  60% { transform: translate(2px, 1px) rotate(0.4deg); }
  70% { transform: translate(-1px, -2px) rotate(-0.2deg); }
  80% { transform: translate(1px, 2px) rotate(0.2deg); }
  90% { transform: translate(-2px, -1px) rotate(-0.1deg); }
}
        
.playfield-wrap.shake {
  animation: screen-shake 0.5s ease-in-out;
}
        
.playfield-wrap.all-clear {
  animation: allClearFlash 0.8s ease-in-out 3;
}
        
@keyframes hold-fly-in {
  0% {
    opacity: 0;
    transform: translateX(-100px) scale(0.5) rotate(-180deg);
  }
  60% {
    transform: translateX(10px) scale(1.1) rotate(10deg);
  }
  100% {
    opacity: 1;
    transform: translateX(0) scale(1) rotate(0deg);
  }
}
        
@keyframes hold-fly-out {
  0% {
    opacity: 1;
    transform: translateX(0) scale(1) rotate(0deg);
  }
  100% {
    opacity: 0;
    transform: translateX(-100px) scale(0.5) rotate(-180deg);
  }
}
        
.hold-box.animate-in canvas {
  animation: hold-fly-in 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
        
.hold-box.animate-out canvas {
  animation: hold-fly-out 0.4s cubic-bezier(0.6, -0.28, 0.735, 0.045);
}

.hold-box.locked {
  opacity: 0.5;
  filter: grayscale(60%);
}

.hold-box.locked::after {
  content: 'ğŸ”’';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
  pointer-events: none;
}

.hold-box {
  position: relative;
}
        
.background-particles {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
  overflow: hidden;
}
        
.bg-particle {
  position: absolute;
  background: radial-gradient(circle, rgba(79, 140, 255, 0.3), transparent);
  border-radius: 50%;
  animation: float-particle linear infinite;
}
        
@keyframes float-particle {
  0% {
    transform: translateY(0) translateX(0) scale(1);
    opacity: 0;
  }
  10% {
    opacity: 0.6;
  }
  90% {
    opacity: 0.3;
  }
  100% {
    transform: translateY(-100vh) translateX(50px) scale(0.5);
    opacity: 0;
  }
}
        
.playfield.glossy {
  filter: brightness(1.1) contrast(1.05);
}
        
@keyframes level-flash {
  0%, 100% {
    box-shadow: 0 0 0 rgba(79, 140, 255, 0);
  }
  50% {
    box-shadow: 0 0 30px rgba(79, 140, 255, 0.8),
                inset 0 0 20px rgba(79, 140, 255, 0.3);
  }
}
        
.playfield.level-up {
  animation: level-flash 0.6s ease-out;
}
        
.audio-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}
        
.audio-toggle {
  background: #1b2140;
  border: 1px solid #2b345d;
  border-radius: 8px;
  padding: 8px 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 16px;
}
        
.audio-toggle:hover {
  background: #232b50;
  transform: scale(1.05);
}
        
.audio-toggle.muted {
  opacity: 0.5;
  background: #3d1f1f;
}
        
@keyframes allClearFlash {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.8) contrast(1.2); }
}
        
.portrait-warning {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, var(--bg) 0%, #1a1f3d 100%);
  z-index: 10000;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}
        
.portrait-warning.show {
  display: flex;
}
        
.portrait-content {
  text-align: center;
  padding: 40px 20px;
  max-width: 400px;
}
        
.portrait-icon {
  font-size: 100px;
  margin-bottom: 30px;
  animation: rotate-hint 2s ease-in-out infinite;
  filter: drop-shadow(0 0 20px rgba(79, 140, 255, 0.5));
}
        
@keyframes rotate-hint {
  0%, 100% {
    transform: rotate(0deg) scale(1);
  }
  25% {
    transform: rotate(-15deg) scale(1.1);
  }
  50% {
    transform: rotate(0deg) scale(1);
  }
  75% {
    transform: rotate(15deg) scale(1.1);
  }
}
        
.portrait-content h2 {
  font-size: 28px;
  margin: 20px 0;
  color: var(--accent);
  font-weight: 700;
  text-shadow: 0 2px 10px rgba(79, 140, 255, 0.3);
}
        
.portrait-content p {
  font-size: 16px;
  color: var(--muted);
  line-height: 1.8;
  margin-top: 16px;
}
        
@media (max-width: 980px) and (orientation: portrait) {
  .portrait-warning.active {
    display: flex !important;
  }
          
  .portrait-warning.active ~ .app {
    display: none;
  }
}
        
@media (orientation: landscape) {
  .portrait-warning {
    display: none !important;
  }
}
        
.leaderboard-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(10,12,24,.75);
  backdrop-filter: blur(6px);
  z-index: 2000;
}
.leaderboard-overlay.visible {
  display: flex;
}
        
.leaderboard-modal {
  width: min(95vw, 700px);
  max-height: 85vh;
  overflow: auto;
  background: var(--panel);
  border: 1px solid #2b3156;
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 20px 50px rgba(0,0,0,.5);
}
        
.leaderboard-modal h3 {
  margin: 0 0 16px 0;
  text-align: center;
  color: var(--accent);
  font-size: 22px;
}
        
.leaderboard-tabs {
  display: flex;
  gap: 6px;
  margin-bottom: 16px;
  flex-wrap: wrap;
  justify-content: center;
}
        
.leaderboard-tab {
  background: #1b2140;
  border: 1px solid #2b345d;
  color: var(--muted);
  padding: 8px 14px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 13px;
  transition: all 0.2s ease;
}
        
.leaderboard-tab:hover {
  background: #232b50;
}
        
.leaderboard-tab.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}
        
.leaderboard-list {
  background: #10142a;
  border-radius: 10px;
  overflow: hidden;
}
        
.leaderboard-header {
  display: grid;
  grid-template-columns: 50px 1fr 100px 120px;
  gap: 10px;
  padding: 12px 16px;
  background: #1a1f3d;
  font-size: 12px;
  color: var(--muted);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
        
.leaderboard-row {
  display: grid;
  grid-template-columns: 50px 1fr 100px 120px;
  gap: 10px;
  padding: 12px 16px;
  border-top: 1px solid #1d2544;
  font-size: 14px;
  transition: background 0.15s ease;
}
        
.leaderboard-row:hover {
  background: #1a1f3d;
}
        
.leaderboard-row.highlight {
  background: rgba(79, 140, 255, 0.15);
  border-left: 3px solid var(--accent);
}
        
.leaderboard-rank {
  font-weight: 700;
  color: var(--muted);
}
        
.leaderboard-rank.gold { color: #ffd700; }
.leaderboard-rank.silver { color: #c0c0c0; }
.leaderboard-rank.bronze { color: #cd7f32; }
        
.leaderboard-score {
  font-weight: 600;
  color: var(--accent);
}
        
.leaderboard-date {
  color: var(--muted);
  font-size: 12px;
}
        
.leaderboard-empty {
  text-align: center;
  padding: 40px 20px;
  color: var(--muted);
  font-size: 14px;
}
        
.leaderboard-actions {
  display: flex;
  justify-content: space-between;
  margin-top: 16px;
  gap: 10px;
}
        
.stats-panel {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 12px;
  margin-bottom: 16px;
}
        
.stats-card {
  background: #1a1f3d;
  border: 1px solid #2b3156;
  border-radius: 10px;
  padding: 14px;
  text-align: center;
}
        
.stats-card-value {
  font-size: 24px;
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 4px;
}
        
.stats-card-label {
  font-size: 11px;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
        
.resume-prompt {
  background: linear-gradient(135deg, #1a3a5c, #1f2847);
  border: 2px solid var(--accent);
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 16px;
  text-align: center;
}
        
.resume-prompt h4 {
  margin: 0 0 8px 0;
  color: var(--accent);
}
        
.resume-prompt p {
  margin: 0 0 12px 0;
  font-size: 13px;
  color: var(--muted);
}
        
.resume-prompt .actions {
  display: flex;
  gap: 10px;
  justify-content: center;
}
        
.volume-control {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 8px 0;
}
        
.volume-control label {
  flex: 1;
  color: var(--muted);
  font-size: 14px;
}
        
  .volume-slider {
  width: 120px;
  height: 6px;
  -webkit-appearance: none;
  appearance: none;
  background: #2b345d;
  border-radius: 3px;
  outline: none;
}
        
.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: var(--accent);
  border-radius: 50%;
  cursor: pointer;
  transition: transform 0.1s ease;
}
        
.volume-slider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
}
        
@media (max-width: 980px) and (orientation: landscape) {
  .leaderboard-modal {
    max-height: 90vh;
    padding: 12px;
  }
          
  .leaderboard-modal h3 {
    font-size: 18px;
    margin-bottom: 10px;
  }
          
  .leaderboard-header,
  .leaderboard-row {
    grid-template-columns: 40px 1fr 80px 100px;
    padding: 8px 12px;
    font-size: 12px;
  }
          
  .leaderboard-tabs {
    gap: 4px;
    margin-bottom: 10px;
  }
          
  .leaderboard-tab {
    padding: 6px 10px;
    font-size: 11px;
  }
          
  .stats-panel {
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }
          
  .stats-card {
    padding: 10px;
  }
          
  .stats-card-value {
    font-size: 18px;
  }
          
  .stats-card-label {
    font-size: 10px;
  }
}
        
@media (max-width: 980px) and (orientation: portrait) {
  .leaderboard-header,
  .leaderboard-row {
    grid-template-columns: 40px 1fr 70px;
  }
          
  .leaderboard-date {
    display: none;
  }
          
  .stats-panel {
    grid-template-columns: repeat(2, 1fr);
  }
}
        
.countdown-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(10,12,24,.85);
  backdrop-filter: blur(8px);
  z-index: 3000;
}
        
.countdown-overlay.visible {
  display: flex;
}
        
.countdown-content {
  text-align: center;
}
        
.countdown-number {
  font-size: 150px;
  font-weight: 900;
  color: var(--accent);
  text-shadow: 0 0 40px rgba(79, 140, 255, 0.8), 0 0 80px rgba(79, 140, 255, 0.5);
  animation: countdownPulse 0.8s ease-out;
}
        
.countdown-number.go {
  font-size: 120px;
  color: #10b981;
  text-shadow: 0 0 40px rgba(16, 185, 129, 0.8), 0 0 80px rgba(16, 185, 129, 0.5);
}
        
@keyframes countdownPulse {
  0% {
    transform: scale(0.3);
    opacity: 0;
  }
  50% {
    transform: scale(1.2);
    opacity: 1;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}
        
.pause-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(10,12,24,.7);
  backdrop-filter: blur(12px);
  z-index: 2500;
}
        
.pause-overlay.visible {
  display: flex;
}
        
.pause-modal {
  background: var(--panel);
  border: 2px solid var(--accent);
  border-radius: 16px;
  padding: 32px 48px;
  text-align: center;
  box-shadow: 0 0 60px rgba(79, 140, 255, 0.3);
}
        
.pause-modal h2 {
  font-size: 36px;
  margin: 0 0 8px 0;
  color: var(--accent);
}
        
.pause-modal p {
  color: var(--muted);
  margin: 0 0 24px 0;
}
        
.pause-modal .pause-stats {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 16px;
  margin-bottom: 24px;
  padding: 16px;
  background: #10142a;
  border-radius: 10px;
}
        
.pause-modal .pause-stat {
  text-align: center;
}
        
.pause-modal .pause-stat-value {
  font-size: 24px;
  font-weight: bold;
  color: var(--text);
}
        
.pause-modal .pause-stat-label {
  font-size: 11px;
  color: var(--muted);
  text-transform: uppercase;
}
        
.pause-modal .actions {
  display: flex;
  gap: 12px;
  justify-content: center;
}
        
.levelup-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: transparent;
  pointer-events: none;
  z-index: 2800;
}
        
.levelup-overlay.visible {
  display: flex;
  animation: levelupFlash 1.5s ease-out forwards;
}
        
@keyframes levelupFlash {
  0% {
    background: rgba(79, 140, 255, 0.4);
  }
  100% {
    background: transparent;
  }
}
        
.levelup-content {
  text-align: center;
  animation: levelupZoom 1.5s ease-out forwards;
}
        
@keyframes levelupZoom {
  0% {
    transform: scale(0.5) rotate(-10deg);
    opacity: 0;
  }
  20% {
    transform: scale(1.3) rotate(5deg);
    opacity: 1;
  }
  40% {
    transform: scale(1) rotate(0deg);
  }
  100% {
    transform: scale(1.5) translateY(-50px);
    opacity: 0;
  }
}
        
.levelup-text {
  font-size: 48px;
  font-weight: 900;
  color: #ffd700;
  text-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.5);
}
        
.levelup-level {
  font-size: 80px;
  font-weight: 900;
  color: var(--accent);
  text-shadow: 0 0 40px rgba(79, 140, 255, 0.8);
}
        
.gameover-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(10,12,24,.85);
  backdrop-filter: blur(10px);
  z-index: 3500;
}
        
.gameover-overlay.visible {
  display: flex;
}
        
.gameover-modal {
  width: min(95vw, 500px);
  max-height: 90vh;
  overflow: auto;
  background: var(--panel);
  border: 2px solid #ef4444;
  border-radius: 16px;
  padding: 24px;
  text-align: center;
  box-shadow: 0 0 60px rgba(239, 68, 68, 0.3);
}
        
.gameover-modal.victory {
  border-color: #10b981;
  box-shadow: 0 0 60px rgba(16, 185, 129, 0.3);
}
        
.gameover-modal h2 {
  font-size: 32px;
  margin: 0 0 8px 0;
  color: #ef4444;
}
        
.gameover-modal.victory h2 {
  color: #10b981;
}
        
.gameover-modal .subtitle {
  color: var(--muted);
  margin: 0 0 20px 0;
  font-size: 14px;
}
        
.gameover-stats-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
  margin-bottom: 20px;
}
        
.gameover-stat-card {
  background: #10142a;
  border: 1px solid #2b3156;
  border-radius: 10px;
  padding: 14px;
}
        
.gameover-stat-card.highlight {
  border-color: var(--accent);
  background: rgba(79, 140, 255, 0.1);
}
        
.gameover-stat-value {
  font-size: 28px;
  font-weight: bold;
  color: var(--text);
}
        
.gameover-stat-label {
  font-size: 11px;
  color: var(--muted);
  text-transform: uppercase;
  margin-top: 4px;
}
        
.gameover-rank {
  background: linear-gradient(135deg, #ffd700, #f59e0b);
  color: #000;
  padding: 12px 20px;
  border-radius: 10px;
  margin-bottom: 20px;
  font-weight: bold;
}
        
.gameover-rank.new-record {
  animation: newRecordPulse 1s ease-in-out infinite;
}
        
@keyframes newRecordPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}
        
.gameover-actions {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
        
.key-feedback {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 8px;
  z-index: 100;
  pointer-events: none;
}
        
.key-indicator {
  background: #1b2140;
  border: 2px solid #2b345d;
  border-radius: 8px;
  padding: 8px 14px;
  font-size: 12px;
  color: var(--muted);
  transition: all 0.1s ease;
  min-width: 50px;
  text-align: center;
}
        
.key-indicator.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
  transform: scale(1.1);
  box-shadow: 0 0 15px rgba(79, 140, 255, 0.5);
}
        
.key-indicator.left.active { background: #3563e9; border-color: #3563e9; }
.key-indicator.right.active { background: #3563e9; border-color: #3563e9; }
.key-indicator.rotate.active { background: #a855f7; border-color: #a855f7; }
.key-indicator.drop.active { background: #10b981; border-color: #10b981; }
.key-indicator.hard.active { background: #ef4444; border-color: #ef4444; }
.key-indicator.hold.active { background: #f59e0b; border-color: #f59e0b; }
        
@media (max-width: 980px) and (orientation: landscape) {
  .key-feedback {
    display: none;
  }
          
  .pause-modal .pause-stats {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }
          
  .pause-modal {
    padding: 20px 30px;
  }
          
  .pause-modal h2 {
    font-size: 28px;
  }
          
  .gameover-modal {
    max-height: 85vh;
    padding: 16px;
  }
          
  .gameover-stats-grid {
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }
          
  .gameover-stat-card {
    padding: 10px;
  }
          
  .gameover-stat-value {
    font-size: 20px;
  }
          
  .levelup-text {
    font-size: 36px;
  }
          
  .levelup-level {
    font-size: 60px;
  }
          
  .countdown-number {
    font-size: 100px;
  }
          
  .countdown-number.go {
    font-size: 80px;
  }
}
        
@media (max-width: 980px) and (orientation: portrait) {
  .key-feedback {
    bottom: 10px;
    gap: 4px;
  }
          
  .key-indicator {
    padding: 6px 10px;
    font-size: 10px;
    min-width: 40px;
  }
          
  .gameover-stats-grid {
    grid-template-columns: 1fr 1fr;
  }
}

.lock-progress-bar {
  position: absolute;
  bottom: 2px;
  left: 2px;
  right: 2px;
  height: 6px;
  background: rgba(30, 40, 80, 0.8);
  border-radius: 3px;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.lock-progress-fill {
  height: 100%;
  transition: width 0.05s linear, background-color 0.2s ease;
  border-radius: 2px;
}

.lock-progress-fill.safe {
  background: linear-gradient(90deg, #10b981, #34d399);
  box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
}

.lock-progress-fill.warning {
  background: linear-gradient(90deg, #f59e0b, #fbbf24);
  box-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
}

.lock-progress-fill.danger {
  background: linear-gradient(90deg, #ef4444, #f87171);
  box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
  animation: dangerPulse 0.3s ease-in-out infinite;
}

@keyframes dangerPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

@keyframes pieceBlink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.piece-locking {
  animation: pieceBlink 0.2s ease-in-out infinite;
}
        
  </style>
</head>
<body>
<div class="app">
<div id="portraitWarning" class="portrait-warning">
  <div class="portrait-content">
    <div class="portrait-icon">ğŸ“±</div>
    <h2>è¯·æ—‹è½¬æ‚¨çš„è®¾å¤‡</h2>
    <p>ä¸ºäº†è·å¾—æœ€ä½³æ¸¸æˆä½“éªŒ<br>è¯·å°†è®¾å¤‡æ¨ªå‘æ”¾ç½®</p>
  </div>
</div>
  <header id="topHeader">
    <div class="title">ä¿„ç½—æ–¯æ–¹å—</div>
    <div class="controls">
  <button id="btnPlayPause" class="primary">â–¶ å¼€å§‹</button>
  <button id="btnRestart">ğŸ”„ é‡æ–°å¼€å§‹</button>
  <button id="btnSettings">âš™ è®¾ç½®</button>
  <button id="btnLeaderboard">ğŸ† æ’è¡Œæ¦œ</button>
</div>
  </header>
          
  <button class="header-toggle" id="btnHeaderToggle">â˜° èœå•</button>
          
  <div class="layout">
    <div class="panel left">
      <div class="preview-title">æš‚å­˜ (C/Shift)</div>
      <div class="hold-box" style="margin-bottom:10px">
        <canvas id="hold" width="140" height="140"></canvas>
      </div>
                
      <div class="stat-line" style="margin-bottom: 8px;">
        <span>æ¨¡å¼</span>
        <strong class="stat-value" id="modeDisplay">é©¬æ‹‰æ¾</strong>
      </div>
          
      <div id="timerContainer" style="display:none;">
        <div class="timer-display" id="timerDisplay">00:00.00</div>
      </div>
          
      <div id="cheeseContainer" class="cheese-preview" style="display:none;">
        <div class="cheese-preview-title">åƒåœ¾è¡Œå‰©ä½™</div>
        <div class="stat-line">
          <span>å‰©ä½™</span>
          <strong class="stat-value" id="cheeseRemaining">0</strong>
        </div>
        <div class="cheese-bar">
          <div class="cheese-progress" id="cheeseProgress" style="width: 0%"></div>
        </div>
      </div>
          
      <div class="gamepad-indicator" id="gamepadIndicator">
        <div class="gamepad-icon"></div>
        <span id="gamepadName">æ‰‹æŸ„å·²è¿æ¥</span>
      </div>
          
      <div class="stats">
        <div class="stat-line" id="scoreRow">
          <span>åˆ†æ•°</span>
          <strong class="stat-value" id="score">0</strong>
        </div>
        <div class="stat-line">
          <span>çº§åˆ«</span>
          <strong class="stat-value" id="level">1</strong>
        </div>
        <div class="stat-line">
          <span>è¡Œæ•°</span>
          <strong class="stat-value" id="lines">0</strong>
        </div>
        <div class="stat-line">
          <span>è¿å‡»</span>
          <strong class="stat-value" id="combo">0</strong>
        </div>
                  
        <div class="status-indicators">
          <div class="indicator combo-ind" id="comboInd">COMBO</div>
          <div class="indicator b2b-ind" id="b2bInd">B2B</div>
        </div>
          
        <div class="undo-controls" id="undoControls">
          <button id="btnUndo" title="æ’¤é”€ (Ctrl+Z)">â†¶ æ’¤é”€</button>
          <button id="btnRedo" title="é‡åš (Ctrl+Y)">â†· é‡åš</button>
        </div>
          
        <div class="badges">
          <span class="badge">è‡ªå®šä¹‰é”®ä½</span>
          <span class="badge">æ‰‹æŸ„æ”¯æŒ</span>
          <span class="badge">éœ‡åŠ¨åé¦ˆ</span>
          <span class="badge">å¤šç§æ¨¡å¼</span>
        </div>
      </div>
    </div>
          
    <div class="panel center">
      <div class="playfield-wrap">
        <div class="mobile-side mobile-left" id="mobileLeft">
          <div class="btn" data-act="left">â† å·¦</div>
          <div class="btn" data-act="rotateLeft">â†º å·¦æ—‹</div>
          <div class="btn" data-act="soft">â†“ è½¯é™</div>
          <div class="btn" data-act="hold">Hold</div>
        </div>
                  
        <canvas id="playfield" class="playfield" width="300" height="600"></canvas>
                  
        <div class="mobile-side mobile-right" id="mobileRight">
          <div class="btn" data-act="right">å³ â†’</div>
          <div class="btn" data-act="rotateRight">â†» å³æ—‹</div>
          <div class="btn" data-act="hard">â¤“ ç¡¬é™</div>
          <div class="btn" data-act="pause">â¸ æš‚åœ</div>
        </div>
      </div>
          
          
        <div class="combo-notification" id="comboNotif"></div>
          
        <div class="overlay" id="overlay">
          <div class="modal">
            <h3 id="modalTitle">æ¸¸æˆè®¾ç½®</h3>
                      
            <div class="tab-nav">
              <button class="tab-btn active" data-tab="mode">æ¸¸æˆæ¨¡å¼</button>
              <button class="tab-btn" data-tab="general">å¸¸è§„è®¾ç½®</button>
              <button class="tab-btn" data-tab="controls">æ§åˆ¶è®¾ç½®</button>
            </div>
          
            <div class="tab-content active" id="tabMode">
              <div class="mode-selector">
                <div class="mode-card selected" data-mode="marathon">
                  <h4>ğŸƒ é©¬æ‹‰æ¾æ¨¡å¼</h4>
                  <p>ç»å…¸ç©æ³•ï¼Œéšåˆ†æ•°/è¡Œæ•°å‡çº§ï¼ŒæŒ‘æˆ˜é«˜åˆ†</p>
                </div>
                <div class="mode-card" data-mode="sprint">
                  <h4>âš¡ 40è¡Œç«é€Ÿ</h4>
                  <p>æ¶ˆé™¤40è¡Œï¼Œè®°å½•æœ€å¿«æ—¶é—´ï¼Œç«æŠ€é¦–é€‰</p>
                </div>
                <div class="mode-card" data-mode="ultra">
                  <h4>â±ï¸ é™æ—¶æ‰“åˆ†</h4>
                  <p>2åˆ†é’Ÿé™æ—¶ï¼Œè¿½æ±‚æœ€é«˜åˆ†æ•°</p>
                </div>
                <div class="mode-card" data-mode="cheese">
                  <h4>â›ï¸ æŒ–æ˜æ¨¡å¼</h4>
                  <p>æ¸…é™¤é¢„å¡«å……çš„åƒåœ¾è¡Œ,è€ƒéªŒæŒ–æ˜æŠ€å·§</p>
                </div>
                <div class="mode-card" data-mode="master">
                  <h4>ğŸ‘‘ å¤§å¸ˆæ¨¡å¼</h4>
                  <p>20Gé‡åŠ›ï¼ŒæçŸ­é”å»¶ï¼Œç¡¬æ ¸æŒ‘æˆ˜</p>
                </div>
                <div class="mode-card" data-mode="practice">
                  <h4>ğŸ“š ç»ƒä¹ æ¨¡å¼</h4>
                  <p>æ”¯æŒæ’¤é”€/é‡åšï¼Œé€‚åˆç»ƒä¹ æŠ€å·§</p>
                </div>
              </div>
          
              <div id="cheeseSettings" style="display:none; margin-top:12px;">
                <div class="row">
                  <label>åƒåœ¾è¡Œæ•°é‡</label>
                  <input id="cfgCheeseLines" type="number" min="5" max="18" value="10">
                </div>
              </div>
          
              <div id="ultraSettings" style="display:none; margin-top:12px;">
                <div class="row">
                  <label>æ—¶é—´é™åˆ¶ï¼ˆç§’ï¼‰</label>
                  <input id="cfgUltraTime" type="number" min="60" max="300" value="120">
                </div>
              </div>
            </div>
          
            <div class="tab-content" id="tabGeneral">
              <div class="grid2">
                <div class="row">
                  <label>åˆ—æ•°ï¼ˆå®½åº¦ï¼‰</label>
                  <input id="cfgCols" type="number" min="6" max="20" step="1" value="10">
                </div>
                <div class="row">
                  <label>è¡Œæ•°ï¼ˆé«˜åº¦ï¼‰</label>
                  <input id="cfgRows" type="number" min="12" max="40" step="1" value="20">
                </div>
                <div class="row">
                  <label>é¢„è§ˆæ•°é‡</label>
                  <input id="cfgPreview" type="number" min="1" max="6" step="1" value="5">
                </div>
                <div class="row">
                  <label>èµ·å§‹çº§åˆ«</label>
                  <input id="cfgStartLevel" type="number" min="1" max="20" step="1" value="1">
                </div>
                <div class="row">
                  <label>æ˜¾ç¤ºé˜´å½±ï¼ˆGhostï¼‰</label>
                  <select id="cfgGhost"><option value="on">å¼€å¯</option><option value="off">å…³é—­</option></select>
                </div>
                <div class="row">
                  <label>é”å»¶è¿Ÿï¼ˆmsï¼‰</label>
                  <input id="cfgLockDelay" type="number" min="200" max="2000" step="50" value="1500">
                </div>
                <div class="row">
                  <label>DAS å»¶è¿Ÿï¼ˆmsï¼‰</label>
                  <input id="cfgDAS" type="number" min="0" max="300" step="10" value="120">
                </div>
                <div class="row">
                  <label>ARR é€Ÿåº¦ï¼ˆmsï¼‰</label>
                  <input id="cfgARR" type="number" min="0" max="100" step="5" value="20">
                </div>
                <div class="row">
                  <label>æ–¹å—é…è‰²</label>
                  <select id="cfgSkin">
                    <option value="classic">ç»å…¸</option>
                    <option value="pastel">é©¬å¡é¾™</option>
                    <option value="neon">éœ“è™¹</option>
                  </select>
                </div>
                <div class="row">
                  <label>éœ‡åŠ¨åé¦ˆ</label>
                  <select id="cfgVibration">
                    <option value="on">å¼€å¯</option>
                    <option value="off">å…³é—­</option>
                  </select>
                </div>
                <div class="row">
                   <label>éŸ³æ•ˆéŸ³é‡</label>
                   <input type="range" class="volume-slider" id="cfgSFXVolume" min="0" max="100" value="50">
                </div>
                <div class="row">
                  <label>èƒŒæ™¯éŸ³ä¹</label>
                  <input type="range" class="volume-slider" id="cfgMusicVolume" min="0" max="100" value="30">
                </div>
              </div>
            </div>
          
            <div class="tab-content" id="tabControls">
              <div style="margin-bottom: 12px;">
                <button id="btnResetKeys" class="danger" style="width: 100%;">æ¢å¤é»˜è®¤é”®ä½</button>
              </div>
              <div class="keybind-grid" id="keybindGrid"></div>
              <div class="legend" style="margin-top: 12px;">
                <strong>æç¤ºï¼š</strong>ç‚¹å‡»æŒ‰é’®åæŒ‰ä¸‹æƒ³è¦ç»‘å®šçš„é”®ã€‚æ”¯æŒé”®ç›˜å’Œæ‰‹æŸ„æŒ‰é’®ã€‚
              </div>
            </div>
          
            <div class="actions">
              <button id="btnCloseSettings">å–æ¶ˆ</button>
              <button id="btnSaveStart" class="primary">ä¿å­˜å¹¶å¼€å§‹</button>
            </div>
          </div>
        </div>
          
          
      <div class="mobile-controls" id="mobileControls">
        <div class="btn" data-act="left">â† å·¦</div>
        <div class="btn" data-act="right">å³ â†’</div>
        <div class="btn" data-act="rotateLeft">â†º å·¦æ—‹</div>
        <div class="btn" data-act="rotateRight">â†» å³æ—‹</div>
        <div class="btn" data-act="soft">â†“ è½¯é™</div>
        <div class="btn" data-act="hard">â¤“ ç¡¬é™</div>
        <div class="btn" data-act="hold">Hold</div>
        <div class="btn" data-act="pause">â¸ æš‚åœ</div>
      </div>
    </div>
          
    <div class="panel right">
      <div class="preview-title">ä¸‹ä¸€ä¸ªæ–¹å—é¢„è§ˆ</div>
      <div class="previews" id="previews"></div>
    </div>
  </div>
          
<div class="countdown-overlay" id="countdownOverlay">
  <div class="countdown-content">
    <div class="countdown-number" id="countdownNumber">3</div>
  </div>
</div>
          
<div class="pause-overlay" id="pauseOverlay">
  <div class="pause-modal">
    <h2>â¸ æ¸¸æˆæš‚åœ</h2>
    <p>ä¼‘æ¯ä¸€ä¸‹ï¼Œå‡†å¤‡å¥½å†ç»§ç»­ï¼</p>
    <div class="pause-stats">
      <div class="pause-stat">
        <div class="pause-stat-value" id="pauseScore">0</div>
        <div class="pause-stat-label">åˆ†æ•°</div>
      </div>
      <div class="pause-stat">
        <div class="pause-stat-value" id="pauseLines">0</div>
        <div class="pause-stat-label">è¡Œæ•°</div>
      </div>
      <div class="pause-stat">
        <div class="pause-stat-value" id="pauseLevel">1</div>
        <div class="pause-stat-label">ç­‰çº§</div>
      </div>
    </div>
    <div class="actions">
      <button id="btnPauseResume" class="primary">â–¶ ç»§ç»­æ¸¸æˆ</button>
      <button id="btnPauseRestart">ğŸ”„ é‡æ–°å¼€å§‹</button>
      <button id="btnPauseSettings">âš™ è®¾ç½®</button>
    </div>
  </div>
</div>
          
<div class="levelup-overlay" id="levelupOverlay">
  <div class="levelup-content">
    <div class="levelup-text">LEVEL UP!</div>
    <div class="levelup-level" id="levelupLevel">2</div>
  </div>
</div>
          
<div class="gameover-overlay" id="gameoverOverlay">
  <div class="gameover-modal" id="gameoverModal">
    <h2 id="gameoverTitle">ğŸ® æ¸¸æˆç»“æŸ</h2>
    <p class="subtitle" id="gameoverSubtitle">å†æ¥å†å‰ï¼</p>
              
    <div id="gameoverRank" class="gameover-rank" style="display:none;">
      ğŸ† æ’è¡Œæ¦œç¬¬ <span id="gameoverRankNum">1</span> åï¼
    </div>
              
    <div class="gameover-stats-grid">
      <div class="gameover-stat-card highlight">
        <div class="gameover-stat-value" id="goScore">0</div>
        <div class="gameover-stat-label">æœ€ç»ˆå¾—åˆ†</div>
      </div>
      <div class="gameover-stat-card">
        <div class="gameover-stat-value" id="goLines">0</div>
        <div class="gameover-stat-label">æ¶ˆé™¤è¡Œæ•°</div>
      </div>
      <div class="gameover-stat-card">
        <div class="gameover-stat-value" id="goLevel">1</div>
        <div class="gameover-stat-label">è¾¾åˆ°ç­‰çº§</div>
      </div>
      <div class="gameover-stat-card">
        <div class="gameover-stat-value" id="goTime">00:00</div>
        <div class="gameover-stat-label">æ¸¸æˆæ—¶é•¿</div>
      </div>
      <div class="gameover-stat-card">
        <div class="gameover-stat-value" id="goTetrises">0</div>
        <div class="gameover-stat-label">Tetrisæ¬¡æ•°</div>
      </div>
      <div class="gameover-stat-card">
        <div class="gameover-stat-value" id="goMaxCombo">0</div>
        <div class="gameover-stat-label">æœ€é«˜è¿å‡»</div>
      </div>
    </div>
              
    <div class="gameover-actions">
      <button id="btnGameoverRestart" class="primary">ğŸ”„ é‡æ–°å¼€å§‹</button>
      <button id="btnGameoverLeaderboard">ğŸ† æŸ¥çœ‹æ’è¡Œæ¦œ</button>
      <button id="btnGameoverSettings">âš™ è¿”å›è®¾ç½®</button>
    </div>
  </div>
</div>
          
<div class="key-feedback" id="keyFeedback">
  <div class="key-indicator left" data-key="left">â†</div>
  <div class="key-indicator right" data-key="right">â†’</div>
  <div class="key-indicator rotate" data-key="rotate">â†»</div>
  <div class="key-indicator drop" data-key="soft">â†“</div>
  <div class="key-indicator hard" data-key="hard">â¤“</div>
  <div class="key-indicator hold" data-key="hold">H</div>
</div>
          
<div class="leaderboard-overlay" id="leaderboardOverlay">
  <div class="leaderboard-modal">
    <h3>ğŸ† æœ¬åœ°æ’è¡Œæ¦œ</h3>
              
    <div class="stats-panel" id="globalStats">
      <div class="stats-card">
        <div class="stats-card-value" id="statTotalGames">0</div>
        <div class="stats-card-label">æ€»æ¸¸æˆæ¬¡æ•°</div>
      </div>
      <div class="stats-card">
        <div class="stats-card-value" id="statTotalLines">0</div>
        <div class="stats-card-label">æ€»æ¶ˆé™¤è¡Œæ•°</div>
      </div>
      <div class="stats-card">
        <div class="stats-card-value" id="statTotalScore">0</div>
        <div class="stats-card-label">ç´¯è®¡æ€»åˆ†</div>
      </div>
      <div class="stats-card">
        <div class="stats-card-value" id="statPlayTime">0h</div>
        <div class="stats-card-label">æ¸¸æˆæ—¶é•¿</div>
      </div>
      <div class="stats-card">
        <div class="stats-card-value" id="statTetrises">0</div>
        <div class="stats-card-label">Tetrisæ¬¡æ•°</div>
      </div>
      <div class="stats-card">
        <div class="stats-card-value" id="statTSpins">0</div>
        <div class="stats-card-label">T-Spinæ¬¡æ•°</div>
      </div>
    </div>
              
    <div class="leaderboard-tabs" id="leaderboardTabs">
      <button class="leaderboard-tab active" data-mode="marathon">é©¬æ‹‰æ¾</button>
      <button class="leaderboard-tab" data-mode="sprint">40è¡Œç«é€Ÿ</button>
      <button class="leaderboard-tab" data-mode="ultra">é™æ—¶æ‰“åˆ†</button>
      <button class="leaderboard-tab" data-mode="cheese">æŒ–æ˜æ¨¡å¼</button>
      <button class="leaderboard-tab" data-mode="master">å¤§å¸ˆæ¨¡å¼</button>
    </div>
              
    <div class="leaderboard-list">
      <div class="leaderboard-header">
        <div>æ’å</div>
        <div>ç©å®¶</div>
        <div id="scoreHeader">åˆ†æ•°</div>
        <div>æ—¥æœŸ</div>
      </div>
      <div id="leaderboardContent">
        <div class="leaderboard-empty">æš‚æ— è®°å½•ï¼Œå¿«æ¥åˆ›é€ å†å²ï¼</div>
      </div>
    </div>
              
    <div class="leaderboard-actions">
      <button id="btnClearLeaderboard" class="danger">æ¸…ç©ºæ’è¡Œæ¦œ</button>
      <button id="btnCloseLeaderboard" class="primary">å…³é—­</button>
    </div>
  </div>
</div>
          
          
  <footer>
    <div>ä¸“ä¸šç«æŠ€ç‰ˆï¼šå¤šæ¨¡å¼ | è‡ªå®šä¹‰é”®ä½ | æ‰‹æŸ„æ”¯æŒ | éœ‡åŠ¨åé¦ˆ</div>
  </footer>
</div>
      
<script>
(()=>{

class StorageManager {
  constructor() {
    this.STORAGE_KEYS = {
      SETTINGS: 'tetris_settings',
      STATISTICS: 'tetris_statistics',
      KEYBINDINGS: 'tetris_keybindings',
      LEADERBOARD: 'tetris_leaderboard',
      GAME_PROGRESS: 'tetris_progress'
    };
  }
        
  save(key, data) {
    try {
      localStorage.setItem(key, JSON.stringify(data));
      return true;
    } catch (e) {
      console.warn('ä¿å­˜æ•°æ®å¤±è´¥:', e);
      return false;
    }
  }
        
  load(key, defaultValue = null) {
    try {
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : defaultValue;
    } catch (e) {
      console.warn('è¯»å–æ•°æ®å¤±è´¥:', e);
      return defaultValue;
    }
  }
        
  remove(key) {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (e) {
      return false;
    }
  }
        
  saveSettings(settings) {
    return this.save(this.STORAGE_KEYS.SETTINGS, settings);
  }
        
  loadSettings() {
    return this.load(this.STORAGE_KEYS.SETTINGS, {
      cols: 10,
      rows: 20,
      previewCount: 5,
      startLevel: 1,
      ghostEnabled: true,
      lockDelay: 1500,
      das: 120,
      arr: 20,
      skin: 'classic',
      vibration: true,
      sfxVolume: 50,
      musicVolume: 30,
      gameMode: 'marathon',
      cheeseLines: 10,
      ultraTime: 120
    });
  }
        
  saveStatistics(stats) {
    return this.save(this.STORAGE_KEYS.STATISTICS, stats);
  }
        
  loadStatistics() {
    return this.load(this.STORAGE_KEYS.STATISTICS, {
      totalGames: 0,
      totalLines: 0,
      totalScore: 0,
      totalPlayTime: 0,
      highestCombo: 0,
      mostLinesInGame: 0,
      tetrises: 0,
      tSpins: 0,
      perfectClears: 0
    });
  }
        
  updateStatistics(gameData) {
    const stats = this.loadStatistics();
    stats.totalGames++;
    stats.totalLines += gameData.lines || 0;
    stats.totalScore += gameData.score || 0;
    stats.totalPlayTime += gameData.playTime || 0;
    stats.highestCombo = Math.max(stats.highestCombo, gameData.maxCombo || 0);
    stats.mostLinesInGame = Math.max(stats.mostLinesInGame, gameData.lines || 0);
    stats.tetrises += gameData.tetrises || 0;
    stats.tSpins += gameData.tSpins || 0;
    stats.perfectClears += gameData.perfectClears || 0;
    this.saveStatistics(stats);
    return stats;
  }
        
  saveKeybindings(bindings) {
    return this.save(this.STORAGE_KEYS.KEYBINDINGS, bindings);
  }
        
  loadKeybindings() {
    return this.load(this.STORAGE_KEYS.KEYBINDINGS, null);
  }
        
  saveLeaderboard(leaderboard) {
    return this.save(this.STORAGE_KEYS.LEADERBOARD, leaderboard);
  }
        
  loadLeaderboard() {
    return this.load(this.STORAGE_KEYS.LEADERBOARD, {
      marathon: [],
      sprint: [],
      ultra: [],
      cheese: [],
      master: []
    });
  }
        
  addToLeaderboard(mode, entry) {
    const leaderboard = this.loadLeaderboard();
    if (!leaderboard[mode]) {
        leaderboard[mode] = [];
    }
    entry.date = new Date().toISOString();
    entry.id = Date.now();
    leaderboard[mode].push(entry);
    if (mode === 'sprint' || mode === 'cheese') {
        leaderboard[mode].sort((a, b) => (a.time || Infinity) - (b.time || Infinity));
    } else {
        leaderboard[mode].sort((a, b) => (b.score || 0) - (a.score || 0));
    }
    leaderboard[mode] = leaderboard[mode].slice(0, 20);
    this.saveLeaderboard(leaderboard);
    const rank = leaderboard[mode].findIndex(e => e.id === entry.id) + 1;
    return rank;
}
clearLeaderboard(mode = null) {
    if (mode) {
        const leaderboard = this.loadLeaderboard();
        leaderboard[mode] = [];
        this.saveLeaderboard(leaderboard);
    } else {
        this.saveLeaderboard({
            marathon: [],
            sprint: [],
            ultra: [],
            cheese: [],
            master: []
        });
    }
}
saveGameProgress(progress) {
    return this.save(this.STORAGE_KEYS.GAME_PROGRESS, progress);
}
loadGameProgress() {
    return this.load(this.STORAGE_KEYS.GAME_PROGRESS, null);
}
clearGameProgress() {
    return this.remove(this.STORAGE_KEYS.GAME_PROGRESS);
}
hasGameProgress() {
    return this.loadGameProgress() !== null;
}
}
let storageManager = null;
let sessionStats = {
    tetrises: 0,
    tSpins: 0,
    perfectClears: 0,
    maxCombo: 0,
    startTime: 0
};
let isCountingDown = false;
function showCountdown(callback) {
    isCountingDown = true;
    countdownOverlay.classList.add('visible');
    const sequence = ['3', '2', '1', 'GO!'];
    let index = 0;
    function showNext() {
        if (index >= sequence.length) {
            countdownOverlay.classList.remove('visible');
            isCountingDown = false;
            if (callback) callback();
            return;
        }
        const text = sequence[index];
        countdownNumber.textContent = text;
        countdownNumber.className = 'countdown-number' + (text === 'GO!' ? ' go' : '');
        if (audioSystem) {
            if (text === 'GO!') {
                audioSystem.playSound('countdownGo');
            } else {
                audioSystem.playSound('countdown');
            }
        }
        vibrate(text === 'GO!' ? 30 : 15);
        index++;
        setTimeout(showNext, text === 'GO!' ? 600 : 800);
    }
    showNext();
}
function showPauseMenu() {
    pauseScore.textContent = score.toLocaleString();
    pauseLines.textContent = lines;
    pauseLevel.textContent = level;
    pauseOverlay.classList.add('visible');
}
function hidePauseMenu() {
    pauseOverlay.classList.remove('visible');
}
function showLevelUpAnimation(newLevel) {
    levelupLevel.textContent = newLevel;
    levelupOverlay.classList.add('visible');
    for (let i = 0; i < 30; i++) {
        setTimeout(() => {
            const x = Math.random() * cvs.width;
            const y = Math.random() * cvs.height;
            const colors = ['#ffd700', '#4f8cff', '#10b981', '#a855f7'];
            particles.push(new Particle(x, y, colors[Math.floor(Math.random() * colors.length)], 'spark'));
        }, i * 30);
    }
    setTimeout(() => {
        levelupOverlay.classList.remove('visible');
    }, 1500);
}
function showGameOverStats(message, isVictory, rank) {
  const playTime = Date.now() - sessionStats.startTime;

  if (isVictory) {
    gameoverTitle.textContent = 'ğŸ‰ ' + (message || 'æ­å–œå®Œæˆï¼');
    gameoverModal.classList.add('victory');
    gameoverSubtitle.textContent = 'å¤ªæ£’äº†ï¼ä½ åšåˆ°äº†ï¼';
  } else {
    gameoverTitle.textContent = 'ğŸ’€ ' + (message || 'æ¸¸æˆç»“æŸ');
    gameoverModal.classList.remove('victory');
    gameoverSubtitle.textContent = 'å†æ¥å†å‰ï¼';
  }

  goScore.textContent = score.toLocaleString();
  goLines.textContent = lines;
  goLevel.textContent = level;
  goTime.textContent = formatTime(playTime).split('.')[0];
  goTetrises.textContent = sessionStats.tetrises;
  goMaxCombo.textContent = sessionStats.maxCombo;

  if (rank && rank <= 10) {
    gameoverRank.style.display = 'block';
    gameoverRankNum.textContent = rank;
    if (rank <= 3) {
      gameoverRank.classList.add('new-record');
    } else {
      gameoverRank.classList.remove('new-record');
    }
  } else {
    gameoverRank.style.display = 'none';
  }

  gameoverOverlay.classList.add('visible');
}

function hideGameOverStats() {
    gameoverOverlay.classList.remove('visible');
}
const keyIndicatorMap = {
    'moveLeft': 'left',
    'moveRight': 'right',
    'rotateRight': 'rotate',
    'rotateLeft': 'rotate',
    'softDrop': 'soft',
    'hardDrop': 'hard',
    'hold': 'hold'
};
function highlightKey(action) {
    const indicatorKey = keyIndicatorMap[action];
    if (!indicatorKey) return;
    const indicator = keyFeedback.querySelector(`[data-key="${indicatorKey}"]`);
    if (indicator) {
        indicator.classList.add('active');
        setTimeout(() => {
            indicator.classList.remove('active');
        }, 150);
    }
}
let wasPortraitPaused = false;
function checkOrientation() {
    const portraitWarning = document.getElementById('portraitWarning');
    if (!portraitWarning) return;
    const isMobile = window.innerWidth <= 980;
    const isPortrait = window.innerHeight > window.innerWidth;
    if (isMobile && isPortrait) {
        portraitWarning.classList.add('show');
        portraitWarning.classList.add('active');
        if (running && !paused && !gameOver) {
            togglePause();
            wasPortraitPaused = true;
        }
    } else {
        const wasShowing = portraitWarning.classList.contains('show');
        portraitWarning.classList.remove('show');
        portraitWarning.classList.remove('active');
        if (wasShowing && wasPortraitPaused && running && paused && !gameOver) {
            togglePause();
            wasPortraitPaused = false;
        }
    }
}
function initOrientationDetection() {
    window.addEventListener('orientationchange', () => {
        setTimeout(checkOrientation, 100);
    });
    window.addEventListener('resize', checkOrientation);
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            setTimeout(checkOrientation, 100);
        }
    });
    setTimeout(checkOrientation, 100);
}
class AudioSystem {
  constructor() {
    this.enabled = true;
    this.musicVolume = 0.3;
    this.sfxVolume = 0.5;
    this.sounds = {};
    this.currentBGM = null;

    this.audioContext = null;
    this.bgmInterval = null;

    this._unlocked = false;
    this._initFailed = false;

    this.generateSounds();
  }

  initSounds() {
    if (this.audioContext || this._initFailed) return;
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) {
        this._initFailed = true;
        return;
      }
      this.audioContext = new Ctx();
    } catch (e) {
      this._initFailed = true;
      this.audioContext = null;
    }
  }

  unlock() {
    if (this._unlocked) return true;
    this.initSounds();
    if (!this.audioContext) return false;

    const ctx = this.audioContext;
    const tryResume = () => {
      if (ctx.state === 'suspended') return ctx.resume();
      return Promise.resolve();
    };

    return tryResume()
      .then(() => {
        this._unlocked = true;
        return true;
      })
      .catch(() => false);
  }

  generateSounds() {
    this.soundConfigs = {
      move: { freq: 200, duration: 0.05, type: 'square' },
      rotate: { freq: 400, duration: 0.08, type: 'sine' },
      softDrop: { freq: 150, duration: 0.03, type: 'triangle' },
      hardDrop: { freq: 100, duration: 0.15, type: 'sawtooth', envelope: 'punch' },
      lock: { freq: 300, duration: 0.1, type: 'square' },
      lineClear1: { freq: 440, duration: 0.2, type: 'sine' },
      lineClear2: { freq: 554, duration: 0.25, type: 'sine' },
      lineClear3: { freq: 659, duration: 0.3, type: 'sine' },
      lineClear4: { freq: 880, duration: 0.4, type: 'sine', envelope: 'swell' },
      tetris: {
        freq: [523, 659, 784, 1046],
        duration: 0.6,
        type: 'sine',
        envelope: 'arpeggio'
      },
      hold: { freq: 350, duration: 0.12, type: 'triangle' },
      levelUp: {
        freq: [440, 554, 659, 880],
        duration: 0.5,
        type: 'sine',
        envelope: 'ascending'
      },
      gameOver: {
        freq: [440, 392, 349, 330],
        duration: 1.0,
        type: 'sawtooth',
        envelope: 'descending'
      },
      countdown: { freq: 440, duration: 0.15, type: 'sine' },
      countdownGo: {
        freq: [523, 659, 784],
        duration: 0.4,
        type: 'sine',
        envelope: 'ascending'
      },
      combo: { freq: 600, duration: 0.15, type: 'sine', envelope: 'bounce' }
    };
  }

  playSound(soundName, volumeMultiplier = 1.0) {
    if (!this.enabled) return;
    this.initSounds();
    if (!this.audioContext) return;

    const config = this.soundConfigs[soundName];
    if (!config) return;

    const ctx = this.audioContext;
    if (ctx.state === 'suspended') return;

    try {
      const now = ctx.currentTime;
      const volume = Math.max(0, Math.min(1, this.sfxVolume * volumeMultiplier));

      const playOne = (freq, start, duration, env) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = config.type;
        osc.frequency.setValueAtTime(freq, start);

        if (env === 'punch') {
          gain.gain.setValueAtTime(volume, start);
          gain.gain.exponentialRampToValueAtTime(0.01, start + duration);
        } else if (env === 'swell') {
          gain.gain.setValueAtTime(0.01, start);
          gain.gain.exponentialRampToValueAtTime(volume, start + duration * 0.3);
          gain.gain.exponentialRampToValueAtTime(0.01, start + duration);
        } else if (env === 'bounce') {
          gain.gain.setValueAtTime(volume, start);
          gain.gain.setValueAtTime(volume * 0.5, start + duration * 0.3);
          gain.gain.setValueAtTime(volume, start + duration * 0.6);
          gain.gain.exponentialRampToValueAtTime(0.01, start + duration);
        } else {
          gain.gain.setValueAtTime(volume, start);
          gain.gain.exponentialRampToValueAtTime(0.01, start + duration);
        }

        osc.start(start);
        osc.stop(start + duration);
      };

      if (config.envelope === 'arpeggio' || config.envelope === 'ascending' || config.envelope === 'descending') {
        const freqs = Array.isArray(config.freq) ? config.freq : [config.freq];
        const noteTime = config.duration / freqs.length;
        freqs.forEach((f, i) => playOne(f, now + i * noteTime, noteTime, null));
        return;
      }

      playOne(config.freq, now, config.duration, config.envelope);
    } catch (e) {}
  }

  playLineClear(lineCount) {
    if (lineCount === 4) this.playSound('tetris', 1.2);
    else if (lineCount === 3) this.playSound('lineClear3');
    else if (lineCount === 2) this.playSound('lineClear2');
    else if (lineCount === 1) this.playSound('lineClear1');
  }

  playComboSound(comboCount) {
    const volumeMultiplier = Math.min(1.5, 1.0 + comboCount * 0.1);
    this.playSound('combo', volumeMultiplier);
  }

  startBGM(level) {
    if (!this.enabled) return;
    this.initSounds();
    if (!this.audioContext) return;
    if (this.audioContext.state === 'suspended') return;

    this.stopBGM();
    const tempo = Math.min(180, 120 + level * 5);
    const beatDuration = 60 / tempo;

    this.bgmInterval = setInterval(() => {
      if (!this.enabled || !this.audioContext || this.audioContext.state === 'suspended') return;

      const now = this.audioContext.currentTime;
      const osc = this.audioContext.createOscillator();
      const gain = this.audioContext.createGain();
      osc.connect(gain);
      gain.connect(this.audioContext.destination);

      const notes = [261.63, 293.66, 329.63, 392, 440];
      const randomNote = notes[Math.floor(Math.random() * notes.length)];
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(randomNote, now);

      const volume = this.musicVolume * 0.1;
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + beatDuration * 0.5);

      osc.start(now);
      osc.stop(now + beatDuration * 0.5);
    }, beatDuration * 1000);
  }

  stopBGM() {
    if (this.bgmInterval) {
      clearInterval(this.bgmInterval);
      this.bgmInterval = null;
    }
  }

  toggle() {
    this.enabled = !this.enabled;
    if (!this.enabled) this.stopBGM();
    return this.enabled;
  }

  setMusicVolume(vol) {
    this.musicVolume = Math.max(0, Math.min(1, vol));
  }

  setSFXVolume(vol) {
    this.sfxVolume = Math.max(0, Math.min(1, vol));
  }
}

function ensureAudioUnlocked() {
  if (!audioSystem) return;
  const res = audioSystem.unlock();
  if (res && typeof res.then === 'function') {
    res.then(() => {}).catch(() => {});
  }
}

let audioSystem = null;
class ScreenShake {
    constructor(element) {
        this.element = element;
        this.shaking = false;
    }
    shake(intensity = 1, duration = 500) {
        if (this.shaking) return;
        this.shaking = true;
        this.element.classList.add('shake');
        this.element.style.setProperty('--shake-intensity', intensity);
        setTimeout(() => {
            this.element.classList.remove('shake');
            this.shaking = false;
        }, duration);
    }
    smallShake() {
        this.shake(0.5, 200);
    }
    mediumShake() {
        this.shake(1.0, 400);
    }
    bigShake() {
        this.shake(1.5, 600);
    }
}
let screenShaker = null;
class BackgroundParticles {
    constructor(container) {
        this.container = container;
        this.particles = [];
        this.maxParticles = 15;
        this.colors = ['#4f8cff', '#3563e9', '#5b9fff', '#6ba5ff'];
        this.init();
    }
    init() {
        this.particleContainer = document.createElement('div');
        this.particleContainer.className = 'background-particles';
        this.container.insertBefore(this.particleContainer, this.container.firstChild);
        for (let i = 0; i < this.maxParticles; i++) {
            setTimeout(() => this.createParticle(), i * 300);
        }
    }
    createParticle() {
        const particle = document.createElement('div');
        particle.className = 'bg-particle';
        const size = 20 + Math.random() * 60;
        const startX = Math.random() * 100;
        const duration = 8 + Math.random() * 10;
        const delay = Math.random() * 5;
        const color = this.colors[Math.floor(Math.random() * this.colors.length)];
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        particle.style.left = startX + '%';
        particle.style.bottom = '-' + size + 'px';
        particle.style.background = `radial-gradient(circle, ${color}40, transparent)`;
        particle.style.animationDuration = duration + 's';
        particle.style.animationDelay = delay + 's';
        this.particleContainer.appendChild(particle);
        particle.addEventListener('animationend', () => {
            particle.remove();
            this.createParticle();
        });
    }
    updateLevel(level) {
        const levelColors = {
            1: ['#4f8cff', '#3563e9', '#5b9fff', '#6ba5ff'],
            5: ['#10b981', '#34d399', '#6ee7b7', '#a7f3d0'],
            10: ['#f59e0b', '#fbbf24', '#fcd34d', '#fde68a'],
            15: ['#ef4444', '#f87171', '#fca5a5', '#fecaca'],
            20: ['#a855f7', '#c084fc', '#d8b4fe', '#e9d5ff']
        };
        let targetLevel = 1;
        for (const lvl in levelColors) {
            if (level >= parseInt(lvl)) {
                targetLevel = parseInt(lvl);
            }
        }
        this.colors = levelColors[targetLevel];
        const particleElements = this.particleContainer.querySelectorAll('.bg-particle');
        particleElements.forEach(p => {
            const newColor = this.colors[Math.floor(Math.random() * this.colors.length)];
            p.style.background = `radial-gradient(circle, ${newColor}40, transparent)`;
        });
    }
    clear() {
        this.particleContainer.innerHTML = '';
    }
}
let bgParticles = null;
const SKINS = {
    classic: {
        I: '#00f0f0', O: '#f0f000', T: '#a000f0', S: '#00f000', Z: '#f00000', J: '#0000f0', L: '#f0a000',
        G: '#606060',
        ghost: 'rgba(122,162,255,0.45)',
        texture: 'flat'
    },
    pastel: {
        I: '#9be7ff', O: '#fff59b', T: '#d1b3ff', S: '#b2f7b2', Z: '#ffb3b3', J: '#b3c6ff', L: '#ffd1a6',
        G: '#a0a0a0',
        ghost: 'rgba(147,197,253,0.45)',
        texture: 'flat'
    },
    neon: {
        I: '#22d3ee', O: '#facc15', T: '#a78bfa', S: '#34d399', Z: '#fb7185', J: '#60a5fa', L: '#f59e0b',
        G: '#505050',
        ghost: 'rgba(56,189,248,0.5)',
        texture: 'glow'
    },
    glossy: {
        I: '#00d4e8', O: '#ffd700', T: '#b24bf3', S: '#00e676', Z: '#ff1744', J: '#2979ff', L: '#ff6d00',
        G: '#707070',
        ghost: 'rgba(122,162,255,0.45)',
        texture: 'glossy'
    },
    retro: {
        I: '#00ffff', O: '#ffff00', T: '#ff00ff', S: '#00ff00', Z: '#ff0000', J: '#0000ff', L: '#ff7f00',
        G: '#808080',
        ghost: 'rgba(255,255,255,0.3)',
        texture: 'pixel'
    },
    minimal: {
        I: '#e0e0e0', O: '#e0e0e0', T: '#e0e0e0', S: '#e0e0e0', Z: '#e0e0e0', J: '#e0e0e0', L: '#e0e0e0',
        G: '#909090',
        ghost: 'rgba(200,200,200,0.4)',
        texture: 'outline'
    }
};
const SRS_STATES = {
    I: {
        0: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
        1: [[0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]],
        2: [[0, 0, 0, 0], [0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0]],
        3: [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]
    },
    O: {
        0: [[1, 1], [1, 1]],
        1: [[1, 1], [1, 1]],
        2: [[1, 1], [1, 1]],
        3: [[1, 1], [1, 1]]
    },
    T: {
        0: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
        1: [[0, 1, 0], [0, 1, 1], [0, 1, 0]],
        2: [[0, 0, 0], [1, 1, 1], [0, 1, 0]],
        3: [[0, 1, 0], [1, 1, 0], [0, 1, 0]]
    },
    S: {
        0: [[0, 1, 1], [1, 1, 0], [0, 0, 0]],
        1: [[0, 1, 0], [0, 1, 1], [0, 0, 1]],
        2: [[0, 0, 0], [0, 1, 1], [1, 1, 0]],
        3: [[1, 0, 0], [1, 1, 0], [0, 1, 0]]
    },
    Z: {
        0: [[1, 1, 0], [0, 1, 1], [0, 0, 0]],
        1: [[0, 0, 1], [0, 1, 1], [0, 1, 0]],
        2: [[0, 0, 0], [1, 1, 0], [0, 1, 1]],
        3: [[0, 1, 0], [1, 1, 0], [1, 0, 0]]
    },
    J: {
        0: [[1, 0, 0], [1, 1, 1], [0, 0, 0]],
        1: [[0, 1, 1], [0, 1, 0], [0, 1, 0]],
        2: [[0, 0, 0], [1, 1, 1], [0, 0, 1]],
        3: [[0, 1, 0], [0, 1, 0], [1, 1, 0]]
    },
    L: {
        0: [[0, 0, 1], [1, 1, 1], [0, 0, 0]],
        1: [[0, 1, 0], [0, 1, 0], [0, 1, 1]],
        2: [[0, 0, 0], [1, 1, 1], [1, 0, 0]],
        3: [[1, 1, 0], [0, 1, 0], [0, 1, 0]]
    }
};
const SHAPES = Object.fromEntries(
    Object.entries(SRS_STATES).map(([k, v]) => [k, v[0]])
);
const TYPES = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];
const SRS_KICKS_JLSTZ = {
    '0->1': [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
    '1->0': [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
    '1->2': [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
    '2->1': [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
    '2->3': [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
    '3->2': [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
    '3->0': [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
    '0->3': [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]]
};
const SRS_KICKS_I = {
    '0->1': [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
    '1->0': [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
    '1->2': [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],
    '2->1': [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],
    '2->3': [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
    '3->2': [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
    '3->0': [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],
    '0->3': [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]]
};
const cvs = document.getElementById('playfield');
const ctx = cvs.getContext('2d');
const holdCanvas = document.getElementById('hold');
const holdCtx = holdCanvas.getContext('2d');
const previewsEl = document.getElementById('previews');
const comboNotif = document.getElementById('comboNotif');
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const linesEl = document.getElementById('lines');
const comboEl = document.getElementById('combo');
const comboInd = document.getElementById('comboInd');
const b2bInd = document.getElementById('b2bInd');
const scoreRow = document.getElementById('scoreRow');
const overlay = document.getElementById('overlay');
const modeDisplayEl = document.getElementById('modeDisplay');
const timerContainer = document.getElementById('timerContainer');
const timerDisplay = document.getElementById('timerDisplay');
const cheeseContainer = document.getElementById('cheeseContainer');
const cheeseRemaining = document.getElementById('cheeseRemaining');
const cheeseProgress = document.getElementById('cheeseProgress');
const gamepadIndicator = document.getElementById('gamepadIndicator');
const gamepadName = document.getElementById('gamepadName');
const topHeader = document.getElementById('topHeader');
const btnHeaderToggle = document.getElementById('btnHeaderToggle');
const btnPlayPause = document.getElementById('btnPlayPause');
const btnRestart = document.getElementById('btnRestart');
const countdownOverlay = document.getElementById('countdownOverlay');
const countdownNumber = document.getElementById('countdownNumber');
const pauseOverlay = document.getElementById('pauseOverlay');
const pauseScore = document.getElementById('pauseScore');
const pauseLines = document.getElementById('pauseLines');
const pauseLevel = document.getElementById('pauseLevel');
const btnPauseResume = document.getElementById('btnPauseResume');
const btnPauseRestart = document.getElementById('btnPauseRestart');
const btnPauseSettings = document.getElementById('btnPauseSettings');
const levelupOverlay = document.getElementById('levelupOverlay');
const levelupLevel = document.getElementById('levelupLevel');
const gameoverOverlay = document.getElementById('gameoverOverlay');
const gameoverModal = document.getElementById('gameoverModal');
const gameoverTitle = document.getElementById('gameoverTitle');
const gameoverSubtitle = document.getElementById('gameoverSubtitle');
const gameoverRank = document.getElementById('gameoverRank');
const gameoverRankNum = document.getElementById('gameoverRankNum');
const goScore = document.getElementById('goScore');
const goLines = document.getElementById('goLines');
const goLevel = document.getElementById('goLevel');
const goTime = document.getElementById('goTime');
const goTetrises = document.getElementById('goTetrises');
const goMaxCombo = document.getElementById('goMaxCombo');
const btnGameoverRestart = document.getElementById('btnGameoverRestart');
const btnGameoverLeaderboard = document.getElementById('btnGameoverLeaderboard');
const btnGameoverSettings = document.getElementById('btnGameoverSettings');
const keyFeedback = document.getElementById('keyFeedback');
const btnSettings = document.getElementById('btnSettings');
const btnCloseSettings = document.getElementById('btnCloseSettings');
const btnSaveStart = document.getElementById('btnSaveStart');
const btnUndo = document.getElementById('btnUndo');
const btnRedo = document.getElementById('btnRedo');
const undoControls = document.getElementById('undoControls');
const btnResetKeys = document.getElementById('btnResetKeys');
const cfgCols = document.getElementById('cfgCols');
const cfgRows = document.getElementById('cfgRows');
const cfgPreview = document.getElementById('cfgPreview');
const cfgStartLevel = document.getElementById('cfgStartLevel');
const cfgGhost = document.getElementById('cfgGhost');
const cfgLockDelay = document.getElementById('cfgLockDelay');
const cfgDAS = document.getElementById('cfgDAS');
const cfgARR = document.getElementById('cfgARR');
const cfgSkin = document.getElementById('cfgSkin');
const cfgVibration = document.getElementById('cfgVibration');
const cfgCheeseLines = document.getElementById('cfgCheeseLines');
const cfgUltraTime = document.getElementById('cfgUltraTime');
const mobileControlsEl = document.getElementById('mobileControls');
const mobileLeftEl = document.getElementById('mobileLeft');
const mobileRightEl = document.getElementById('mobileRight');
const keybindGrid = document.getElementById('keybindGrid');
const leaderboardOverlay = document.getElementById('leaderboardOverlay');
const btnLeaderboard = document.getElementById('btnLeaderboard');
const btnCloseLeaderboard = document.getElementById('btnCloseLeaderboard');
const btnClearLeaderboard = document.getElementById('btnClearLeaderboard');
const leaderboardTabs = document.getElementById('leaderboardTabs');
const leaderboardContent = document.getElementById('leaderboardContent');
const scoreHeader = document.getElementById('scoreHeader');
const statTotalGames = document.getElementById('statTotalGames');
const statTotalLines = document.getElementById('statTotalLines');
const statTotalScore = document.getElementById('statTotalScore');
const statPlayTime = document.getElementById('statPlayTime');
const statTetrises = document.getElementById('statTetrises');
const statTSpins = document.getElementById('statTSpins');
const cfgSFXVolume = document.getElementById('cfgSFXVolume');
const cfgMusicVolume = document.getElementById('cfgMusicVolume');
let COLS = 10, ROWS = 20;
let BLOCK = 30;
let board = createMatrix(COLS, ROWS);
let running = false, paused = false, gameOver = false;
let skin = SKINS.classic;
let previewCount = 5;
let bag = [];
let queue = [];
let holdType = null;
let holdLocked = false;
let piece = null;
let score = 0, lines = 0, level = 1;
let startLevel = 1;
let combo = 0;
let b2bCount = 0;
let lastClearWasSpecial = false;
let lastActionWasRotate = false;
let tSpinType = null;
let lastKickIndex = 0;
let particles = [];
let hardDropping = false;
let hardDropStartY = 0;
let hardDropTargetY = 0;
let hardDropCurrentY = 0;
let hardDropSpeed = 3;
let clearingLines = false;
let clearAnimationTimer = 0;
const CLEAR_ANIMATION_DURATION = 800;
let gravity = 800;
const levelSpeed = lvl => Math.max(80, 900 - (lvl - 1) * 60);
let dropTimer = 0;
let lastTS = 0;
let lockDelay = 1500;
let lockTimer = 0;
let touchingGround = false;
let ghostEnabled = true;
let DAS = 120;
let ARR = 20;
let keyState = {};
let dasTimer = {};
let arrTimer = {};
let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
let pausedBeforeOverlay = false;
let vibrationEnabled = true;
let currentLeaderboardMode = 'marathon';
let gameMode = 'marathon';
const MODE_NAMES = {
    marathon: 'é©¬æ‹‰æ¾',
    sprint: '40è¡Œç«é€Ÿ',
    ultra: 'é™æ—¶æ‰“åˆ†',
    cheese: 'æŒ–æ˜æ¨¡å¼',
    master: 'å¤§å¸ˆæ¨¡å¼',
    practice: 'ç»ƒä¹ æ¨¡å¼'
};
let gameTimer = 0;
let timerRunning = false;
let ultraTimeLimit = 120;
let cheeseLines = 10;
let initialCheeseLines = 10;
let historyStates = [];
let historyIndex = -1;
const MAX_HISTORY = 50;
const DEFAULT_KEYBINDS = {
    moveLeft: ['ArrowLeft'],
    moveRight: ['ArrowRight'],
    softDrop: ['ArrowDown'],
    hardDrop: [' ', 'Space'],
    rotateRight: ['ArrowUp', 'x', 'X'],
    rotateLeft: ['z', 'Z', 'Control'],
    hold: ['c', 'C', 'Shift'],
    pause: ['p', 'P', 'Escape']
};
let keyBindings = JSON.parse(JSON.stringify(DEFAULT_KEYBINDS));
let listeningForKey = null;
const GAMEPAD_BINDINGS = {
    moveLeft: [14],
    moveRight: [15],
    softDrop: [13],
    hardDrop: [0],
    rotateRight: [2],
    rotateLeft: [1],
    hold: [3, 4, 5],
    pause: [9]
};

let connectedGamepad = null;
let gamepadState = {};
let lastGamepadState = {};

let lockWarningTimer = 0;
const LOCK_WARNING_TIME = 300;
let showLockWarning = false;

let lockMoveResets = 0;
const MAX_LOCK_RESETS = 15;
let lowestY = 0;

class Particle {
    constructor(x, y, color, type = 'normal') {
        this.x = x;
        this.y = y;
        this.type = type;

        if(type === 'spark') {
            this.vx = (Math.random() - 0.5) * 12;
            this.vy = Math.random() * 4 - 1;
            this.life = 1.0;
            this.decay = 0.03 + Math.random() * 0.02;
            this.size = 2 + Math.random() * 3;
            this.gravity = 0.15;
        } else {
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10 - 3;
            this.life = 1.0;
            this.decay = 0.008 + Math.random() * 0.008;
            this.size = 4 + Math.random() * 5;
            this.gravity = 0.25;
        }

        this.color = color;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.3;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.vx *= 0.98;
        this.life -= this.decay;
        this.rotation += this.rotationSpeed;
        return this.life > 0;
    }

    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        if(this.type === 'spark') {
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

            ctx.globalAlpha = this.life * 0.3;
            ctx.fillStyle = '#fff';
            ctx.fillRect(-this.size/3, -this.size/3, this.size*0.66, this.size*0.66);
        } else {
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        }

        ctx.restore();
    }
}

function createMatrix(w,h){
    const m = [];
    for(let y=0;y<h;y++){ m.push(new Array(w).fill(0)); }
    return m;
}
function cloneMatrix(m){ return m.map(r=>r.slice()); }

function refillBag(){
    const arr = TYPES.slice();
    for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    bag = arr;
}

function takeFromQueue(){
    while(queue.length < previewCount + 1){
        if(!bag.length) refillBag();
        queue.push(bag.pop());
    }
    return queue.shift();
}

function collide(b, p) {
    for(let y = 0; y < p.m.length; y++) {
        for(let x = 0; x < p.m[y].length; x++) {
            if(!p.m[y][x]) continue;
            const nx = p.x + x;
            const ny = p.y + y;

            if(nx < 0 || nx >= COLS || ny >= ROWS) {
                return true;
            }

            if(ny >= 0 && b[ny][nx]) {
                return true;
            }
        }
    }
    return false;
}

function isGrounded(p){
    if(!p) return false;
    const test = { ...p, y: p.y + 1 };
    return collide(board, test);
}

function merge(b,p){
    for(let y=0;y<p.m.length;y++){
        for(let x=0;x<p.m[y].length;x++){
            if(p.m[y][x]){
                const nx = p.x + x;
                const ny = p.y + y;
                if(ny>=0 && ny<ROWS && nx>=0 && nx<COLS){
                    b[ny][nx] = p.type;
                }
            }
        }
    }
}

function checkTSpin(p, kickIndex) {
    if(p.type !== 'T') return null;
    if(!lastActionWasRotate) return null;

    const centerX = p.x + 1;
    const centerY = p.y + 1;

    const frontCorners = {
        0: [{dx: -1, dy: -1}, {dx: 1, dy: -1}],
        1: [{dx: 1, dy: -1}, {dx: 1, dy: 1}],
        2: [{dx: -1, dy: 1}, {dx: 1, dy: 1}],
        3: [{dx: -1, dy: -1}, {dx: -1, dy: 1}]
    };

    const allCorners = [
        {dx: -1, dy: -1},
        {dx: 1, dy: -1},
        {dx: -1, dy: 1},
        {dx: 1, dy: 1}
    ];

    function isCornerFilled(corner) {
        const cx = centerX + corner.dx;
        const cy = centerY + corner.dy;
        if(cy < 0 || cy >= ROWS || cx < 0 || cx >= COLS) {
            return true;
        }
        return !!board[cy][cx];
    }

    let filledCorners = 0;
    for(const corner of allCorners) {
        if(isCornerFilled(corner)) filledCorners++;
    }

    if(filledCorners < 3) return null;

    const front = frontCorners[p.rotation] || frontCorners[0];
    const frontFilled = front.filter(c => isCornerFilled(c)).length;

    if(kickIndex >= 3 || frontFilled < 2) {
        return 'mini';
    }

    return 'normal';
}

function clearLines(){
  if (gameOverAnimating) {
    tSpinType = null;
    return;
  }

  const fullRows = [];
  for(let y=0; y<ROWS; y++){
    const isFull = board[y].every(v => v !== 0);
    if(isFull) fullRows.push(y);
  }
  const cleared = fullRows.length;

  if(cleared > 0){
    vibrate([10, 20, 30][Math.min(cleared-1, 2)] || 30);

    for(const y of fullRows){
      for(let x=0; x<COLS; x++){
        const type = board[y][x];
        if(!type) continue;
        const color = skin[type];
        const px = x * BLOCK + BLOCK / 2;
        const py = y * BLOCK + BLOCK / 2;
        const count = 15 + Math.floor(Math.random() * 6);
        for(let i=0; i<count; i++){
          particles.push(new Particle(px, py, color, 'normal'));
        }
      }
    }

    const isTetris = (cleared === 4);
    const isTSpin = (tSpinType !== null && cleared > 0);
    if (isTetris) sessionStats.tetrises++;
    if (isTSpin) sessionStats.tSpins++;
    sessionStats.maxCombo = Math.max(sessionStats.maxCombo, combo + 1);

    const isSpecial = isTetris || isTSpin;

    if(cleared > 0) {
      audioSystem.playLineClear(cleared);
      if(combo > 1) {
        audioSystem.playComboSound(combo);
      }
      if(cleared === 4 || isTSpin) {
        screenShaker.bigShake();
      } else {
        screenShaker.smallShake();
      }
    }

    let b2bMultiplier = 1.0;
    if(isSpecial) {
      if(lastClearWasSpecial) {
        b2bCount++;
        b2bMultiplier = 1.5;
      } else {
        b2bCount = 1;
      }
      lastClearWasSpecial = true;
    } else {
      lastClearWasSpecial = false;
      b2bCount = 0;
    }

    let baseScore = 0;
    if(isTSpin) {
      let effectiveTSpinType = tSpinType;
      if(tSpinType === 'mini' && cleared >= 3) {
        effectiveTSpinType = 'normal';
      }
      const tSpinScores = {
        'mini': [100, 200, 400],
        'normal': [400, 800, 1200, 1600]
      };
      const scoreTable = tSpinScores[effectiveTSpinType] || tSpinScores['normal'];
      baseScore = scoreTable[Math.min(cleared - 1, scoreTable.length - 1)] || 0;
    } else {
      const normalScores = {1:100, 2:300, 3:500, 4:800};
      baseScore = normalScores[cleared] || 0;
    }

    combo++;
    const comboBonus = combo > 1 ? 50 * (combo - 1) : 0;
    const totalScore = Math.floor((baseScore + comboBonus) * level * b2bMultiplier);
    score += totalScore;
    lines += cleared;

    if(gameMode === 'cheese') {
      updateCheeseProgress();
    }

    updateLevelByLines();
    updateStats();
    showClearNotification(cleared, isTSpin, tSpinType, b2bMultiplier > 1);

    const fullSet = new Set(fullRows);
    const kept = [];
    for(let y=0; y<ROWS; y++){
      if(!fullSet.has(y)) kept.push(board[y]);
    }
    const empties = new Array(cleared).fill(0).map(()=> new Array(COLS).fill(0));
    board = [...empties, ...kept];

    const allClear = board.every(row => row.every(cell => cell === 0));
    if(allClear) {
      triggerAllClear();
    }

    clearingLines = true;
    clearAnimationTimer = 0;
    const endAt = Date.now() + CLEAR_ANIMATION_DURATION;
    if (pendingInputs && pendingInputs.length) {
      for (const it of pendingInputs) {
        if (it && typeof it === 'object') it.validUntil = endAt + 120;
      }
    }
    setTimeout(()=>{
      clearingLines = false;
      processPendingInputs();
    }, CLEAR_ANIMATION_DURATION);

    checkModeCompletion();
    spawn();
  } else {
    combo = 0;
    updateStats();
    spawn();
  }
  tSpinType = null;
}

function triggerAllClear() {
    const allClearBonus = 10000 * level;
    score += allClearBonus;

    audioSystem.playSound('tetris', 1.5);
    screenShaker.bigShake();

    showAllClearNotification();

    createAllClearEffect();
}

function showAllClearNotification() {
    comboNotif.textContent = 'ALL CLEAR!';
    comboNotif.className = 'combo-notification combo-tspin show';

    const canvas = document.getElementById('playfield');
    canvas.style.filter = 'brightness(1.5)';
    setTimeout(() => {
        canvas.style.filter = '';
    }, 500);

    setTimeout(() => {
        comboNotif.classList.remove('show');
    }, 2000);
}

function createAllClearEffect() {
    for(let x = 0; x < COLS; x++) {
        for(let y = 0; y < ROWS; y++) {
            if(Math.random() < 0.3) {
                const colors = ['#FFD700', '#FF69B4', '#00CED1', '#FF6347'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const px = x * BLOCK + BLOCK / 2;
                const py = y * BLOCK + BLOCK / 2;
                particles.push(new Particle(px, py, color, 'spark'));
            }
        }
    }
}

function showClearNotification(count, isTSpin, tSpinVariant, isB2B) {
    let message = '';
    let cssClass = 'combo-notification';

    if(isTSpin) {
        const lineNames = ['', 'Single', 'Double', 'Triple'];
        const lineName = lineNames[count] || count + 'è¡Œ';

        if(tSpinVariant === 'mini') {
            message = `T-Spin Mini ${lineName}!`;
        } else {
            message = `T-Spin ${lineName}!`;
        }
        cssClass += ' combo-tspin';
    } else if(count === 4) {
        message = 'TETRIS!';
        cssClass += ' combo-4';
    } else if(count === 3) {
        message = 'TRIPLE!';
        cssClass += ' combo-3';
    } else if(count === 2) {
        message = 'DOUBLE!';
        cssClass += ' combo-2';
    } else if(count === 1) {
        message = 'SINGLE';
        cssClass += ' combo-1';
    }

    if(isB2B && (isTSpin || count === 4)) {
        message = 'B2B ' + message;
        cssClass += ' combo-b2b';
    }

    if(combo > 1) {
        message += ` (Combo x${combo})`;
    }

    comboNotif.textContent = message;
    comboNotif.className = cssClass + ' show';

    setTimeout(() => {
        comboNotif.classList.remove('show');
    }, 1200);
}

function rotate(dir = +1) {
  if (!piece || hardDropping || gameOverAnimating) return false;

  if (piece.type === 'O') {
    lastActionWasRotate = true;
    lastKickIndex = 0;
    tSpinType = null;
    audioSystem.playSound('rotate');
    vibrate(4);
    if (isGrounded(piece)) maybeResetLockTimer();
    return true;
  }

  if (!SRS_STATES[piece.type]) return false;

  const oldRotation = piece.rotation;
  const newRotation = (oldRotation + (dir > 0 ? 1 : 3)) % 4;
  const rotated = SRS_STATES[piece.type][newRotation];
  if (!rotated) return false;

  const rotatedMatrix = rotated.map(row => row.slice());
  const kickKey = `${oldRotation}->${newRotation}`;

  const kicks = (piece.type === 'I')
    ? (SRS_KICKS_I[kickKey] || [[0, 0]])
    : (SRS_KICKS_JLSTZ[kickKey] || [[0, 0]]);

  for (let kickIdx = 0; kickIdx < kicks.length; kickIdx++) {
    const kick = kicks[kickIdx];
    if (!kick || kick.length < 2) continue;

    const [dx, dy] = kick;
    const test = {
      ...piece,
      x: piece.x + dx,
      y: piece.y + dy,
      m: rotatedMatrix,
      rotation: newRotation
    };

    if (!collide(board, test)) {
      piece.x = test.x;
      piece.y = test.y;
      piece.m = rotatedMatrix;
      piece.rotation = newRotation;

      lastActionWasRotate = true;
      lastKickIndex = kickIdx;

      audioSystem.playSound('rotate');
      vibrate(5);

      if (isGrounded(piece)) maybeResetLockTimer();
      tSpinType = (piece.type === 'T') ? checkTSpin(piece, kickIdx) : null;
      return true;
    }
  }

  lastActionWasRotate = false;
  return false;
}

function flushPendingInputsOnSpawn() {
    if (!pendingInputs || pendingInputs.length === 0) return;
    if (!running || paused || gameOver) {
        pendingInputs = [];
        return;
    }
    if (shouldBlockGameplayInput()) {
        pendingInputs = [];
        return;
    }
    processPendingInputs();
}

function spawn() {
    piece = newPiece(takeFromQueue());
    holdLocked = false;

    const holdBox = document.querySelector('.hold-box');
    if (holdBox) holdBox.classList.remove('locked');

    lockTimer = 0;
    lockWarningTimer = 0;
    showLockWarning = false;
    touchingGround = false;
    lastActionWasRotate = false;
    tSpinType = null;
    lastKickIndex = 0;
    lockMoveResets = 0;

    lowestY = piece ? piece.y : -999;

    if (piece) {
        if (collide(board, piece)) {
            piece.y -= 1;
            if (collide(board, piece)) {
                endGame();
                return;
            }
        }
        lowestY = piece.y;
        piece.animX = piece.x;
        piece.animY = piece.y;
    }

    redrawSidePanels();
    flushPendingInputsOnSpawn();
}

function newPiece(type) {
    const mat = SRS_STATES[type][0].map(row => [...row]);

    const p = {
        type,
        m: mat,
        x: Math.floor(COLS/2) - Math.ceil(mat[0].length/2),
        y: 0,
        color: skin[type],
        animX: 0,
        animY: 0,
        rotation: 0
    };

    if(type === 'I') {
        p.y = -2;
    }

    if(p.x < 0) {
        p.x = 0;
    }
    if(p.x + mat[0].length > COLS) {
        p.x = COLS - mat[0].length;
    }

    p.animX = p.x;
    p.animY = p.y;

    return p;
}

function updateLevelByLines(){
    if(gameMode === 'sprint' || gameMode === 'ultra' || gameMode === 'cheese' || gameMode === 'practice') return;

    const computed = startLevel + Math.floor(lines / 10);
    const newLevel = Math.min(20, Math.max(1, computed));
    if(newLevel !== level){
        const oldLevel = level;
        level = newLevel;
        if(gameMode !== 'master') {
            gravity = levelSpeed(level);
        }

        audioSystem.playSound('levelUp');
        cvs.classList.add('level-up');
        setTimeout(() => cvs.classList.remove('level-up'), 600);

        showLevelUpAnimation(level);

        if(bgParticles) {
            bgParticles.updateLevel(level);
        }
    }
}

function tryMove(dx, dy) {
    if(!piece) return false;

    const testPiece = {
        ...piece,
        x: piece.x + dx,
        y: piece.y + dy
    };

    return !collide(board, testPiece);
}

function move(dx){
    if(!piece || hardDropping || gameOverAnimating) return false;
    piece.x += dx;
    if(collide(board, piece)){
        piece.x -= dx;
        return false;
    }
    lastActionWasRotate = false;
    tSpinType = null;
    maybeResetLockTimer();
    audioSystem.playSound('move');
    return true;
}

let softDropActive = false;
let softDropTimer = 0;
const SOFT_DROP_SPEED = 50;

function softDropStep(){
    if(!piece || hardDropping) return false;
    piece.y += 1;
    if(collide(board, piece)){
        piece.y -= 1;
        return false;
    }else{
        lastActionWasRotate = false;
        tSpinType = null;
        score += 1;
        updateStats();

        audioSystem.playSound('softDrop');

        return true;
    }
}

function startSoftDrop() {
    if(!piece || hardDropping) return;
    softDropActive = true;
    softDropTimer = 0;
    softDropStep();
}

function stopSoftDrop() {
    softDropActive = false;
    softDropTimer = 0;
}

function updateSoftDrop(dt) {
    if(!softDropActive || !piece || hardDropping) return;

    softDropTimer += dt;
    while(softDropTimer >= SOFT_DROP_SPEED) {
        softDropTimer -= SOFT_DROP_SPEED;
        if(!softDropStep()) break;
    }
}

function hardDrop(){
    if(!piece || hardDropping || gameOverAnimating) return;

    const gy = ghostY();
    const dist = Math.max(0, gy - piece.y);

    if(dist === 0) {
        lockPiece();
        return;
    }

    hardDropping = true;
    hardDropStartY = piece.y;
    hardDropTargetY = gy;
    hardDropCurrentY = piece.y;

    score += dist * 2;
    updateStats();
    lastActionWasRotate = false;

    audioSystem.playSound('hardDrop');
    screenShaker.mediumShake();

    vibrate(15);
}

function updateHardDrop() {
    if(!hardDropping) return;

    hardDropCurrentY = Math.min(hardDropTargetY, hardDropCurrentY + hardDropSpeed);

    const pieceScreenY = hardDropCurrentY * BLOCK;

    for(let py = 0; py < piece.m.length; py++) {
        for(let px = 0; px < piece.m[py].length; px++) {
            if(!piece.m[py][px]) continue;

            const nx = piece.x + px;
            if(Math.random() < 0.3) {
                const sparkX = nx * BLOCK + (Math.random() < 0.5 ? 2 : BLOCK - 2);
                const sparkY = pieceScreenY + py * BLOCK + BLOCK / 2;

                const sparkColors = ['#ffaa00', '#ff6600', '#ffdd00', '#fff'];
                const sparkColor = sparkColors[Math.floor(Math.random() * sparkColors.length)];

                particles.push(new Particle(sparkX, sparkY, sparkColor, 'spark'));
            }
        }
    }

    piece.y = Math.floor(hardDropCurrentY);

    if(hardDropCurrentY >= hardDropTargetY) {
        piece.y = hardDropTargetY;
        hardDropping = false;

        for(let py = 0; py < piece.m.length; py++) {
            for(let px = 0; px < piece.m[py].length; px++) {
                if(!piece.m[py][px]) continue;
                const nx = piece.x + px;
                const ny = piece.y + py;

                const particleX = nx * BLOCK + BLOCK / 2;
                const particleY = (ny + 1) * BLOCK;

                for(let i = 0; i < 5; i++) {
                    particles.push(new Particle(particleX, particleY, '#fff', 'spark'));
                }
            }
        }

        vibrate(20);
        lockPiece();
    }
}

function lockPiece(){
    audioSystem.playSound('lock');
    merge(board, piece);
    piece = null;
    clearLines();
    lockTimer = 0;
    lockWarningTimer = 0;
    showLockWarning = false;
    touchingGround = false;
    if(gameMode === 'practice') {
        saveHistory();
    }
}

function maybeResetLockTimer(){
    if(!isGrounded(piece)) return;

    if(piece.y > lowestY) {
        lowestY = piece.y;
        lockMoveResets = 0;
    }

    if(lockMoveResets < MAX_LOCK_RESETS) {
        lockTimer = 0;
        lockWarningTimer = 0;
        showLockWarning = false;
        lockMoveResets++;
    }
}

function ghostY(){
    let gy = piece.y;
    while(true){
        gy++;
        const test = { ...piece, y: gy };
        if(collide(board, test)) return gy - 1;
    }
}

function lerp(a,b,t){ return a + (b - a) * t; }

function draw() {
  ctx.clearRect(0, 0, cvs.width, cvs.height);
  ctx.fillStyle = '#0b0f23';
  ctx.fillRect(0, 0, cvs.width, cvs.height);

  ctx.strokeStyle = '#1b2248';
  ctx.lineWidth = 1;

  for (let x = 0; x <= COLS; x++) {
    const px = Math.floor(x * BLOCK) + 0.5;
    ctx.beginPath();
    ctx.moveTo(px, 0);
    ctx.lineTo(px, ROWS * BLOCK);
    ctx.stroke();
  }

  for (let y = 0; y <= ROWS; y++) {
    const py = Math.floor(y * BLOCK) + 0.5;
    ctx.beginPath();
    ctx.moveTo(0, py);
    ctx.lineTo(COLS * BLOCK, py);
    ctx.stroke();
  }

  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const t = board[y][x];
      if (!t) continue;
      drawCell(x, y, skin[t]);
    }
  }

  if (ghostEnabled && piece && !hardDropping) {
    const gy = ghostY();
    drawPiece({ ...piece, x: piece.animX, y: gy }, skin.ghost || 'rgba(122,162,255,0.45)', true);
  }

  if (piece) {
    if (hardDropping) {
      const animPiece = { ...piece, y: hardDropCurrentY, x: piece.x };
      drawPiece(animPiece, piece.color, false, 0.9);
    } else {
      let alpha = 1;
      if (showLockWarning) {
        const pulseSpeed = 8;
        const pulsePhase = (Date.now() / 1000) * pulseSpeed;
        alpha = 0.6 + Math.sin(pulsePhase) * 0.25;
      }
      drawPiece({ ...piece, x: piece.animX, y: piece.animY }, piece.color, false, alpha);
      if (showLockWarning) {
        drawPieceOutline({ ...piece, x: piece.animX, y: piece.animY });
      }
    }
  }

  if (showLockWarning && piece && !hardDropping) {
    const progress = Math.max(0, Math.min(1, lockTimer / Math.max(1, lockDelay)));
    const barH = 6;
    const barY = ROWS * BLOCK - barH - 2;
    const barX = 2;
    const barW = COLS * BLOCK - 4;

    ctx.fillStyle = 'rgba(30, 40, 80, 0.85)';
    ctx.fillRect(barX, barY, barW, barH);

    let color;
    if (progress < 0.5) color = '#10b981';
    else if (progress < 0.8) color = '#f59e0b';
    else color = '#ef4444';

    const fillW = Math.floor(barW * progress);
    const grad = ctx.createLinearGradient(barX, barY, barX + barW, barY);
    grad.addColorStop(0, color + 'aa');
    grad.addColorStop(1, color + '55');

    ctx.fillStyle = grad;
    ctx.fillRect(barX, barY, fillW, barH);

    ctx.strokeStyle = 'rgba(255, 255, 255, 0.28)';
    ctx.lineWidth = 1;
    ctx.strokeRect(barX, barY, barW, barH);
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    if (!particles[i].update()) particles.splice(i, 1);
    else particles[i].draw(ctx);
  }
}

function drawPieceOutline(p) {
    const gap = varGap();
    const phase = (Date.now() / 100) % 1;
    const glowIntensity = Math.sin(phase * Math.PI * 2) * 0.5 + 0.5;

    const progress = Math.min(1, lockTimer / lockDelay);
    let outlineColor;
    if(progress < 0.5) {
        outlineColor = `rgba(16, 185, 129, ${0.6 + glowIntensity * 0.4})`;
    } else if(progress < 0.8) {
        outlineColor = `rgba(245, 158, 11, ${0.6 + glowIntensity * 0.4})`;
    } else {
        outlineColor = `rgba(239, 68, 68, ${0.7 + glowIntensity * 0.3})`;
    }

    ctx.strokeStyle = outlineColor;
    ctx.lineWidth = 3;
    ctx.shadowBlur = 15 * glowIntensity;
    ctx.shadowColor = outlineColor;

    for(let y=0;y<p.m.length;y++){
        for(let x=0;x<p.m[y].length;x++){
            if(!p.m[y][x]) continue;
            const nx = p.x + x;
            const ny = p.y + y;
            if(ny<0) continue;

            const px = nx * BLOCK + gap;
            const py = ny * BLOCK + gap;
            const size = BLOCK - 2 * gap;

            ctx.strokeRect(px + 1.5, py + 1.5, size - 3, size - 3);
        }
    }

    ctx.shadowBlur = 0;
}

function varGap(){ return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap')) || 1; }

function drawCell(x, y, color, alpha = 1) {
    const px = x * BLOCK;
    const py = y * BLOCK;
    const gap = varGap();
    const size = BLOCK - 2 * gap;

    ctx.globalAlpha = alpha;

    const texture = skin.texture || 'flat';

    switch(texture) {
        case 'glossy':
            ctx.fillStyle = color;
            ctx.fillRect(px + gap, py + gap, size, size);

            const glossGradient = ctx.createLinearGradient(px + gap, py + gap, px + gap, py + size * 0.4);
            glossGradient.addColorStop(0, 'rgba(255,255,255,0.6)');
            glossGradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = glossGradient;
            ctx.fillRect(px + gap, py + gap, size, size * 0.4);

            const shadowGradient = ctx.createLinearGradient(px + gap, py + size * 0.6, px + gap, py + size);
            shadowGradient.addColorStop(0, 'rgba(0,0,0,0)');
            shadowGradient.addColorStop(1, 'rgba(0,0,0,0.4)');
            ctx.fillStyle = shadowGradient;
            ctx.fillRect(px + gap, py + size * 0.6, size, size * 0.4);

            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(px + gap + 0.5, py + gap + 0.5, size - 1, size - 1);
            break;

        case 'glow':
            ctx.shadowBlur = 15 * alpha;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.fillRect(px + gap, py + gap, size, size);
            ctx.shadowBlur = 0;

            const glowGradient = ctx.createRadialGradient(
                px + BLOCK/2, py + BLOCK/2, 0,
                px + BLOCK/2, py + BLOCK/2, size/2
            );
            glowGradient.addColorStop(0, 'rgba(255,255,255,0.6)');
            glowGradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            glowGradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = glowGradient;
            ctx.fillRect(px + gap, py + gap, size, size);
            break;

        case 'pixel':
            ctx.fillStyle = color;
            ctx.fillRect(px + gap, py + gap, size, size);

            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillRect(px + gap, py + gap, size, 2);
            ctx.fillRect(px + gap, py + gap, 2, size);

            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(px + gap, py + gap + size - 2, size, 2);
            ctx.fillRect(px + gap + size - 2, py + gap, 2, size);
            break;

        case 'outline':
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(px + gap + 1, py + gap + 1, size - 2, size - 2);

            ctx.fillStyle = color + '20';
            ctx.fillRect(px + gap + 2, py + gap + 2, size - 4, size - 4);
            break;

        case 'flat':
        default:
            ctx.fillStyle = color;
            ctx.fillRect(px + gap, py + gap, size, size);

            ctx.globalAlpha = alpha * 0.4;
            ctx.fillStyle = 'rgba(255,255,255,0.10)';
            ctx.fillRect(px + gap, py + gap, size, 4);

            ctx.globalAlpha = alpha * 0.35;
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.fillRect(px + gap, py + size - 4, size, 4);
            break;
    }

    ctx.globalAlpha = 1;
}

function drawPiece(p, color, isGhost=false, alpha=1){
    for(let y=0;y<p.m.length;y++){
        for(let x=0;x<p.m[y].length;x++){
            if(!p.m[y][x]) continue;
            const nx = p.x + x;
            const ny = p.y + y;
            if(ny<0) continue;
            drawCell(nx, ny, color, alpha);
        }
    }
}

function redrawSidePanels(){
    const items = previewsEl.querySelectorAll('canvas');
    items.forEach((cv, idx) => {
        const type = queue[idx];
        const c = cv.getContext('2d');
        c.clearRect(0,0,cv.width,cv.height);
        if(!type) return;
        drawMini(c, type);
    });

    holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
    if(holdType){ drawMini(holdCtx, holdType); }
}

function drawMini(c, type){
    const mat = SHAPES[type];
    const w = mat[0].length, h = mat.length;
    const margin = Math.floor(Math.min(c.canvas.width, c.canvas.height) * 0.1);
    const areaW = c.canvas.width - margin*2;
    const areaH = c.canvas.height - margin*2;
    const cell = Math.max(2, Math.floor(Math.min(areaW / w, areaH / h)));
    const shapeW = w*cell, shapeH = h*cell;
    const ox = Math.floor((c.canvas.width - shapeW)/2);
    const oy = Math.floor((c.canvas.height - shapeH)/2);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        if(!mat[y][x]) continue;
        c.fillStyle = skin[type];
        c.fillRect(ox + x*cell + 1, oy + y*cell + 1, cell-2, cell-2);
      }
    }
  }

  function safeRequestLoop() {
  if (!running || paused) return;
  lastTS = 0;
  requestAnimationFrame(loop);
}

  function loop(ts) {
  if (!running || paused) return;

  if (!lastTS) lastTS = ts;
  const dt = ts - lastTS;
  lastTS = ts;

  updateTimer(dt);

  if (gameMode === 'ultra' && gameTimer >= ultraTimeLimit * 1000) {
    endGame('æ—¶é—´åˆ°ï¼');
    return;
  }

  if (hardDropping) updateHardDrop();
  if (clearingLines) clearAnimationTimer += dt;

  updateSoftDrop(dt);
  updateDASARR(dt);
  pollGamepad();

  if (piece && !hardDropping) {
    if (gameMode === 'master') {
      const gy = ghostY();
      if (gy > piece.y) {
        piece.y = gy;
      }
      dropTimer = 0;
    } else {
      dropTimer += dt;
      while (dropTimer >= gravity) {
        dropTimer -= gravity;
        piece.y += 1;
        if (collide(board, piece)) {
          piece.y -= 1;
          dropTimer = 0;
          break;
        }
      }
    }
  }

  if (piece && !hardDropping) {
    const grounded = isGrounded(piece);
    const denom = Math.max(1, gravity);
    const frac = grounded ? 0 : Math.min(0.999, dropTimer / denom);
    const targetY = piece.y + frac;

    piece.animX = lerp(piece.animX, piece.x, 0.35);

    if (piece.animY > targetY) piece.animY = targetY;
    else piece.animY = lerp(piece.animY, targetY, 0.35);

    if (grounded) {
      dropTimer = 0;
      piece.animY = Math.min(piece.animY, piece.y);
    }
  }

  if (piece && !hardDropping && isGrounded(piece)) {
    touchingGround = true;
    lockTimer += dt;
    lockWarningTimer += dt;
    showLockWarning = lockWarningTimer >= LOCK_WARNING_TIME;

    if (lockTimer >= lockDelay) {
      lockPiece();
      lockWarningTimer = 0;
      showLockWarning = false;
    }
  } else {
    touchingGround = false;
    lockTimer = 0;
    lockWarningTimer = 0;
    showLockWarning = false;
  }

  draw();
  requestAnimationFrame(loop);
}
  function updateDASARR(dt) {
    for(const key in keyState) {
      if(!keyState[key]) continue;
      if(!dasTimer[key]) dasTimer[key] = 0;
      if(!arrTimer[key]) arrTimer[key] = 0;
      dasTimer[key] += dt;
      if(dasTimer[key] >= DAS) {
        arrTimer[key] += dt;
        if(ARR === 0) {
          if(key === 'moveLeft') {
            while(move(-1));
          } else if(key === 'moveRight') {
            while(move(1));
          }
          dasTimer[key] = DAS;
          arrTimer[key] = 0;
        } else {
          while(arrTimer[key] >= ARR) {
            arrTimer[key] -= ARR;
            if(key === 'moveLeft') {
              if(!move(-1)) break;
            } else if(key === 'moveRight') {
              if(!move(1)) break;
            }
          }
        }
      }
    }
  }
  function buildPreviewCanvases(){
    previewsEl.innerHTML = '';
    for(let i=0;i<previewCount;i++){
      const box = document.createElement('div');
      box.className = 'preview-item';
      const cv = document.createElement('canvas');
      cv.width = 140; cv.height = 100;
      box.appendChild(cv);
      previewsEl.appendChild(box);
    }
  }
  function updateStats(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
    comboEl.textContent = combo;
    if(combo > 1) {
      comboInd.classList.add('active');
    } else {
      comboInd.classList.remove('active');
    }
    if(b2bCount > 0) {
      b2bInd.classList.add('active');
    } else {
      b2bInd.classList.remove('active');
    }
    if(gameMode === 'practice') {
      btnUndo.disabled = historyIndex <= 0;
      btnRedo.disabled = historyIndex >= historyStates.length - 1;
    }
  }
  function resetGame(){
  sessionStats = {
    tetrises: 0,
    tSpins: 0,
    perfectClears: 0,
    maxCombo: 0,
    startTime: Date.now()
  };
  board = createMatrix(COLS, ROWS);
  score = 0; lines = 0; combo = 0; b2bCount = 0;
  level = startLevel;
  if(gameMode === 'master') {
    gravity = 0;
    lockDelay = 200;
  } else {
    gravity = levelSpeed(level);
    lockDelay = parseInt(cfgLockDelay.value);
  }
  queue = [];
  bag = [];
  particles = [];
  hardDropping = false;
  clearingLines = false;
  clearAnimationTimer = 0;
  lastClearWasSpecial = false;
  lastActionWasRotate = false;
  tSpinType = null;
  gameTimer = 0;
  timerRunning = false;
  lockWarningTimer = 0;
  showLockWarning = false;
  lockMoveResets = 0;
  lowestY = -999;
  pendingInputs = [];
  softDropActive = false;
  softDropTimer = 0;
  gameOverAnimating = false;
  const holdBox = document.querySelector('.hold-box');
  if(holdBox) {
    holdBox.classList.remove('locked');
  }
  if(gameMode === 'cheese') {
    initCheeseMode();
  }
  historyStates = [];
  historyIndex = -1;
  refillBag();
  for(let i=0;i<previewCount;i++){
    if(!bag.length) refillBag();
    queue.push(bag.pop());
  }
  holdType = null;
  holdLocked = false;
  gameOver = false;
  updateStats();
  buildPreviewCanvases();
  updateModeDisplay();
  spawn();
  redrawSidePanels();
  if(gameMode === 'practice') {
    saveHistory();
  }
  draw();
  dropTimer = 0;
  lastTS = 0;
  lockTimer = 0;
  touchingGround = false;
}
  function hold(){
  const holdBox = document.querySelector('.hold-box');
  if (!piece) return;
  if (gameOverAnimating) return;

  if (holdLocked || hardDropping) {
    if (holdLocked && holdBox) {
      holdBox.classList.add('shake');
      setTimeout(() => holdBox.classList.remove('shake'), 300);
      vibrate(10);
    }
    return;
  }

  ensureAudioUnlocked();
  audioSystem.playSound('hold');

  const currentType = piece.type;

  const applySpawnSafety = () => {
    if (!piece) return;
    lockTimer = 0;
    lockWarningTimer = 0;
    showLockWarning = false;
    touchingGround = false;
    lastActionWasRotate = false;
    tSpinType = null;
    lastKickIndex = 0;
    lockMoveResets = 0;
    lowestY = piece.y;

    if (piece.type === 'I') {
      piece.y = -2;
    } else {
      piece.y = 0;
    }

    if (collide(board, piece)) {
      piece.y -= 1;
      if (collide(board, piece)) {
        endGame();
        return;
      }
    }

    lowestY = piece.y;
    piece.animX = piece.x;
    piece.animY = piece.y;
  };

  const centerPiece = () => {
    piece.x = Math.floor(COLS / 2) - Math.ceil(piece.m[0].length / 2);
    if (piece.x < 0) piece.x = 0;
    if (piece.x + piece.m[0].length > COLS) piece.x = COLS - piece.m[0].length;
  };

  if (!holdType) {
    holdType = currentType;
    if (holdBox) {
      holdBox.classList.remove('locked');
      holdBox.classList.add('animate-in');
      setTimeout(() => holdBox.classList.remove('animate-in'), 500);
    }
    piece = newPiece(takeFromQueue());
    centerPiece();
    applySpawnSafety();
  } else {
    if (holdBox) {
      holdBox.classList.add('animate-out');
    }
    const nextType = holdType;
    holdType = currentType;
    piece = newPiece(nextType);
    centerPiece();
    applySpawnSafety();

    setTimeout(() => {
      if (holdBox) {
        holdBox.classList.remove('animate-out');
        holdBox.classList.add('animate-in');
        setTimeout(() => holdBox.classList.remove('animate-in'), 500);
      }
      redrawSidePanels();
      draw();
    }, 0);
  }

  holdLocked = true;
  if (holdBox) {
    holdBox.classList.add('locked');
  }

  redrawSidePanels();
  draw();
  vibrate(8);
}
let pendingInputs = [];
const MAX_PENDING_INPUTS = 5;
  function inputAction(act) {
    ensureAudioUnlocked();
    const blockedByUI = shouldBlockGameplayInput();

    if (gameOver || gameOverAnimating) return;

    if (act !== 'pause') {
        if (!running || paused) return;
        if (blockedByUI) return;
    } else {
        if (!running || isCountingDown) return;
        if (blockedByUI && !paused) return;
    }

    highlightKey(act);

    if (clearingLines && act !== 'pause') {
        if (pendingInputs.length < MAX_PENDING_INPUTS) {
            const now = Date.now();
            pendingInputs.push({
                action: act,
                time: now,
                validUntil: now + CLEAR_ANIMATION_DURATION + 200
            });
        }
        return;
    }

    executeAction(act);
    draw();
}
function executeAction(act) {
    switch(act) {
        case 'moveLeft':
        case 'left':
            move(-1);
            break;
        case 'moveRight':
        case 'right':
            move(1);
            break;
        case 'rotateRight':
            rotate(+1);
            break;
        case 'rotateLeft':
            rotate(-1);
            break;
        case 'softDrop':
        case 'soft':
            softDropStep();
            break;
        case 'hardDrop':
        case 'hard':
            hardDrop();
            break;
        case 'hold':
            hold();
            break;
        case 'pause':
            togglePause();
            break;
    }
}
function processPendingInputs() {
    if (!pendingInputs || pendingInputs.length === 0) return;
    if (!running || paused || gameOver) {
        pendingInputs = [];
        return;
    }
    if (shouldBlockGameplayInput()) {
        pendingInputs = [];
        return;
    }

    const now = Date.now();
    const validInputs = pendingInputs.filter(input => {
        if (!input) return false;
        const t = input.time || 0;
        const until = input.validUntil || (t + 200);
        return now <= until;
    });

    for (const input of validInputs) {
        executeAction(input.action);
    }

    pendingInputs = [];
}

  window.addEventListener('keydown', onKeyDown, { passive: false });
  window.addEventListener('keyup', onKeyUp);
  cvs.addEventListener('touchstart', (e)=>{
    const t = e.changedTouches[0];
    touchStartX = t.clientX; touchStartY = t.clientY; touchStartTime = Date.now();
  }, {passive:true});
  cvs.addEventListener('touchmove', (e)=>{ e.preventDefault(); }, {passive:false});
  cvs.addEventListener('touchend', (e)=>{
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const dt = Date.now() - touchStartTime;
    const TH = 24;
    if(adx<TH && ady<TH && dt<220){
      const rect = cvs.getBoundingClientRect();
      const relY = t.clientY - rect.top;
      if(relY < rect.height*0.5) inputAction('rotateRight');
      else inputAction('soft');
      return;
    }
    if(adx > ady){
      if(dx > TH) inputAction('right');
      else if(dx < -TH) inputAction('left');
    }else{
      if(dy > TH) inputAction('soft');
      else if(dy < -TH) inputAction('hard');
    }
  }, {passive:false});
  function attachMobileHandlers(el) {
  if (!el) return;

  const actionMap = {
    left: 'moveLeft',
    right: 'moveRight',
    rotateLeft: 'rotateLeft',
    rotateRight: 'rotateRight',
    soft: 'softDrop',
    hard: 'hardDrop',
    hold: 'hold',
    pause: 'pause'
  };

  let activeTouchAction = null;
  let activeTouchBtn = null;
  let activeTouchId = null;

  const startContinuous = (mapped) => {
    if (mapped === 'moveLeft' || mapped === 'moveRight') {
      if (!keyState[mapped]) {
        keyState[mapped] = true;
        dasTimer[mapped] = 0;
        arrTimer[mapped] = 0;
        highlightKey(mapped);
        if (mapped === 'moveLeft') move(-1);
        else move(1);
      }
      return true;
    }
    if (mapped === 'softDrop') {
      if (!keyState[mapped]) {
        keyState[mapped] = true;
        startSoftDrop();
      }
      return true;
    }
    return false;
  };

  const stopContinuous = (mapped) => {
    if (mapped === 'moveLeft' || mapped === 'moveRight') {
      keyState[mapped] = false;
      dasTimer[mapped] = 0;
      arrTimer[mapped] = 0;
      return;
    }
    if (mapped === 'softDrop') {
      keyState[mapped] = false;
      stopSoftDrop();
      return;
    }
  };

  const releaseActiveTouch = () => {
    if (!activeTouchAction) return;
    stopContinuous(activeTouchAction);
    if (activeTouchBtn) activeTouchBtn.classList.remove('pressed');
    activeTouchAction = null;
    activeTouchBtn = null;
    activeTouchId = null;
  };

  el.addEventListener('click', (e) => {
    const t = e.target.closest('.btn');
    if (!t || !t.dataset.act) return;
    const action = t.dataset.act;
    const mapped = actionMap[action] || action;
    inputAction(mapped);
  });

  el.addEventListener('touchstart', (e) => {
    const t = e.target.closest('.btn');
    if (!t || !t.dataset.act) return;
    ensureAudioUnlocked();
    e.preventDefault();

    const touch = e.changedTouches && e.changedTouches[0];
    activeTouchId = touch ? touch.identifier : null;

    const action = t.dataset.act;
    const mapped = actionMap[action] || action;

    releaseActiveTouch();
    activeTouchAction = mapped;
    activeTouchBtn = t;
    t.classList.add('pressed');

    if (!startContinuous(mapped)) {
      inputAction(mapped);
    }
  }, { passive: false });

  el.addEventListener('touchend', (e) => {
    if (!activeTouchAction) return;
    if (activeTouchId == null) {
      releaseActiveTouch();
      return;
    }
    const touches = Array.from(e.changedTouches || []);
    if (touches.some(tt => tt.identifier === activeTouchId)) {
      releaseActiveTouch();
    }
  }, { passive: true });

  el.addEventListener('touchcancel', (e) => {
    if (!activeTouchAction) return;
    if (activeTouchId == null) {
      releaseActiveTouch();
      return;
    }
    const touches = Array.from(e.changedTouches || []);
    if (touches.some(tt => tt.identifier === activeTouchId)) {
      releaseActiveTouch();
    }
  }, { passive: true });

  el.addEventListener('touchmove', (e) => {
    if (!activeTouchAction || !activeTouchBtn) return;
    const touch = (e.touches && Array.from(e.touches).find(tt => tt.identifier === activeTouchId)) || null;
    if (!touch) return;

    const rect = activeTouchBtn.getBoundingClientRect();
    const inside = touch.clientX >= rect.left && touch.clientX <= rect.right &&
                   touch.clientY >= rect.top && touch.clientY <= rect.bottom;
    if (!inside) {
      releaseActiveTouch();
    }
  }, { passive: true });

  window.addEventListener('blur', releaseActiveTouch, { passive: true });
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) releaseActiveTouch();
  }, { passive: true });
}
  attachMobileHandlers(mobileControlsEl);
  attachMobileHandlers(mobileLeftEl);
  attachMobileHandlers(mobileRightEl);

  function releaseAllContinuousInputs() {
  const cont = ['moveLeft', 'moveRight', 'softDrop'];
  cont.forEach(a => {
    keyState[a] = false;
    dasTimer[a] = 0;
    arrTimer[a] = 0;
  });
  stopSoftDrop();
}

  function resize(){
    const wrap = cvs.parentElement;
    const w = wrap.clientWidth - 8;
    const h = wrap.clientHeight - 8;
    const blockW = Math.floor(w / COLS);
    const blockH = Math.floor(h / ROWS);
    BLOCK = Math.max(14, Math.min(blockW, blockH));
    cvs.width = COLS * BLOCK;
    cvs.height = ROWS * BLOCK;
    draw();
    redrawSidePanels();
  }
  window.addEventListener('resize', resize);
btnPlayPause.addEventListener('click', handlePlayPause);
btnRestart.addEventListener('click', () => {
  if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ã€‚')) {
    resetGame();
    resize();
    running = true;
    paused = true;
    showCountdown(() => {
      paused = false;
      timerRunning = true;
      btnPlayPause.textContent = 'â¸ æš‚åœ';
      sessionStats.startTime = Date.now();
      startProgressAutoSave();
      if(audioSystem) {
        audioSystem.startBGM(level);
      }
      lastTS = 0;
      requestAnimationFrame(loop);
    });
  }
});
btnSettings.addEventListener('click', ()=> showSettingsOverlay(true));
btnCloseSettings.addEventListener('click', ()=> showSettingsOverlay(false));
btnSaveStart.addEventListener('click', saveSettingsAndStart);
btnUndo.addEventListener('click', undo);
btnRedo.addEventListener('click', redo);
btnResetKeys.addEventListener('click', resetKeybindings);
btnHeaderToggle.addEventListener('click', ()=>{
  topHeader.classList.toggle('header-visible');
});
btnPauseResume.addEventListener('click', () => {
  hidePauseMenu();
  resumeGame();
});
btnPauseRestart.addEventListener('click', () => {
  hidePauseMenu();
  showSettingsOverlay(true, 'é‡æ–°å¼€å§‹');
});
btnPauseSettings.addEventListener('click', () => {
  hidePauseMenu();
  showSettingsOverlay(true);
});
btnGameoverRestart.addEventListener('click', () => {
  hideGameOverStats();
  showSettingsOverlay(true, 'é‡æ–°å¼€å§‹');
});
btnGameoverLeaderboard.addEventListener('click', () => {
  hideGameOverStats();
  showLeaderboard();
});
btnGameoverSettings.addEventListener('click', () => {
  hideGameOverStats();
  showSettingsOverlay(true);
});
btnLeaderboard.addEventListener('click', showLeaderboard);
btnCloseLeaderboard.addEventListener('click', hideLeaderboard);
btnClearLeaderboard.addEventListener('click', () => {
  if (confirm(`ç¡®å®šè¦æ¸…ç©º ${MODE_NAMES[currentLeaderboardMode]} çš„æ’è¡Œæ¦œå—ï¼Ÿ`)) {
    storageManager.clearLeaderboard(currentLeaderboardMode);
    renderLeaderboard(currentLeaderboardMode);
  }
});
leaderboardTabs.addEventListener('click', (e) => {
  const tab = e.target.closest('.leaderboard-tab');
  if (tab) {
    renderLeaderboard(tab.dataset.mode);
  }
});
cfgSFXVolume.addEventListener('input', (e) => {
  if (audioSystem) {
    audioSystem.setSFXVolume(parseInt(e.target.value) / 100);
  }
});
cfgMusicVolume.addEventListener('input', (e) => {
  if (audioSystem) {
    audioSystem.setMusicVolume(parseInt(e.target.value) / 100);
  }
});
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const tab = btn.dataset.tab;
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
    });
  });
  document.querySelectorAll('.mode-card').forEach(card => {
    card.addEventListener('click', () => {
      document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      gameMode = card.dataset.mode;
      document.getElementById('cheeseSettings').style.display =
        gameMode === 'cheese' ? 'block' : 'none';
      document.getElementById('ultraSettings').style.display =
        gameMode === 'ultra' ? 'block' : 'none';
    });
  });
  function showSettingsOverlay(v, title) {
  if (v) {
    const h3 = document.getElementById('modalTitle');
    h3.textContent = title || 'æ¸¸æˆè®¾ç½®';
    if (title === 'é€‰æ‹©æ¸¸æˆæ¨¡å¼') btnCloseSettings.style.display = 'none';
    else btnCloseSettings.style.display = '';

    pausedBeforeOverlay = paused;

    releaseAllContinuousInputs();

    if (running && !paused && !gameOver) {
      paused = true;
      timerRunning = false;
      if (btnPlayPause) btnPlayPause.textContent = 'â–¶ ç»§ç»­';
      updateMobilePauseButtons('â–¶ ç»§ç»­');
      if (audioSystem) audioSystem.stopBGM();
    }
  } else {
    releaseAllContinuousInputs();
    if (running && !gameOver && paused && !pausedBeforeOverlay) {
      paused = false;
      timerRunning = true;
      if (btnPlayPause) btnPlayPause.textContent = 'â¸ æš‚åœ';
      updateMobilePauseButtons('â¸ æš‚åœ');
      ensureAudioUnlocked();
      if (audioSystem) audioSystem.startBGM(level);
      safeRequestLoop();
    }
  }

  overlay.classList.toggle('visible', v);
}

  function applySkin(name){
    skin = SKINS[name] || SKINS.classic;
  }
  function clampInt(v,min,max){
    v = parseInt(v,10);
    if(isNaN(v)) v = min;
    return Math.max(min, Math.min(max, v));
  }
  function saveSettingsAndStart(){
    COLS = clampInt(cfgCols.value,6,20);
    ROWS = clampInt(cfgRows.value,12,40);
    previewCount = clampInt(cfgPreview.value,1,6);
    ghostEnabled = cfgGhost.value==='on';
    lockDelay = clampInt(cfgLockDelay.value,200,2000);
    DAS = clampInt(cfgDAS.value, 0, 300);
    ARR = clampInt(cfgARR.value, 0, 100);
    applySkin(cfgSkin.value);
    vibrationEnabled = cfgVibration.value === 'on';
    startLevel = clampInt(cfgStartLevel.value,1,20);
    level = startLevel;
    gravity = levelSpeed(level);
    cheeseLines = clampInt(cfgCheeseLines.value, 5, 18);
    initialCheeseLines = cheeseLines;
    ultraTimeLimit = clampInt(cfgUltraTime.value, 60, 300);
    saveCurrentSettings();
    if (audioSystem) {
      audioSystem.setSFXVolume(parseInt(cfgSFXVolume.value) / 100);
      audioSystem.setMusicVolume(parseInt(cfgMusicVolume.value) / 100);
    }
    resetGame();
    resize();
    showSettingsOverlay(false);
    running = true;
    paused = true;
    showCountdown(() => {
      paused = false;
      timerRunning = true;
      btnPlayPause.textContent = 'â¸ æš‚åœ';
      sessionStats.startTime = Date.now();
      startProgressAutoSave();
      if(audioSystem) {
        audioSystem.startBGM(level);
      }
      lastTS = 0;
      requestAnimationFrame(loop);
    });
  }
function handlePlayPause() {
  if (isCountingDown) return;
  if (gameOver) {
    showSettingsOverlay(true, 'é‡æ–°å¼€å§‹');
    return;
  }
  if (!running) {
    showSettingsOverlay(true, 'é€‰æ‹©æ¸¸æˆæ¨¡å¼');
    return;
  }
  if (paused) {
    hidePauseMenu();
    resumeGame();
  } else {
    pauseGame();
  }
}
let gameOverAnimating = false;
let gameOverAnimRow = 0;
function spawnFractureBurstAtCell(cx, cy, baseColor, intensity = 1) {
  const px = cx * BLOCK + BLOCK / 2;
  const py = cy * BLOCK + BLOCK / 2;

  const count = Math.floor(10 + Math.random() * 10 + intensity * 10);
  for (let i = 0; i < count; i++) {
    const p = new Particle(px, py, baseColor, (Math.random() < 0.35 ? 'spark' : 'normal'));
    p.vx *= 0.55 + Math.random() * 0.35;
    p.vy *= 0.55 + Math.random() * 0.35;
    p.vx += (Math.random() - 0.5) * (6 + intensity * 6);
    p.vy += (Math.random() - 0.5) * (6 + intensity * 6);

    p.size = Math.max(1.5, p.size * (0.55 + Math.random() * 0.35));
    p.decay = Math.min(0.08, (p.decay || 0.02) * (1.2 + Math.random() * 0.8));
    p.gravity = (p.gravity || 0.2) * (0.8 + Math.random() * 0.6);
    particles.push(p);
  }

  const edgeCount = Math.floor(6 + Math.random() * 8 + intensity * 6);
  for (let i = 0; i < edgeCount; i++) {
    const ex = cx * BLOCK + (Math.random() < 0.5 ? 2 : BLOCK - 2);
    const ey = cy * BLOCK + 4 + Math.random() * (BLOCK - 8);
    const spark = new Particle(ex, ey, '#ffffff', 'spark');
    spark.vx *= 0.7;
    spark.vy *= 0.7;
    spark.size = 1.5 + Math.random() * 2.5;
    spark.decay = 0.04 + Math.random() * 0.03;
    particles.push(spark);
  }
}

function applyGameOverCrushRow(rowY, overlayType = 'G') {
  const crushIntensity = 1 + (ROWS - 1 - rowY) / Math.max(1, ROWS - 1);

  for (let x = 0; x < COLS; x++) {
    const t = board[rowY][x];
    if (t && t !== overlayType) {
      const color = skin[t] || '#9aa3b2';
      spawnFractureBurstAtCell(x, rowY, color, crushIntensity);
    }
    board[rowY][x] = overlayType;
  }

  const shockY = rowY - 1;
  if (shockY >= 0) {
    for (let x = 0; x < COLS; x++) {
      const t2 = board[shockY][x];
      if (t2 && t2 !== overlayType && Math.random() < 0.25) {
        const color2 = skin[t2] || '#9aa3b2';
        spawnFractureBurstAtCell(x, shockY, color2, 0.6 + crushIntensity * 0.25);
      }
    }
  }
}
function finalizeGameOverBoard(overlayType = 'G') {
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      board[y][x] = overlayType;
    }
  }
}
function startGameOverCrushAnimation(callback, overlayType = 'G') {
  gameOverAnimating = true;
  gameOverAnimRow = ROWS - 1;

  const stepMs = 26;
  let lastSoundAt = 0;

  function step() {
    if (gameOverAnimRow < 0) {
      finalizeGameOverBoard(overlayType);
      draw();
      gameOverAnimating = false;
      setTimeout(callback, 220);
      return;
    }

    applyGameOverCrushRow(gameOverAnimRow, overlayType);

    const now = Date.now();
    if (audioSystem && now - lastSoundAt > 55) {
      audioSystem.playSound('lock', 0.9);
      lastSoundAt = now;
    }
    if ((ROWS - 1 - gameOverAnimRow) % 3 === 0) vibrate(6);

    if (screenShaker) {
      const depth = (ROWS - 1 - gameOverAnimRow) / Math.max(1, ROWS - 1);
      if (depth > 0.75) screenShaker.mediumShake();
      else screenShaker.smallShake();
    }

    draw();
    gameOverAnimRow--;
    setTimeout(step, stepMs);
  }

  step();
}
function updateMobilePauseButtons(label) {
  const btns = document.querySelectorAll('.btn[data-act="pause"]');
  btns.forEach(b => {
    b.textContent = label;
  });
}
function pauseGame() {
  releaseAllContinuousInputs();
  paused = true;
  timerRunning = false;
  btnPlayPause.textContent = 'â–¶ ç»§ç»­';
  updateMobilePauseButtons('â–¶ ç»§ç»­');
  showPauseMenu();
  if (audioSystem) audioSystem.stopBGM();
}

function resumeGame() {
  releaseAllContinuousInputs();
  paused = false;
  timerRunning = true;
  btnPlayPause.textContent = 'â¸ æš‚åœ';
  updateMobilePauseButtons('â¸ æš‚åœ');
  ensureAudioUnlocked();
  if (audioSystem) audioSystem.startBGM(level);
  safeRequestLoop();
}
function togglePause(){
  if(!running || isCountingDown) return;
  if (paused) {
    hidePauseMenu();
    resumeGame();
  } else {
    pauseGame();
  }
}
function endGame(message, isVictory = false) {
  if (gameOver) return;

  gameOver = true;
  timerRunning = false;
  releaseAllContinuousInputs();

  if (audioSystem) audioSystem.stopBGM();

  if (isVictory) {
    const rank = saveGameResult();
    stopProgressAutoSave();
    running = false;
    paused = false;
    btnPlayPause.textContent = 'â–¶ å¼€å§‹';
    if (audioSystem) audioSystem.playSound('levelUp');
    if (screenShaker) screenShaker.bigShake();
    vibrate([50, 100, 50]);
    showGameOverStats(message, true, rank);
    return;
  }

  const overlayType = 'G';

  startGameOverCrushAnimation(() => {
    const rank = saveGameResult();
    stopProgressAutoSave();
    running = false;
    paused = false;
    btnPlayPause.textContent = 'â–¶ å¼€å§‹';
    if (audioSystem) audioSystem.playSound('gameOver');
    if (screenShaker) screenShaker.bigShake();
    vibrate([50, 100, 50]);
    showGameOverStats(message, false, rank);
  }, overlayType);
}
  function updateTimer(dt) {
  if (!timerRunning) return;

  gameTimer += dt;

  if (gameMode === 'sprint' || gameMode === 'cheese') {
    timerDisplay.className = 'timer-display';
    timerDisplay.textContent = formatTime(gameTimer);
    return;
  }

  if (gameMode === 'ultra') {
    const remaining = ultraTimeLimit * 1000 - gameTimer;
    const safeRemaining = Math.max(0, remaining);

    timerDisplay.textContent = formatTime(safeRemaining);

    if (safeRemaining < 10000) {
      timerDisplay.className = 'timer-display danger';
    } else if (safeRemaining < 30000) {
      timerDisplay.className = 'timer-display warning';
    } else {
      timerDisplay.className = 'timer-display';
    }
  }
}
const pad = n => String(n).padStart(2, '0');
function formatTime(ms) {
  const totalSeconds = Math.floor(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  const centiseconds = Math.floor((ms % 1000) / 10);
  return `${pad(minutes)}:${pad(seconds)}.${pad(centiseconds)}`;
}
  function updateModeDisplay() {
    modeDisplayEl.textContent = MODE_NAMES[gameMode] || gameMode;
    if(gameMode === 'sprint' || gameMode === 'ultra' || gameMode === 'cheese') {
      timerContainer.style.display = 'block';
      timerDisplay.className = 'timer-display';
    } else {
      timerContainer.style.display = 'none';
    }
    if(gameMode === 'cheese') {
      cheeseContainer.style.display = 'block';
    } else {
      cheeseContainer.style.display = 'none';
    }
    if(gameMode === 'practice') {
      undoControls.classList.add('visible');
    } else {
      undoControls.classList.remove('visible');
    }
  }
  function initCheeseMode() {
    const startRow = ROWS - cheeseLines;
    for(let y = startRow; y < ROWS; y++) {
      const holePos = Math.floor(Math.random() * COLS);
      for(let x = 0; x < COLS; x++) {
        if(x !== holePos) {
          board[y][x] = 'G';
        }
      }
    }
    updateCheeseProgress();
  }
  function countCheeseLines() {
    let count = 0;
    for(let y = 0; y < ROWS; y++) {
      if(board[y].some(cell => cell === 'G')) {
        count++;
      }
    }
    return count;
  }
  function updateCheeseProgress() {
    const remaining = countCheeseLines();
    cheeseRemaining.textContent = remaining;
    const progress = Math.max(0, (initialCheeseLines - remaining) / initialCheeseLines * 100);
    cheeseProgress.style.width = progress + '%';
  }
  function checkModeCompletion() {
  if (gameMode === 'sprint' && lines >= 40) {
    endGame('å®Œæˆï¼', true);
  } else if (gameMode === 'cheese' && countCheeseLines() === 0) {
    endGame('æ¸…ç†å®Œæˆï¼', true);
  }
}
  function saveHistory() {
  if(gameMode !== 'practice') return;
  const state = {
    board: cloneMatrix(board),
    score,
    lines,
    level,
    combo,
    b2bCount,
    lastClearWasSpecial,
    holdType,
    holdLocked,
    queue: [...queue],
    bag: [...bag],
    lockMoveResets,
    lowestY,
    piece: piece ? {
      type: piece.type,
      x: piece.x,
      y: piece.y,
      m: piece.m.map(row => row.slice()),
      rotation: piece.rotation,
      color: piece.color,
      animX: piece.animX,
      animY: piece.animY
    } : null
  };
  historyStates = historyStates.slice(0, historyIndex + 1);
  historyStates.push(JSON.parse(JSON.stringify(state)));
  historyIndex = historyStates.length - 1;
  while(historyStates.length > MAX_HISTORY) {
    historyStates.shift();
    historyIndex--;
  }
  updateStats();
}
  function undo() {
    if(gameMode !== 'practice' || historyIndex <= 0) return;
    historyIndex--;
    restoreHistory();
    vibrate(5);
  }
  function redo() {
    if(gameMode !== 'practice' || historyIndex >= historyStates.length - 1) return;
    historyIndex++;
    restoreHistory();
    vibrate(5);
  }
  function restoreHistory() {
  const state = historyStates[historyIndex];
  board = cloneMatrix(state.board);
  score = state.score;
  lines = state.lines;
  level = state.level;
  combo = state.combo;
  b2bCount = state.b2bCount;
  lastClearWasSpecial = state.lastClearWasSpecial;
  holdType = state.holdType;
  holdLocked = state.holdLocked;
  queue = [...state.queue];
  bag = [...state.bag];
  lockMoveResets = state.lockMoveResets || 0;
  lowestY = state.lowestY || -999;
  if(state.piece) {
    piece = {
      type: state.piece.type,
      x: state.piece.x,
      y: state.piece.y,
      m: state.piece.m.map(row => row.slice()),
      rotation: state.piece.rotation,
      color: skin[state.piece.type],
      animX: state.piece.animX,
      animY: state.piece.animY
    };
  } else {
    piece = null;
  }
  lockTimer = 0;
  lockWarningTimer = 0;
  showLockWarning = false;
  touchingGround = false;
  const holdBox = document.querySelector('.hold-box');
  if(holdBox) {
    holdBox.classList.toggle('locked', holdLocked);
  }
  updateStats();
  redrawSidePanels();
  draw();
}
  function buildKeybindUI() {
    keybindGrid.innerHTML = '';
    const actionNames = {
        moveLeft: 'å·¦ç§»',
        moveRight: 'å³ç§»',
        softDrop: 'è½¯é™',
        hardDrop: 'ç¡¬é™',
        rotateRight: 'é¡ºæ—¶é’ˆæ—‹è½¬ â†»',
        rotateLeft: 'é€†æ—¶é’ˆæ—‹è½¬ â†º',
        hold: 'æš‚å­˜',
        pause: 'æš‚åœ'
    };
    for(const action in keyBindings) {
        const item = document.createElement('div');
        item.className = 'keybind-item';
        const label = document.createElement('div');
        label.className = 'keybind-label';
        label.textContent = actionNames[action] || action;
        const button = document.createElement('div');
        button.className = 'keybind-button';
        button.textContent = formatKeys(keyBindings[action]);
        button.dataset.action = action;
        button.addEventListener('click', () => {
            startListening(action, button);
        });
        item.appendChild(label);
        item.appendChild(button);
        keybindGrid.appendChild(item);
    }
}

  function normalizeKeyName(key) {
  if (key == null) return '';
  let k = String(key);

  if (k === ' ') k = 'Space';
  if (k === 'Spacebar') k = 'Space';

  if (k === 'Esc') k = 'Escape';
  if (k === 'Left') k = 'ArrowLeft';
  if (k === 'Right') k = 'ArrowRight';
  if (k === 'Up') k = 'ArrowUp';
  if (k === 'Down') k = 'ArrowDown';

  if (k === 'Ctrl') k = 'Control';
  if (k === 'Del') k = 'Delete';

  if (k.length === 1) k = k.toLowerCase();
  return k;
}

function normalizeCodeName(code) {
  if (!code) return '';
  let c = String(code);

  if (c === 'Spacebar') c = 'Space';

  if (c === 'Left') c = 'ArrowLeft';
  if (c === 'Right') c = 'ArrowRight';
  if (c === 'Up') c = 'ArrowUp';
  if (c === 'Down') c = 'ArrowDown';

  return c;
}

function getEventKeyTokens(e) {
  const tokens = new Set();

  const k = normalizeKeyName(e.key);
  const c = normalizeCodeName(e.code);

  if (k) tokens.add(k);
  if (c) tokens.add(c);

  if (k === ' ') tokens.add('Space');
  if (k === 'Space') tokens.add(' ');
  if (c === 'Space') tokens.add('Space');
  if (c === 'Space') tokens.add(' ');

  return tokens;
}

function matchBinding(action, e) {
    const binds = keyBindings[action] || [];
    if (!binds.length) return false;

    const tokens = getEventKeyTokens(e);

    for (const raw of binds) {
        const bCode = normalizeCodeName(raw);
        const bKey = normalizeKeyName(raw);

        if (bCode && tokens.has(bCode)) return true;
        if (bKey && tokens.has(bKey)) return true;

        if ((raw === ' ' || raw === 'Space' || raw === 'Spacebar' || bKey === 'Space' || bCode === 'Space') &&
            (tokens.has('Space') || tokens.has(' '))) {
            return true;
        }
    }
    return false;
}

  function formatKeys(keys) {
  if (!keys || keys.length === 0) return 'æœªè®¾ç½®';

  return keys.map(raw => {
    const k = normalizeKeyName(raw);
    if (k === 'Space') return 'Space';
    if (k.length === 1) return k.toUpperCase();
    return k;
  }).join(', ');
}

  function assignKey(action, key) {
  const nk = normalizeKeyName(key);
  if (!nk) return;

  for (const act in keyBindings) {
    keyBindings[act] = (keyBindings[act] || [])
      .map(v => normalizeKeyName(v))
      .filter(k => k !== nk);
  }

  keyBindings[action] = [nk];
  storageManager.saveKeybindings(keyBindings);

  const button = document.querySelector(`[data-action="${action}"]`);
  if (button) {
    button.textContent = formatKeys(keyBindings[action]);
    button.classList.remove('listening');
  }
  listeningForKey = null;
}

function assignKeyFromEvent(action, e) {
    const code = normalizeCodeName(e.code);
    const key = normalizeKeyName(e.key);

    const tokens = [];
    if (code) tokens.push(code);

    if (key) {
        if (key === 'Space' && !tokens.includes('Space')) tokens.push('Space');
        else if (key !== code && !tokens.includes(key)) tokens.push(key);
    }

    for (const act in keyBindings) {
        const arr = keyBindings[act] || [];
        keyBindings[act] = arr
            .map(v => {
                const nc = normalizeCodeName(v);
                const nk = normalizeKeyName(v);
                return nc || nk || v;
            })
            .filter(v => !tokens.includes(v));
    }

    keyBindings[action] = tokens.length ? tokens : [code || key];

    storageManager.saveKeybindings(keyBindings);

    const button = document.querySelector(`[data-action="${action}"]`);
    if (button) {
        button.textContent = formatKeys(keyBindings[action]);
        button.classList.remove('listening');
    }
    listeningForKey = null;
}

function shouldBlockGameplayInput() {
  const overlayVisible = overlay && overlay.classList.contains('visible');
  const leaderboardVisible = leaderboardOverlay && leaderboardOverlay.classList.contains('visible');
  const pauseVisible = pauseOverlay && pauseOverlay.classList.contains('visible');
  return overlayVisible || leaderboardVisible || pauseVisible;
}

function onKeyDown(e) {
  if (listeningForKey) {
    e.preventDefault();
    assignKeyFromEvent(listeningForKey, e);
    return;
  }

  if (gameMode === 'practice' && e.ctrlKey) {
    if (e.key === 'z' || e.key === 'Z') {
      e.preventDefault();
      undo();
      return;
    }
    if (e.key === 'y' || e.key === 'Y') {
      e.preventDefault();
      redo();
      return;
    }
  }

  for (const action in keyBindings) {
    if (!matchBinding(action, e)) continue;

    e.preventDefault();

    if (action === 'pause') {
      if (!running || isCountingDown || gameOver) return;
    } else {
      if (!running || paused || gameOver) return;
      if (shouldBlockGameplayInput()) return;
    }

    ensureAudioUnlocked();

    if (action === 'moveLeft' || action === 'moveRight') {
      if (!keyState[action]) {
        keyState[action] = true;
        dasTimer[action] = 0;
        arrTimer[action] = 0;
        highlightKey(action);
        if (action === 'moveLeft') move(-1);
        else move(1);
      }
      return;
    }

    if (action === 'softDrop') {
      if (!keyState[action]) {
        keyState[action] = true;
        startSoftDrop();
      }
      return;
    }

    inputAction(action);
    return;
  }
}

function onKeyUp(e) {
  for (const action in keyBindings) {
    if (!matchBinding(action, e)) continue;

    if (action === 'moveLeft' || action === 'moveRight') {
      keyState[action] = false;
      dasTimer[action] = 0;
      arrTimer[action] = 0;
      return;
    }

    if (action === 'softDrop') {
      keyState[action] = false;
      stopSoftDrop();
      return;
    }
  }
}

  function startListening(action, button) {
    if(listeningForKey) {
      document.querySelector('.keybind-button.listening').classList.remove('listening');
    }
    listeningForKey = action;
    button.classList.add('listening');
    button.textContent = 'æŒ‰ä¸‹æŒ‰é”®...';
  }
  function resetKeybindings() {
  keyBindings = JSON.parse(JSON.stringify(DEFAULT_KEYBINDS));
  for (const action in keyBindings) {
    keyBindings[action] = (keyBindings[action] || []).map(normalizeKeyName);
  }
  storageManager.saveKeybindings(keyBindings);
  buildKeybindUI();
}
function showLeaderboard() {
  updateGlobalStatsDisplay();
  renderLeaderboard(currentLeaderboardMode);
  leaderboardOverlay.classList.add('visible');

  if (running && !paused && !gameOver) {
    releaseAllContinuousInputs();
    togglePause();
  }
}

function hideLeaderboard() {
  leaderboardOverlay.classList.remove('visible');
}
function updateGlobalStatsDisplay() {
  const stats = storageManager.loadStatistics();
  statTotalGames.textContent = stats.totalGames.toLocaleString();
  statTotalLines.textContent = stats.totalLines.toLocaleString();
  statTotalScore.textContent = formatLargeNumber(stats.totalScore);
  statPlayTime.textContent = formatPlayTime(stats.totalPlayTime);
  statTetrises.textContent = stats.tetrises.toLocaleString();
  statTSpins.textContent = stats.tSpins.toLocaleString();
}
function formatLargeNumber(num) {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + 'M';
  } else if (num >= 1000) {
    return (num / 1000).toFixed(1) + 'K';
  }
  return num.toLocaleString();
}

function formatPlayTime(ms) {
  const hours = Math.floor(ms / 3600000);
  const minutes = Math.floor((ms % 3600000) / 60000);
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
}

function renderLeaderboard(mode) {
  currentLeaderboardMode = mode;
  const leaderboard = storageManager.loadLeaderboard();
  const entries = leaderboard[mode] || [];

  leaderboardTabs.querySelectorAll('.leaderboard-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.mode === mode);
  });

  if (mode === 'sprint' || mode === 'cheese') {
    scoreHeader.textContent = 'ç”¨æ—¶';
  } else {
    scoreHeader.textContent = 'åˆ†æ•°';
  }

  if (entries.length === 0) {
    leaderboardContent.innerHTML = '<div class="leaderboard-empty">æš‚æ— è®°å½•ï¼Œå¿«æ¥åˆ›é€ å†å²ï¼</div>';
    return;
  }

  let html = '';
  entries.forEach((entry, index) => {
    const rank = index + 1;
    let rankClass = '';
    if (rank === 1) rankClass = 'gold';
    else if (rank === 2) rankClass = 'silver';
    else if (rank === 3) rankClass = 'bronze';

    const scoreDisplay = (mode === 'sprint' || mode === 'cheese')
      ? formatTime(entry.time)
      : entry.score.toLocaleString();

    const dateDisplay = formatDate(entry.date);

    html += `
      <div class="leaderboard-row">
        <div class="leaderboard-rank ${rankClass}">#${rank}</div>
        <div class="leaderboard-name">${entry.name || 'ç©å®¶'}</div>
        <div class="leaderboard-score">${scoreDisplay}</div>
        <div class="leaderboard-date">${dateDisplay}</div>
      </div>
    `;
  });

  leaderboardContent.innerHTML = html;
}

function formatDate(isoString) {
  const date = new Date(isoString);
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const hours = date.getHours().toString().padStart(2, '0');
  const minutes = date.getMinutes().toString().padStart(2, '0');
  return `${month}/${day} ${hours}:${minutes}`;
}

function saveGameResult() {
  if (gameMode === 'practice') return;

  const playTime = Date.now() - sessionStats.startTime;

  storageManager.updateStatistics({
    lines: lines,
    score: score,
    playTime: playTime,
    maxCombo: sessionStats.maxCombo,
    tetrises: sessionStats.tetrises,
    tSpins: sessionStats.tSpins,
    perfectClears: sessionStats.perfectClears
  });

  const entry = {
    name: 'ç©å®¶',
    score: score,
    lines: lines,
    level: level,
    time: gameTimer
  };

  const rank = storageManager.addToLeaderboard(gameMode, entry);
  storageManager.clearGameProgress();
  return rank;
}

function saveCurrentProgress() {
  if (!running || gameOver || gameMode === 'practice') return;

  const progress = {
    board: cloneMatrix(board),
    score: score,
    lines: lines,
    level: level,
    combo: combo,
    b2bCount: b2bCount,
    lastClearWasSpecial: lastClearWasSpecial,
    holdType: holdType,
    holdLocked: holdLocked,
    queue: [...queue],
    bag: [...bag],
    gameMode: gameMode,
    gameTimer: gameTimer,
    piece: piece ? {
      type: piece.type,
      x: piece.x,
      y: piece.y,
      m: piece.m.map(row => [...row]),
      rotation: piece.rotation
    } : null,
    sessionStats: {...sessionStats},
    savedAt: Date.now()
  };

  storageManager.saveGameProgress(progress);
}

function loadSavedProgress() {
  const progress = storageManager.loadGameProgress();
  if (!progress) return false;

  if (Date.now() - progress.savedAt > 24 * 60 * 60 * 1000) {
    storageManager.clearGameProgress();
    return false;
  }

  return progress;
}

function restoreGameProgress(progress) {
  board = cloneMatrix(progress.board);
  score = progress.score;
  lines = progress.lines;
  level = progress.level;
  combo = progress.combo;
  b2bCount = progress.b2bCount;
  lastClearWasSpecial = progress.lastClearWasSpecial;
  holdType = progress.holdType;
  holdLocked = progress.holdLocked;
  queue = [...progress.queue];
  bag = [...progress.bag];
  gameMode = progress.gameMode;
  gameTimer = progress.gameTimer;

  sessionStats = { ...progress.sessionStats };
  sessionStats.startTime = Date.now() - gameTimer;

  if (progress.piece) {
    piece = {
      type: progress.piece.type,
      x: progress.piece.x,
      y: progress.piece.y,
      m: progress.piece.m.map(row => [...row]),
      rotation: progress.piece.rotation,
      color: skin[progress.piece.type],
      animX: progress.piece.x,
      animY: progress.piece.y
    };
  } else {
    piece = null;
  }

  gravity = (gameMode === 'master') ? 0 : levelSpeed(level);

  lockTimer = 0;
  lockWarningTimer = 0;
  showLockWarning = false;
  touchingGround = false;

  timerDisplay.className = 'timer-display';

  gameOver = false;
  running = false;
  paused = false;

  buildPreviewCanvases();
  updateModeDisplay();
  updateStats();
  redrawSidePanels();
  resize();
  draw();

  const holdBox = document.querySelector('.hold-box');
  if (holdBox) holdBox.classList.toggle('locked', holdLocked);

  storageManager.clearGameProgress();
  return true;
}

let progressSaveInterval = null;

function startProgressAutoSave() {
  stopProgressAutoSave();
  progressSaveInterval = setInterval(() => {
    if (running && !paused && !gameOver) {
      saveCurrentProgress();
    }
  }, 30000);
}

function stopProgressAutoSave() {
  if (progressSaveInterval) {
    clearInterval(progressSaveInterval);
    progressSaveInterval = null;
  }
}

window.addEventListener('beforeunload', () => {
  if (running && !gameOver) {
    saveCurrentProgress();
  }
});

document.addEventListener('visibilitychange', () => {
  if (document.hidden && running && !gameOver) {
    saveCurrentProgress();
  }
});

function saveCurrentSettings() {
  const settings = {
    cols: parseInt(cfgCols.value),
    rows: parseInt(cfgRows.value),
    previewCount: parseInt(cfgPreview.value),
    startLevel: parseInt(cfgStartLevel.value),
    ghostEnabled: cfgGhost.value === 'on',
    lockDelay: parseInt(cfgLockDelay.value),
    das: parseInt(cfgDAS.value),
    arr: parseInt(cfgARR.value),
    skin: cfgSkin.value,
    vibration: cfgVibration.value === 'on',
    sfxVolume: parseInt(cfgSFXVolume.value),
    musicVolume: parseInt(cfgMusicVolume.value),
    gameMode: gameMode,
    cheeseLines: parseInt(cfgCheeseLines.value),
    ultraTime: parseInt(cfgUltraTime.value)
  };

  storageManager.saveSettings(settings);
}

function loadSavedSettings() {
  const settings = storageManager.loadSettings();

  cfgCols.value = settings.cols || 10;
  cfgRows.value = settings.rows || 20;
  cfgPreview.value = settings.previewCount || 5;
  cfgStartLevel.value = settings.startLevel || 1;
  cfgGhost.value = settings.ghostEnabled !== false ? 'on' : 'off';
  cfgLockDelay.value = settings.lockDelay || 1500;
  cfgDAS.value = settings.das !== undefined ? settings.das : 120;
  cfgARR.value = settings.arr !== undefined ? settings.arr : 20;
  cfgSkin.value = settings.skin || 'classic';
  cfgVibration.value = settings.vibration !== false ? 'on' : 'off';
  cfgSFXVolume.value = settings.sfxVolume !== undefined ? settings.sfxVolume : 50;
  cfgMusicVolume.value = settings.musicVolume !== undefined ? settings.musicVolume : 30;
  cfgCheeseLines.value = settings.cheeseLines || 10;
  cfgUltraTime.value = settings.ultraTime || 120;

  if (settings.gameMode) {
    gameMode = settings.gameMode;
    document.querySelectorAll('.mode-card').forEach(card => {
      card.classList.toggle('selected', card.dataset.mode === gameMode);
    });
    document.getElementById('cheeseSettings').style.display =
      gameMode === 'cheese' ? 'block' : 'none';
    document.getElementById('ultraSettings').style.display =
      gameMode === 'ultra' ? 'block' : 'none';
  }

  if (audioSystem) {
    audioSystem.setSFXVolume(settings.sfxVolume / 100 || 0.5);
    audioSystem.setMusicVolume(settings.musicVolume / 100 || 0.3);
  }
}

function loadSavedKeybindings() {
  const saved = storageManager.loadKeybindings();
  if (saved) {
    for (const action in saved) {
      saved[action] = (saved[action] || []).map(normalizeKeyName);
    }
    keyBindings = saved;
  } else {
    for (const action in keyBindings) {
      keyBindings[action] = (keyBindings[action] || []).map(normalizeKeyName);
    }
  }
  buildKeybindUI();
}

function pollGamepad() {
  if (!connectedGamepad) return;
  if (isCountingDown) return;

  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  const idx = connectedGamepad.index;
  const gp = gamepads && Number.isFinite(idx) ? gamepads[idx] : null;

  if (!gp) {
    connectedGamepad = null;
    if (gamepadIndicator) gamepadIndicator.classList.remove('connected');
    for (const action in gamepadState) {
      if (gamepadState[action]) {
        if (action === 'moveLeft' || action === 'moveRight') {
          keyState[action] = false;
          dasTimer[action] = 0;
          arrTimer[action] = 0;
        }
      }
    }
    gamepadState = {};
    lastGamepadState = {};
    return;
  }

  connectedGamepad = gp;

  for (const action in GAMEPAD_BINDINGS) {
    const buttons = GAMEPAD_BINDINGS[action];
    let pressed = false;

    for (const btnIdx of buttons) {
      if (gp.buttons[btnIdx] && gp.buttons[btnIdx].pressed) {
        pressed = true;
        break;
      }
    }

    const wasPressed = gamepadState[action] || false;

    if (pressed && !wasPressed) {
      if (action === 'moveLeft' || action === 'moveRight') {
        keyState[action] = true;
        dasTimer[action] = 0;
        arrTimer[action] = 0;
        if (action === 'moveLeft') move(-1);
        else move(1);
      } else {
        inputAction(action);
      }
    } else if (!pressed && wasPressed) {
      if (action === 'moveLeft' || action === 'moveRight') {
        keyState[action] = false;
        dasTimer[action] = 0;
        arrTimer[action] = 0;
      }
    }

    gamepadState[action] = pressed;
  }

  const threshold = 0.5;
  const leftStickX = gp.axes[0];

  if (leftStickX < -threshold) {
    if (!gamepadState['axisLeft']) {
      keyState['moveLeft'] = true;
      dasTimer['moveLeft'] = 0;
      arrTimer['moveLeft'] = 0;
      move(-1);
      gamepadState['axisLeft'] = true;
    }
  } else {
    if (gamepadState['axisLeft']) {
      keyState['moveLeft'] = false;
      dasTimer['moveLeft'] = 0;
      arrTimer['moveLeft'] = 0;
      gamepadState['axisLeft'] = false;
    }
  }

  if (leftStickX > threshold) {
    if (!gamepadState['axisRight']) {
      keyState['moveRight'] = true;
      dasTimer['moveRight'] = 0;
      arrTimer['moveRight'] = 0;
      move(1);
      gamepadState['axisRight'] = true;
    }
  } else {
    if (gamepadState['axisRight']) {
      keyState['moveRight'] = false;
      dasTimer['moveRight'] = 0;
      arrTimer['moveRight'] = 0;
      gamepadState['axisRight'] = false;
    }
  }
}

function onGamepadConnected(e) {
  const idx = e && e.gamepad ? e.gamepad.index : null;
  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  const gp = gamepads && Number.isFinite(idx) ? gamepads[idx] : (e ? e.gamepad : null);

  connectedGamepad = gp || (e ? e.gamepad : null);

  if (gamepadIndicator) gamepadIndicator.classList.add('connected');
  if (gamepadName) {
    const name = (connectedGamepad && connectedGamepad.id) ? connectedGamepad.id : 'æ‰‹æŸ„å·²è¿æ¥';
    gamepadName.textContent = name.length > 20 ? name.substring(0, 20) + '...' : name;
  }
}

function onGamepadDisconnected(e) {
  connectedGamepad = null;
  if (gamepadIndicator) gamepadIndicator.classList.remove('connected');

  for (const action in gamepadState) {
    if (gamepadState[action]) {
      if (action === 'moveLeft' || action === 'moveRight') {
        keyState[action] = false;
        dasTimer[action] = 0;
        arrTimer[action] = 0;
      }
    }
  }

  gamepadState = {};
  lastGamepadState = {};
}

function initGamepadListeners() {
  window.addEventListener('gamepadconnected', onGamepadConnected);
  window.addEventListener('gamepaddisconnected', onGamepadDisconnected);
}

function vibrate(duration) {
  if (!vibrationEnabled) return;

  const isPattern = Array.isArray(duration);
  const totalDuration = isPattern
    ? duration.reduce((s, v) => s + (Number.isFinite(v) ? v : 0), 0)
    : duration;

  const safeDuration = Number.isFinite(totalDuration) ? Math.max(0, Math.floor(totalDuration)) : 0;
  if (safeDuration <= 0 && !isPattern) return;

  if (navigator.vibrate) {
    try {
      navigator.vibrate(isPattern ? duration : safeDuration);
    } catch (e) {}
  }

  if (!connectedGamepad) return;

  const pads = navigator.getGamepads ? navigator.getGamepads() : null;
  const gp = pads && Number.isFinite(connectedGamepad.index) ? pads[connectedGamepad.index] : null;
  const actuator = gp && gp.vibrationActuator;

  if (!actuator || typeof actuator.playEffect !== 'function') return;

  const burstMs = isPattern
    ? Math.max(0, Math.min(200, duration[0] || safeDuration || 60))
    : safeDuration;

  const safeBurst = Number.isFinite(burstMs) ? Math.max(0, Math.floor(burstMs)) : 0;
  if (safeBurst <= 0) return;

  const intensity = Math.max(0, Math.min(1, safeBurst / 50));
  const params = {
    startDelay: 0,
    duration: safeBurst,
    weakMagnitude: Math.max(0, Math.min(1, intensity * 0.5)),
    strongMagnitude: Math.max(0, Math.min(1, intensity))
  };

  try {
    const r = actuator.playEffect('dual-rumble', params);
    if (r && typeof r.catch === 'function') r.catch(() => {});
  } catch (e) {}
}

function showResumePrompt(progress) {
  const modalContent = document.querySelector('.modal');
  const existingPrompt = document.querySelector('.resume-prompt');
  if (existingPrompt) existingPrompt.remove();

  const prompt = document.createElement('div');
  prompt.className = 'resume-prompt';
  const modeName = MODE_NAMES[progress.gameMode] || progress.gameMode;

  prompt.innerHTML = `
    <h4>ğŸ® å‘ç°æœªå®Œæˆçš„æ¸¸æˆ</h4>
    <p>æ¨¡å¼: ${modeName} | åˆ†æ•°: ${progress.score.toLocaleString()} | è¡Œæ•°: ${progress.lines}</p>
    <div class="actions">
      <button id="btnResumeGame" class="primary">ç»§ç»­æ¸¸æˆ</button>
      <button id="btnNewGame">å¼€å§‹æ–°æ¸¸æˆ</button>
    </div>
  `;

  modalContent.insertBefore(prompt, modalContent.querySelector('.tab-nav'));
  showSettingsOverlay(true, 'æ¬¢è¿å›æ¥');

  document.getElementById('btnResumeGame').addEventListener('click', () => {
    prompt.remove();
    if (restoreGameProgress(progress)) {
      showSettingsOverlay(false);

      running = true;
      paused = true;

      showCountdown(() => {
        paused = false;
        timerRunning = true;
        btnPlayPause.textContent = 'â¸ æš‚åœ';

        startProgressAutoSave();

        if(audioSystem) {
          audioSystem.startBGM(level);
        }

        lastTS = 0;
        requestAnimationFrame(loop);
      });
    }
  });

  document.getElementById('btnNewGame').addEventListener('click', () => {
    prompt.remove();
    storageManager.clearGameProgress();
  });
}

(function init(){
  storageManager = new StorageManager();
  loadSavedSettings();
  loadSavedKeybindings();
  audioSystem = new AudioSystem();
  audioSystem.setSFXVolume(parseInt(cfgSFXVolume.value) / 100);
  audioSystem.setMusicVolume(parseInt(cfgMusicVolume.value) / 100);
  screenShaker = new ScreenShake(document.querySelector('.playfield-wrap'));
  bgParticles = new BackgroundParticles(document.querySelector('.playfield-wrap'));
  applySkin(cfgSkin.value);
  buildPreviewCanvases();
  buildKeybindUI();
  initGamepadListeners();
  resize();
  updateModeDisplay();
  const savedProgress = loadSavedProgress();
  if (savedProgress) {
    showResumePrompt(savedProgress);
  } else {
    showSettingsOverlay(true);
  }
  btnPlayPause.textContent = 'â–¶ å¼€å§‹';
  draw();
  initOrientationDetection();
})();

})();
</script>
</body>
</html>